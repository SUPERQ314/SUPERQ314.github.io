<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/53ec4cae8bfa9696385d334042db5c18</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://superq314.github.io/atom.xml" rel="self"/>
  
  <link href="https://superq314.github.io/"/>
  <updated>2022-06-27T16:35:32.582Z</updated>
  <id>https://superq314.github.io/</id>
  
  <author>
    <name>superQ</name>
    <email>220202090@seu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>语法——SVG教程</title>
    <link href="https://superq314.github.io/2022/06/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-SVG%E6%95%99%E7%A8%8B/"/>
    <id>https://superq314.github.io/2022/06/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-SVG%E6%95%99%E7%A8%8B/</id>
    <published>2022-06-27T16:33:11.784Z</published>
    <updated>2022-06-27T16:35:32.582Z</updated>
    
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="SVG" scheme="https://superq314.github.io/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>框架</title>
    <link href="https://superq314.github.io/2022/06/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6/"/>
    <id>https://superq314.github.io/2022/06/28/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6/</id>
    <published>2022-06-27T16:10:32.364Z</published>
    <updated>2022-06-27T16:13:39.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Class-组件有哪些周期函数？分别有什么作用？"><a href="#React-Class-组件有哪些周期函数？分别有什么作用？" class="headerlink" title="React Class 组件有哪些周期函数？分别有什么作用？"></a>React Class 组件有哪些周期函数？分别有什么作用？</h2><h2 id="React-Class-组件中请求可以在-componentWillMount-中发起吗？为什么？"><a href="#React-Class-组件中请求可以在-componentWillMount-中发起吗？为什么？" class="headerlink" title="React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？"></a>React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？</h2><h2 id="React-Class-组件和-React-Hook-的区别有哪些？"><a href="#React-Class-组件和-React-Hook-的区别有哪些？" class="headerlink" title="React Class 组件和 React Hook 的区别有哪些？"></a>React Class 组件和 React Hook 的区别有哪些？</h2><h2 id="React-中高阶函数和自定义-Hook-的优缺点？"><a href="#React-中高阶函数和自定义-Hook-的优缺点？" class="headerlink" title="React 中高阶函数和自定义 Hook 的优缺点？"></a>React 中高阶函数和自定义 Hook 的优缺点？</h2><h2 id="简要说明-React-Hook-中-useState-和-useEffect-的运行原理？"><a href="#简要说明-React-Hook-中-useState-和-useEffect-的运行原理？" class="headerlink" title="简要说明 React Hook 中 useState 和 useEffect 的运行原理？"></a>简要说明 React Hook 中 useState 和 useEffect 的运行原理？</h2><h2 id="React-如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？"><a href="#React-如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？" class="headerlink" title="React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？"></a>React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？</h2><h2 id="React-Hook-中-useEffect-有哪些参数，如何检测数组依赖项的变化？"><a href="#React-Hook-中-useEffect-有哪些参数，如何检测数组依赖项的变化？" class="headerlink" title="React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？"></a>React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？</h2><h2 id="React-的-useEffect-是如何监听数组依赖项的变化的？"><a href="#React-的-useEffect-是如何监听数组依赖项的变化的？" class="headerlink" title="React 的 useEffect 是如何监听数组依赖项的变化的？"></a>React 的 useEffect 是如何监听数组依赖项的变化的？</h2><h2 id="React-Hook-和闭包有什么关联关系？"><a href="#React-Hook-和闭包有什么关联关系？" class="headerlink" title="React Hook 和闭包有什么关联关系？"></a>React Hook 和闭包有什么关联关系？</h2><h2 id="React-中-useState-是如何做数据初始化的？"><a href="#React-中-useState-是如何做数据初始化的？" class="headerlink" title="React 中 useState 是如何做数据初始化的？"></a>React 中 useState 是如何做数据初始化的？</h2><h2 id="列举你常用的-React-性能优化技巧？"><a href="#列举你常用的-React-性能优化技巧？" class="headerlink" title="列举你常用的 React 性能优化技巧？"></a>列举你常用的 React 性能优化技巧？</h2><h2 id="Vue-2-x-模板中的指令是如何解析实现的？"><a href="#Vue-2-x-模板中的指令是如何解析实现的？" class="headerlink" title="Vue 2.x 模板中的指令是如何解析实现的？"></a>Vue 2.x 模板中的指令是如何解析实现的？</h2><h2 id="简要说明-Vue-2-x-的全链路运作机制？"><a href="#简要说明-Vue-2-x-的全链路运作机制？" class="headerlink" title="简要说明 Vue 2.x 的全链路运作机制？"></a>简要说明 Vue 2.x 的全链路运作机制？</h2><h2 id="简单介绍一下-Element-UI-的框架设计？"><a href="#简单介绍一下-Element-UI-的框架设计？" class="headerlink" title="简单介绍一下 Element UI 的框架设计？"></a>简单介绍一下 Element UI 的框架设计？</h2><h2 id="如何理解-Vue-是一个渐进式框架？"><a href="#如何理解-Vue-是一个渐进式框架？" class="headerlink" title="如何理解 Vue 是一个渐进式框架？"></a>如何理解 Vue 是一个渐进式框架？</h2><h2 id="Vue-里实现跨组件通信的方式有哪些？"><a href="#Vue-里实现跨组件通信的方式有哪些？" class="headerlink" title="Vue 里实现跨组件通信的方式有哪些？"></a>Vue 里实现跨组件通信的方式有哪些？</h2><h2 id="Vue-中响应式数据是如何做到对某个对象的深层次属性的监听的？"><a href="#Vue-中响应式数据是如何做到对某个对象的深层次属性的监听的？" class="headerlink" title="Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？"></a>Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？</h2><h2 id="MVVM、MVC-和-MVP-的区别是什么？各自有什么应用场景？、"><a href="#MVVM、MVC-和-MVP-的区别是什么？各自有什么应用场景？、" class="headerlink" title="MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？、"></a>MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？、</h2><h2 id="什么是-MVVM-框架？"><a href="#什么是-MVVM-框架？" class="headerlink" title="什么是 MVVM 框架？"></a>什么是 MVVM 框架？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;React-Class-组件有哪些周期函数？分别有什么作用？&quot;&gt;&lt;a href=&quot;#React-Class-组件有哪些周期函数？分别有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;React Class 组件有哪些周期函数？分别有什么作用？&quot;&gt;</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="框架" scheme="https://superq314.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>语法——Typescript</title>
    <link href="https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-Typescript/"/>
    <id>https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-Typescript/</id>
    <published>2022-06-27T15:04:56.048Z</published>
    <updated>2022-06-27T17:09:09.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用-TypeScript-TypeScript-相对于-JavaScript-的优势是什么？"><a href="#为什么要使用-TypeScript-TypeScript-相对于-JavaScript-的优势是什么？" class="headerlink" title="为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？"></a>为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？</h2><h2 id="TypeScript-中-const-和-readonly-的区别？枚举和常量枚举的区别？接口和类型别名的区别？"><a href="#TypeScript-中-const-和-readonly-的区别？枚举和常量枚举的区别？接口和类型别名的区别？" class="headerlink" title="TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？"></a>TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？</h2><h2 id="TypeScript-中-any-类型的作用是什么？"><a href="#TypeScript-中-any-类型的作用是什么？" class="headerlink" title="TypeScript 中 any 类型的作用是什么？"></a>TypeScript 中 any 类型的作用是什么？</h2><h2 id="TypeScript-中-any、never、unknown-和-void-有什么区别？"><a href="#TypeScript-中-any、never、unknown-和-void-有什么区别？" class="headerlink" title="TypeScript 中 any、never、unknown 和 void 有什么区别？"></a>TypeScript 中 any、never、unknown 和 void 有什么区别？</h2><h2 id="TypeScript-中-interface-可以给-Function-x2F-Array-x2F-Class（Indexable）做声明吗？"><a href="#TypeScript-中-interface-可以给-Function-x2F-Array-x2F-Class（Indexable）做声明吗？" class="headerlink" title="TypeScript 中 interface 可以给 Function &#x2F; Array &#x2F; Class（Indexable）做声明吗？"></a>TypeScript 中 interface 可以给 Function &#x2F; Array &#x2F; Class（Indexable）做声明吗？</h2><h2 id="TypeScript-中可以使用-String、Number、Boolean、Symbol、Object-等给类型做声明吗？"><a href="#TypeScript-中可以使用-String、Number、Boolean、Symbol、Object-等给类型做声明吗？" class="headerlink" title="TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？"></a>TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？</h2><h2 id="TypeScript-中的-this-和-JavaScript-中的-this-有什么差异？"><a href="#TypeScript-中的-this-和-JavaScript-中的-this-有什么差异？" class="headerlink" title="TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？"></a>TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？</h2><h2 id="TypeScript-中使用-Unions-时有哪些注意事项？"><a href="#TypeScript-中使用-Unions-时有哪些注意事项？" class="headerlink" title="TypeScript 中使用 Unions 时有哪些注意事项？"></a>TypeScript 中使用 Unions 时有哪些注意事项？</h2><h2 id="TypeScript-如何设计-Class-的声明？"><a href="#TypeScript-如何设计-Class-的声明？" class="headerlink" title="TypeScript 如何设计 Class 的声明？"></a>TypeScript 如何设计 Class 的声明？</h2><h2 id="TypeScript-中如何联合枚举类型的-Key"><a href="#TypeScript-中如何联合枚举类型的-Key" class="headerlink" title="TypeScript 中如何联合枚举类型的 Key?"></a>TypeScript 中如何联合枚举类型的 Key?</h2><h2 id="TypeScript-中-、-、-、-、-等符号的含义？"><a href="#TypeScript-中-、-、-、-、-等符号的含义？" class="headerlink" title="TypeScript 中 ?.、??、!.、_、** 等符号的含义？"></a>TypeScript 中 ?.、??、!.、_、** 等符号的含义？</h2><h2 id="TypeScript-中预定义的有条件类型有哪些？"><a href="#TypeScript-中预定义的有条件类型有哪些？" class="headerlink" title="TypeScript 中预定义的有条件类型有哪些？"></a>TypeScript 中预定义的有条件类型有哪些？</h2><h2 id="简单介绍一下-TypeScript-模块的加载机制？"><a href="#简单介绍一下-TypeScript-模块的加载机制？" class="headerlink" title="简单介绍一下 TypeScript 模块的加载机制？"></a>简单介绍一下 TypeScript 模块的加载机制？</h2><h2 id="简单聊聊你对-TypeScript-类型兼容性的理解？抗变、双变、协变和逆变的简单理解？"><a href="#简单聊聊你对-TypeScript-类型兼容性的理解？抗变、双变、协变和逆变的简单理解？" class="headerlink" title="简单聊聊你对 TypeScript 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？"></a>简单聊聊你对 TypeScript 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？</h2><h2 id="TypeScript-中对象展开会有什么副作用吗？"><a href="#TypeScript-中对象展开会有什么副作用吗？" class="headerlink" title="TypeScript 中对象展开会有什么副作用吗？"></a>TypeScript 中对象展开会有什么副作用吗？</h2><h2 id="TypeScript-中-interface、type、enum-声明有作用域的功能吗？"><a href="#TypeScript-中-interface、type、enum-声明有作用域的功能吗？" class="headerlink" title="TypeScript 中 interface、type、enum 声明有作用域的功能吗？"></a>TypeScript 中 interface、type、enum 声明有作用域的功能吗？</h2><h2 id="TypeScript-中同名的-interface-或者同名的-interface-和-class-可以合并吗？"><a href="#TypeScript-中同名的-interface-或者同名的-interface-和-class-可以合并吗？" class="headerlink" title="TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？"></a>TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？</h2><h2 id="如何使-TypeScript-项目引入并识别编译为-JavaScript-的-npm-库包？"><a href="#如何使-TypeScript-项目引入并识别编译为-JavaScript-的-npm-库包？" class="headerlink" title="如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？"></a>如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？</h2><h2 id="TypeScript-的-tsconfig-json-中有哪些配置项信息？"><a href="#TypeScript-的-tsconfig-json-中有哪些配置项信息？" class="headerlink" title="TypeScript 的 tsconfig.json 中有哪些配置项信息？"></a>TypeScript 的 tsconfig.json 中有哪些配置项信息？</h2><h2 id="TypeScript-中如何设置模块导入的路径别名？"><a href="#TypeScript-中如何设置模块导入的路径别名？" class="headerlink" title="TypeScript 中如何设置模块导入的路径别名？"></a>TypeScript 中如何设置模块导入的路径别名？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么要使用-TypeScript-TypeScript-相对于-JavaScript-的优势是什么？&quot;&gt;&lt;a href=&quot;#为什么要使用-TypeScript-TypeScript-相对于-JavaScript-的优势是什么？&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="Typescript" scheme="https://superq314.github.io/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>编程范式</title>
    <link href="https://superq314.github.io/2022/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    <id>https://superq314.github.io/2022/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</id>
    <published>2022-06-27T14:20:08.193Z</published>
    <updated>2022-06-27T15:08:34.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h1><h2 id="列举你所了解的编程范式？"><a href="#列举你所了解的编程范式？" class="headerlink" title="列举你所了解的编程范式？"></a>列举你所了解的编程范式？</h2><p>编程范式（Programming paradigm）是指计算机编程的基本风格或者典型模式，可以简单理解为编程学科中实践出来的具有哲学和理论依据的一些经典原型。常见的编程范式有：</p><ul><li>面向过程（Process Oriented Programming，POP）</li><li>面向对象（Object Oriented Programming，OOP）</li><li>面向接口（Interface Oriented Programming， IOP）</li><li>面向切面（Aspect Oriented Programming，AOP）</li><li>函数式（Funtional Programming，FP）</li><li>响应式（Reactive Programming，RP）</li><li>函数响应式（Functional Reactive Programming，FRP）</li></ul><blockquote><p>阅读链接：：如果你对于编程范式的定义相对模糊，可以继续阅读 <a href="https://link.juejin.cn/?target=https://softwareengineering.stackexchange.com/questions/166442/what-is-the-precise-definition-of-programming-paradigm%23" title="https://softwareengineering.stackexchange.com/questions/166442/what-is-the-precise-definition-of-programming-paradigm#">What is the precise definition of programming paradigm?</a> 了解更多。</p></blockquote><p>不同的语言可以支持多种不同的编程范式，例如 C 语言支持 POP 范式，C++ 和 Java 语言支持 OOP 范式，Swift 语言则可以支持 FP 范式，而 Web 前端中的 JavaScript 可以支持上述列出的所有编程范式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程范式&quot;&gt;&lt;a href=&quot;#编程范式&quot; class=&quot;headerlink&quot; title=&quot;编程范式&quot;&gt;&lt;/a&gt;编程范式&lt;/h1&gt;&lt;h2 id=&quot;列举你所了解的编程范式？&quot;&gt;&lt;a href=&quot;#列举你所了解的编程范式？&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="计算机基础" scheme="https://superq314.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="编程范式" scheme="https://superq314.github.io/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://superq314.github.io/2022/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://superq314.github.io/2022/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-06-27T14:19:45.151Z</published>
    <updated>2022-06-27T16:58:53.875Z</updated>
    
    
    
    
    <category term="计算机基础" scheme="https://superq314.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="设计模式" scheme="https://superq314.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>编译原理</title>
    <link href="https://superq314.github.io/2022/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <id>https://superq314.github.io/2022/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</id>
    <published>2022-06-27T14:19:33.562Z</published>
    <updated>2022-06-27T16:57:19.532Z</updated>
    
    
    
    
    <category term="计算机基础" scheme="https://superq314.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="编译原理" scheme="https://superq314.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>语法——网络/浏览器</title>
    <link href="https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8/</id>
    <published>2022-06-27T13:46:08.731Z</published>
    <updated>2022-06-27T16:36:06.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络-x2F-浏览器"><a href="#网络-x2F-浏览器" class="headerlink" title="网络&#x2F;浏览器"></a>网络&#x2F;浏览器</h1><h2 id="说说浏览器渲染流程"><a href="#说说浏览器渲染流程" class="headerlink" title="说说浏览器渲染流程"></a>说说浏览器渲染流程</h2><h3 id="浏览器的主进程：Browser进程"><a href="#浏览器的主进程：Browser进程" class="headerlink" title="浏览器的主进程：Browser进程"></a>浏览器的主进程：Browser进程</h3><ol><li>负责下载资源</li><li>创建销毁renderer进程</li><li>负责将renderer进程生成的位图渲染到页面上</li><li>与用户交互</li></ol><h3 id="浏览器内核：renderer进程"><a href="#浏览器内核：renderer进程" class="headerlink" title="浏览器内核：renderer进程"></a>浏览器内核：renderer进程</h3><h5 id="js引擎线程"><a href="#js引擎线程" class="headerlink" title="js引擎线程"></a>js引擎线程</h5><p>由一个主线程和多个web worder线程组成，web worker线程不能操作dom</p><h5 id="GUI线程"><a href="#GUI线程" class="headerlink" title="GUI线程"></a>GUI线程</h5><p>用于解析html生成DOM树，解析css生成CSSOM,布局layout、绘制paint。回流和重绘依赖该线程</p><h5 id="事件线程"><a href="#事件线程" class="headerlink" title="事件线程"></a>事件线程</h5><p>当事件触发时，该线程将事件的回调函数放入callback queue（任务队列）中，等待js引擎线程处理</p><h5 id="定时触发线程"><a href="#定时触发线程" class="headerlink" title="定时触发线程"></a>定时触发线程</h5><p>setTimeout和setInterval由该线程来记时，记时结束，将回调函数放入任务队列</p><h5 id="http请求线程"><a href="#http请求线程" class="headerlink" title="http请求线程"></a>http请求线程</h5><p>每有一个http请求就开一个该线程，每当检测到状态变更就会产生一个状态变更事件，如果这个事件由对应的回掉函数，将这个函数放入任务队列</p><h5 id="任务队列轮询线程"><a href="#任务队列轮询线程" class="headerlink" title="任务队列轮询线程"></a>任务队列轮询线程</h5><p>用于轮询监听任务队列</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>获取html文件</li><li>从上到下解析html</li><li>并行请求资源(css资源不会阻塞html解析，但是会阻塞页面渲染。js资源会组织html解析）</li><li>生成DOM tree 和 style rules</li><li>构建render tree</li><li>执行布局过程(layout、也叫回流)，确定元素在屏幕上的具体坐标</li><li>绘制到屏幕上(paint)</li></ol><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h5 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h5><p>当初始的HTML文档被完全加载和解析完成(script脚本执行完，所属的script脚本之前的样式表加载解析完成)之后，DOMContentLoaded事件被触发</p><h5 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h5><p>所有资源加载完成触发window的onload事件</p><h5 id="参考流程图：www-processon-com-view-5a6861…"><a href="#参考流程图：www-processon-com-view-5a6861…" class="headerlink" title="参考流程图：www.processon.com/view/5a6861…"></a>参考流程图：<a href="https://link.juejin.cn/?target=https://www.processon.com/view/5a68611fe4b010a6e72f0d6f" title="https://www.processon.com/view/5a68611fe4b010a6e72f0d6f">www.processon.com/view/5a6861…</a></h5><h2 id="说说http2-0"><a href="#说说http2-0" class="headerlink" title="说说http2.0"></a>说说http2.0</h2><p>http2.0是对SPDY协议的一个升级版。和http1.0相比主要有以下特性：</p><ul><li>二进制分帧</li><li>首部压缩</li><li>多路复用</li><li>请求优先级</li><li>服务端推送(server push)</li></ul><p>详细可参考： <a href="https://juejin.cn/post/6844903545532071943" title="https://juejin.cn/post/6844903545532071943">HTTP—-HTTP2.0新特性</a></p><h2 id="如何处理浏览器中表单项的密码自动填充问题"><a href="#如何处理浏览器中表单项的密码自动填充问题" class="headerlink" title="如何处理浏览器中表单项的密码自动填充问题"></a>如何处理浏览器中表单项的密码自动填充问题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络-x2F-浏览器&quot;&gt;&lt;a href=&quot;#网络-x2F-浏览器&quot; class=&quot;headerlink&quot; title=&quot;网络&amp;#x2F;浏览器&quot;&gt;&lt;/a&gt;网络&amp;#x2F;浏览器&lt;/h1&gt;&lt;h2 id=&quot;说说浏览器渲染流程&quot;&gt;&lt;a href=&quot;#说说浏览器渲染流程&quot;</summary>
      
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="网络/浏览器" scheme="https://superq314.github.io/tags/%E7%BD%91%E7%BB%9C-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>语法——ECMAScript6</title>
    <link href="https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-ECMAScript6/"/>
    <id>https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-ECMAScript6/</id>
    <published>2022-06-27T13:38:09.285Z</published>
    <updated>2022-06-27T16:42:50.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ECMAScript6"><a href="#ECMAScript6" class="headerlink" title="ECMAScript6"></a>ECMAScript6</h1><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><ol><li><p>CommonJS输出的是值的拷贝，ES6模块输出的是值的引用。</p><p>也就是说CommonJS引用后改变模块内变量的值，其他引用模块不会改变，而ES6模块会改变。</p></li><li><p>CommonJS是运行时加载，ES6模块是编译时输出接口。</p><p>之所以Webpack的Tree Shaking是基于ES6的，就是因为ES6在编译的时候就能确定依赖。因为使用babel-preset-2015这个预设默认是会把ES6模块编译为CommonJS的，所以想使用Tree Shaking还需要手动修改这个预设。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        exclude: /(node_modules|bower_components)/,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: &#x27;babel-loader&#x27;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [[&#x27;babel-preset-es2015&#x27;, &#123;modules: false&#125;]],</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async函数实现原理"><a href="#async函数实现原理" class="headerlink" title="async函数实现原理"></a>async函数实现原理</h2><p>async函数是基于generator实现，所以涉及到generator相关知识。在没有async函数之前，通常使用co库来执行generator，所以通过co我们也能模拟async的实现。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Asyncfn() &#123;</span><br><span class="line">  return co(function*() &#123;</span><br><span class="line">    //.....</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function co(gen) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    const fn = gen();</span><br><span class="line">    function next(data) &#123;</span><br><span class="line">      let &#123; value, done &#125; = fn.next(data);</span><br><span class="line">      if (done) return resolve(value);</span><br><span class="line">      Promise.resolve(value).then(res =&gt; &#123;</span><br><span class="line">        next(res);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ECMAScript6&quot;&gt;&lt;a href=&quot;#ECMAScript6&quot; class=&quot;headerlink&quot; title=&quot;ECMAScript6&quot;&gt;&lt;/a&gt;ECMAScript6&lt;/h1&gt;&lt;h2 id=&quot;ES6-模块与-CommonJS-模块的差异&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="ECMAScript6" scheme="https://superq314.github.io/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>前端开发——性能优化</title>
    <link href="https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2022-06-27T13:37:52.932Z</published>
    <updated>2022-06-27T15:08:27.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="性能优化之dns-prefetch、prefetch、preload、defer、async"><a href="#性能优化之dns-prefetch、prefetch、preload、defer、async" class="headerlink" title="性能优化之dns-prefetch、prefetch、preload、defer、async"></a>性能优化之dns-prefetch、prefetch、preload、defer、async</h2><h3 id="dns-prefetch"><a href="#dns-prefetch" class="headerlink" title="dns-prefetch"></a>dns-prefetch</h3><p>域名转化为ip是一个比较耗时的过程，dns-prefetch能让浏览器空闲的时候帮你做这件事。尤其大型网站会使用多域名，这时候更加需要dns预取。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//来自百度首页</span><br><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//m.baidu.com&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="prefetch"><a href="#prefetch" class="headerlink" title="prefetch"></a>prefetch</h3><p>prefetch一般用来预加载可能使用的资源，一般是对用户行为的一种判断，浏览器会在空闲的时候加载prefetch的资源。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;http://www.example.com/&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h3><p>和prefetch不同，prefecth通常是加载接下来可能用到的页面资源，而preload是加载当前页面要用的脚本、样式、字体、图片等资源。所以preload不是空闲时加载，它的优先级更强，并且会占用http请求数量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&#x27;preload&#x27; href=&#x27;style.css&#x27; as=&quot;style&quot; onload=&quot;console.log(&#x27;style loaded&#x27;)&quot;</span><br></pre></td></tr></table></figure><p>as值包括</p><ul><li>“script”</li><li>“style”</li><li>“image”</li><li>“media”</li><li>“document”<br>onload方法是资源加载完成的回调函数</li></ul><h3 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//defer</span><br><span class="line">&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">//async</span><br><span class="line">&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>defer和async都是异步(并行)加载资源，不同点是async是加载完立即执行，而defer是加载完不执行，等到所有元素解析完再执行，也就是DOMContentLoaded事件触发之前。</p><p>因为async加载的资源是加载完执行，所以它比不能保证顺序，而defer会按顺序执行脚本。</p><h2 id="React性能优化"><a href="#React性能优化" class="headerlink" title="React性能优化"></a>React性能优化</h2><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><p>举例：下面是antd-design-mobile的Modal组件中对的内部蒙层组件的处理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import * as React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export interface lazyRenderProps &#123;</span><br><span class="line">  style: &#123;&#125;;</span><br><span class="line">  visible?: boolean;</span><br><span class="line">  className?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class LazyRender extends React.Component&lt;lazyRenderProps, any&gt; &#123;</span><br><span class="line">  shouldComponentUpdate(nextProps: lazyRenderProps) &#123;</span><br><span class="line">    return !!nextProps.visible;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const props: any = &#123; ...this.props &#125;;</span><br><span class="line">    delete props.visible;</span><br><span class="line">    return &lt;div &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="immutable"><a href="#immutable" class="headerlink" title="immutable"></a>immutable</h3><p>像上面这种只比较了一个visible属性，并且它是string类型，如果是一个object类型那么就不能直接比较了，这时候使用immutable库更好一些。</p><p>immutable优势：</p><ul><li>性能更好</li><li>更加安全<br>immutable劣势：</li><li>库比较大(压缩后大约16k)</li><li>api和js不兼容</li></ul><p>解决方案：seamless-immutable<br>seamless-immutable这个库没有完整实现Persistent Data Structure，而是使用了Object.defineProperty扩展了JS的Object和Array对象，所以保持了相同的Api，同时库的代码量更少，压缩后大约2k</p><h3 id="基于key的优化"><a href="#基于key的优化" class="headerlink" title="基于key的优化"></a>基于key的优化</h3><p>文档中已经强调，key需要保证在当前的作用域中唯一，不要使用当前循环的index(尤其在长列表中)。<br>参考 <a href="https://link.juejin.cn/?target=https://reactjs.org/docs/reconciliation.html%23keys" title="https://reactjs.org/docs/reconciliation.html#keys">reactjs.org&#x2F;docs&#x2F;reconc…</a></p><h2 id="编译性能"><a href="#编译性能" class="headerlink" title="编译性能"></a>编译性能</h2><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h2 id="白屏检测"><a href="#白屏检测" class="headerlink" title="白屏检测"></a>白屏检测</h2><h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;性能优化&quot;&gt;&lt;a href=&quot;#性能优化&quot; class=&quot;headerlink&quot; title=&quot;性能优化&quot;&gt;&lt;/a&gt;性能优化&lt;/h1&gt;&lt;h2 id=&quot;性能优化之dns-prefetch、prefetch、preload、defer、async&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="性能优化" scheme="https://superq314.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>语法——NodeJS</title>
    <link href="https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-NodeJS/"/>
    <id>https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-NodeJS/</id>
    <published>2022-06-27T13:37:40.287Z</published>
    <updated>2022-06-27T16:35:43.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h1><h2 id="浏览器和NodeJS中的事件循环（EventLoop）"><a href="#浏览器和NodeJS中的事件循环（EventLoop）" class="headerlink" title="浏览器和NodeJS中的事件循环（EventLoop）"></a>浏览器和NodeJS中的事件循环（EventLoop）</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/5/16d99c58b974a59d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>如图：浏览器中相对简单，共有两个事件队列，当主线程空闲时会清空Microtask queue(微任务队列)依次执行Task Queue(宏任务队列)中的回调函数，每执行完一个之后再清空Microtask queue。</p><blockquote><p>“当前执行栈” -&gt; “micro-task” -&gt; “task queue中取一个回调” -&gt; “micro-task” -&gt; … (不断消费task queue) -&gt; “micro-task”</p></blockquote><h3 id="NodeJS-1"><a href="#NodeJS-1" class="headerlink" title="NodeJS"></a>NodeJS</h3><p>node中机制和浏览器有一些差异。node中的task queue是分为几个阶段，清空micro-task是在一个阶段结束之后(浏览器中是每一个任务结束之后)，各个阶段如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │&lt;————— 执行 setTimeout()、setInterval() 的回调</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|             |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     pending callbacks │&lt;————— 执行由上一个 Tick 延迟下来的 I/O 回调（待完善，可忽略）</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|             |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │&lt;————— 内部调用（可忽略）</span><br><span class="line">│  └──────────┬────────────┘   </span><br><span class="line">|             |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调</span><br><span class="line">|             |                   ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │ - (执行几乎所有的回调，除了 close callbacks 以及 timers 调度的回调和 setImmediate() 调度的回调，在恰当的时机将会阻塞在此阶段)</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │ </span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │ </span><br><span class="line">│             |                   |               | </span><br><span class="line">|             |                   └───────────────┘</span><br><span class="line">|             |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调</span><br><span class="line">|  ┌──────────┴────────────┐  </span><br><span class="line">│  │        check          │&lt;————— setImmediate() 的回调将会在这个阶段执行</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">|             |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │&lt;————— socket.on(&#x27;close&#x27;, ...)</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p>这里我们主要关注其中的3个阶段：timer、poll和check，其中poll队列相对复杂：</p><blockquote><p>轮询 阶段有两个重要的功能：</p><p>1、计算应该阻塞和轮询 I&#x2F;O 的时间。</p><p>2、然后，处理 轮询 队列里的事件。</p></blockquote><blockquote><p>当事件循环进入 轮询 阶段且 没有计划计时器时 ，将发生以下两种情况之一：</p><p>1、如果轮询队列不是空的，事件循环将循环访问其回调队列并同步执行它们，直到队列已用尽，或者达到了与系统相关的硬限制。</p><p>2、如果轮询队列是空的，还有两件事发生：</p><p>a、如果脚本已按 setImmediate() 排定，则事件循环将结束 轮询 阶段，并继续 check阶段以执行这些计划脚本。</p><p>b、如果脚本 尚未 按 setImmediate()排定，则事件循环将等待回调添加到队列中，然后立即执行。</p></blockquote><blockquote><p>一旦轮询队列为空，事件循环将检查已达到时间阈值的计时器。如果一个或多个计时器已准备就绪，则事件循环将绕回计时器阶段以执行这些计时器的回调。</p></blockquote><p>细节请参考<a href="https://link.juejin.cn/?target=https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/%23poll" title="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#poll">The Node.js Event Loop, Timers, and process.nextTick()</a><br>中文：<a href="https://link.juejin.cn/?target=https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/" title="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/">Node.js 事件循环，定时器和 process.nextTick()</a></p><h3 id="通过程序理解浏览器和node中的差异"><a href="#通过程序理解浏览器和node中的差异" class="headerlink" title="通过程序理解浏览器和node中的差异"></a>通过程序理解浏览器和node中的差异</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;timer1&quot;);</span><br><span class="line">  Promise.resolve().then(function() &#123;</span><br><span class="line">    console.log(&quot;promise1&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&quot;timer2&quot;);</span><br><span class="line">  Promise.resolve().then(function() &#123;</span><br><span class="line">    console.log(&quot;promise2&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 0);</span><br></pre></td></tr></table></figure><p>在浏览器中的顺序是：timer1 -&gt; promise1 -&gt; timer2 -&gt; pormise2</p><p>node中顺序是： timer1 -&gt; timer2 -&gt; promise1 -&gt; promise2</p><p><em><strong>这道题目很好的说明了node中的micro-task是在一个阶段的任务执行完之后才清空的。</strong></em></p><h2 id="实现一个node中的EventEmiter"><a href="#实现一个node中的EventEmiter" class="headerlink" title="实现一个node中的EventEmiter"></a>实现一个node中的EventEmiter</h2><p>简单实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class EventsEmiter &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  on(type, fn) &#123;</span><br><span class="line">    const events = this.events;</span><br><span class="line">    if (!events[type]) &#123;</span><br><span class="line">      events[type] = [fn];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      events[type].push(fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  emit(type, ...res) &#123;</span><br><span class="line">    const events = this.events;</span><br><span class="line">    if (events[type]) &#123;</span><br><span class="line">      events[type].forEach(fn =&gt; fn.apply(this, res));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  remove(type, fn) &#123;</span><br><span class="line">    const events = this.events;</span><br><span class="line">    if (events[type]) &#123;</span><br><span class="line">      events[type] = events[type].filer(lisener =&gt; lisener !== fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现一个node中util模块的promisify方法"><a href="#实现一个node中util模块的promisify方法" class="headerlink" title="实现一个node中util模块的promisify方法"></a>实现一个node中util模块的promisify方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fs = require(&quot;fs&quot;);</span><br><span class="line">let read = fs.readFile;</span><br><span class="line"></span><br><span class="line">function promisify(fn) &#123;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      fn(...args, (err, data) =&gt; &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 回调用法</span><br><span class="line">// read(&quot;./test.json&quot;, (err, data) =&gt; &#123;</span><br><span class="line">//   if (err) &#123;</span><br><span class="line">//     console.error(&quot;err&quot;, err);</span><br><span class="line">//   &#125;</span><br><span class="line">//   console.log(&quot;data&quot;, data.toString());</span><br><span class="line">// &#125;);</span><br><span class="line"></span><br><span class="line">// promise用法</span><br><span class="line">let readPromise = promisify(read);</span><br><span class="line"></span><br><span class="line">readPromise(&quot;./test.json&quot;).then(res =&gt; &#123;</span><br><span class="line">  console.log(&quot;data&quot;, res.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何实现一个自定义流"><a href="#如何实现一个自定义流" class="headerlink" title="如何实现一个自定义流"></a>如何实现一个自定义流</h2><p>根据所创建的流类型，新的流类必须实现一个或多个特定的方法，如下图所示:</p><table><thead><tr><th>用例</th><th>类</th><th>需实现的方法</th></tr></thead><tbody><tr><td>只读流</td><td><a href="/s/YuDKX1" title="/s/YuDKX1"><code>Readable</code></a></td><td><code>&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;/s/5hv4Rd&quot; title=&quot;/s/5hv4Rd&quot;&gt;_read&lt;/a&gt;</code></td></tr><tr><td>只写流</td><td><a href="/s/9JUnJ8" title="/s/9JUnJ8"><code>Writable</code></a></td><td><code>&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;/s/8MvCPB&quot; title=&quot;/s/8MvCPB&quot;&gt;_write&lt;/a&gt;</code>,<code>&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;/s/7qpAhU&quot; title=&quot;/s/7qpAhU&quot;&gt;_writev&lt;/a&gt;</code>,<code>&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;/s/ehUmqz&quot; title=&quot;/s/ehUmqz&quot;&gt;_final&lt;/a&gt;</code></td></tr><tr><td>可读可写流</td><td><a href="/s/2iRabr" title="/s/2iRabr"><code>Duplex</code></a></td><td><code>&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;/s/5hv4Rd&quot; title=&quot;/s/5hv4Rd&quot;&gt;_read&lt;/a&gt;</code>,<code>&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;/s/8MvCPB&quot; title=&quot;/s/8MvCPB&quot;&gt;_write&lt;/a&gt;</code>,<code>&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;/s/7qpAhU&quot; title=&quot;/s/7qpAhU&quot;&gt;_writev&lt;/a&gt;</code>,<code>&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;/s/ehUmqz&quot; title=&quot;/s/ehUmqz&quot;&gt;_final&lt;/a&gt;</code></td></tr><tr><td>对写入的数据进行操作，然后读取结果</td><td><a href="/s/fhVJQM" title="/s/fhVJQM"><code>Transform</code></a></td><td><code>&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;/s/N8nFbP&quot; title=&quot;/s/N8nFbP&quot;&gt;_transform&lt;/a&gt;</code>,<code>&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;/s/mErApk&quot; title=&quot;/s/mErApk&quot;&gt;_flush&lt;/a&gt;</code>,<code>&lt;a target=&quot;_blank&quot; rel=&quot;nofollow&quot; href=&quot;/s/ehUmqz&quot; title=&quot;/s/ehUmqz&quot;&gt;_final&lt;/a&gt;</code></td></tr></tbody></table><p>以双工流为例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; Duplex &#125; = require(&#x27;stream&#x27;);</span><br><span class="line"></span><br><span class="line">class Myduplex extends  Duplex &#123;</span><br><span class="line">  constructor(arr, opt) &#123;</span><br><span class="line">    super(opt);</span><br><span class="line">    this.arr = arr</span><br><span class="line">    this.index = 0</span><br><span class="line">  &#125;</span><br><span class="line">  //实现可读流部分</span><br><span class="line">  _read(size) &#123;</span><br><span class="line">    this.index++</span><br><span class="line">    if(this.index === 3) &#123;</span><br><span class="line">        this.push(null) </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.push(this.index.toString())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //实现可写流</span><br><span class="line">  _write(chunk, encoding, callback) &#123;</span><br><span class="line">    this.arr.push(chunk.toString())</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多内容可以参考我的另一篇文章：<a href="https://juejin.cn/post/6844903557066391565" title="https://juejin.cn/post/6844903557066391565">说说node中可读流和可写流</a><br>和 <a href="https://link.juejin.cn/?target=https://nodejs.org/dist/latest-v12.x/docs/api/stream.html" title="https://nodejs.org/dist/latest-v12.x/docs/api/stream.html">nodejs官网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;NodeJS&quot;&gt;&lt;a href=&quot;#NodeJS&quot; class=&quot;headerlink&quot; title=&quot;NodeJS&quot;&gt;&lt;/a&gt;NodeJS&lt;/h1&gt;&lt;h2 id=&quot;浏览器和NodeJS中的事件循环（EventLoop）&quot;&gt;&lt;a href=&quot;#浏览器和NodeJS</summary>
      
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="NodeJS" scheme="https://superq314.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础——算法</title>
    <link href="https://superq314.github.io/2022/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E7%AE%97%E6%B3%95/"/>
    <id>https://superq314.github.io/2022/06/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E7%AE%97%E6%B3%95/</id>
    <published>2022-06-27T13:37:24.838Z</published>
    <updated>2022-06-27T16:58:38.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="实现一个reduce方法"><a href="#实现一个reduce方法" class="headerlink" title="实现一个reduce方法"></a>实现一个reduce方法</h2><p>注意边界条件：1、数组长度为0，并且reduce没有传入初始参数时，抛出错误。2、reduce有返回值。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array.prototype.myReduce = function(fn, initial) &#123;</span><br><span class="line">  if (this.length === 0 &amp;&amp; !initial) &#123;</span><br><span class="line">    throw new Error(&quot;no initial and array is empty&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  let start = 1;</span><br><span class="line">  let pre = this[0];</span><br><span class="line">  if (initial) &#123;</span><br><span class="line">    start = 0;</span><br><span class="line">    pre = initial;</span><br><span class="line">  &#125;</span><br><span class="line">  for (let i = start; i &lt; this.length; i++) &#123;</span><br><span class="line">    let current = this[i];</span><br><span class="line">    pre = fn.call(this, pre, current, i);</span><br><span class="line">  &#125;</span><br><span class="line">  return pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现一个promise-all方法，要求保留错误并且并发数为3"><a href="#实现一个promise-all方法，要求保留错误并且并发数为3" class="headerlink" title="实现一个promise.all方法，要求保留错误并且并发数为3"></a>实现一个promise.all方法，要求保留错误并且并发数为3</h2><p>标准的all方法是遇到错误会立即将promise置为失败态，并触发error回调。保留错误的定义为：promise遇到错误保存在返回的结果中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function promiseall(promises) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    let flag = 0;</span><br><span class="line">    let taskQueue = promises.slice(0, 3); //任务队列，初始为最大并发数3</span><br><span class="line">    let others = promises.slice(3); //排队的任务</span><br><span class="line"></span><br><span class="line">    taskQueue.forEach((promise, i) =&gt; &#123;</span><br><span class="line">      singleTaskRun(promise, i);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let i = 3; //新的任务从索引3开始</span><br><span class="line">    function next() &#123;</span><br><span class="line">      if (others.length === 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      const newTask = others.shift();</span><br><span class="line">      singleTaskRun(newTask, i++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function singleTaskRun(promise, i) &#123;</span><br><span class="line">      promise</span><br><span class="line">        .then(res =&gt; &#123;</span><br><span class="line">          check();</span><br><span class="line">          result[i] = res;</span><br><span class="line">          next();</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(err =&gt; &#123;</span><br><span class="line">          check();</span><br><span class="line">          result[i] = err;</span><br><span class="line">          next();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    function check() &#123;</span><br><span class="line">      flag++;</span><br><span class="line">      if (flag === promises.length) &#123;</span><br><span class="line">        resolve(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;1&quot;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">let p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;2&quot;);</span><br><span class="line">  &#125;, 1500);</span><br><span class="line">&#125;);</span><br><span class="line">let p3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;3&quot;);</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">let p4 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;4&quot;);</span><br><span class="line">  &#125;, 2500);</span><br><span class="line">&#125;);</span><br><span class="line">let p_e = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  // throw new Error(&quot;出错&quot;);</span><br><span class="line">  reject(&quot;错误&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">let p5 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&quot;5&quot;);</span><br><span class="line">  &#125;, 5000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let all = promiseall([p_e, p1, p3, p2, p4, p5]);</span><br><span class="line">all.then(</span><br><span class="line">  data =&gt; &#123;</span><br><span class="line">    console.log(&quot;data&quot;, data);    // [ &#x27;错误&#x27;, &#x27;1&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;4&#x27;, &#x27;5&#x27; ]</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="不用递归函数求一个二叉树的高度"><a href="#不用递归函数求一个二叉树的高度" class="headerlink" title="不用递归函数求一个二叉树的高度"></a>不用递归函数求一个二叉树的高度</h2><p>先看一下递归的实现(二叉树的深度优先遍历)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getBinaryTreeHeigth(node) &#123;</span><br><span class="line">  let maxDeep = 0;</span><br><span class="line">  function next(n, deep) &#123;</span><br><span class="line">    deep++;</span><br><span class="line">    if (n.l) &#123;</span><br><span class="line">      let newDeep = next(n.l, deep);</span><br><span class="line">      if (newDeep &gt; maxDeep) &#123;</span><br><span class="line">        maxDeep = newDeep;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n.r) &#123;</span><br><span class="line">      let newDeep = next(n.r, deep);</span><br><span class="line">      if (newDeep &gt; maxDeep) &#123;</span><br><span class="line">        maxDeep = newDeep;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return deep;</span><br><span class="line">  &#125;</span><br><span class="line">  next(node, 0);</span><br><span class="line">  return maxDeep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Node(v, l, r) &#123;</span><br><span class="line">  this.v = v;</span><br><span class="line">  this.l = l;</span><br><span class="line">  this.r = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归的实现(二叉树的广度优先遍历)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getBinaryTreeHeigth(node) &#123;</span><br><span class="line">  if (!node) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  const queue = [node];</span><br><span class="line">  let deep = 0;</span><br><span class="line">  while (queue.length) &#123;</span><br><span class="line">    deep++;</span><br><span class="line">    for (let i = 0; i &lt; queue.length; i++) &#123;</span><br><span class="line">      const cur = queue.pop();</span><br><span class="line">      if (cur.l) &#123;</span><br><span class="line">        queue.unshift(cur.l);</span><br><span class="line">      &#125;</span><br><span class="line">      if (cur.r) &#123;</span><br><span class="line">        queue.unshift(cur.r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return deep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Node(v, l, r) &#123;</span><br><span class="line">  this.v = v;</span><br><span class="line">  this.l = l;</span><br><span class="line">  this.r = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js中求两个大数相加"><a href="#js中求两个大数相加" class="headerlink" title="js中求两个大数相加"></a>js中求两个大数相加</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2,返回它们的和，仍用字符串表示。</p><blockquote><p>输入：num1 &#x3D; ‘1234’, num2 &#x3D; ‘987’</p><p>输出：’2221’</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function bigIntAdd(str1, str2) &#123;</span><br><span class="line">  let result = [];</span><br><span class="line">  let ary1 = str1.split(&quot;&quot;);</span><br><span class="line">  let ary2 = str2.split(&quot;&quot;);</span><br><span class="line">  let flag = false; //是否进位</span><br><span class="line">  while (ary1.length || ary2.length) &#123;</span><br><span class="line">    let result_c = sigle_pos_add(ary1.pop(), ary2.pop());</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">      result_c = result_c + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    result.unshift(result_c % 10);</span><br><span class="line"></span><br><span class="line">    if (result_c &gt;= 10) &#123;</span><br><span class="line">      flag = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      flag = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if(flag) &#123;</span><br><span class="line">    result.unshift(&#x27;1&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  return result.join(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sigle_pos_add(str1_c, str2_c) &#123;</span><br><span class="line">  let l = (r = 0);</span><br><span class="line">  if (str1_c) &#123;</span><br><span class="line">    l = Number(str1_c);</span><br><span class="line">  &#125;</span><br><span class="line">  if (str2_c) &#123;</span><br><span class="line">    r = Number(str2_c);</span><br><span class="line">  &#125;</span><br><span class="line">  return l + r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const str1 = &quot;1234&quot;;</span><br><span class="line">const str2 = &quot;987654321&quot;;</span><br><span class="line">const str3 = &quot;4566786445677555&quot;;</span><br><span class="line">const str4 = &quot;987&quot;;</span><br><span class="line"></span><br><span class="line">console.log(bigIntAdd(str1, str4))  //&#x27;2221&#x27;</span><br><span class="line">console.log(bigIntAdd(str2, str3))  //&#x27;4566787433331876&#x27;</span><br></pre></td></tr></table></figure><h2 id="实现一个数组随机打乱算法"><a href="#实现一个数组随机打乱算法" class="headerlink" title="实现一个数组随机打乱算法"></a>实现一个数组随机打乱算法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function disOrder(ary) &#123;</span><br><span class="line">  for (let i = 0; i &lt; ary.length; i++) &#123;</span><br><span class="line">    let randomIndex = Math.floor(Math.random() * ary.length);</span><br><span class="line">    swap(ary, i, randomIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function swap(ary, a, b) &#123;</span><br><span class="line">  let temp = ary[a];</span><br><span class="line">  ary[a] = ary[b];</span><br><span class="line">  ary[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ary = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];</span><br><span class="line">disOrder(ary);</span><br><span class="line"></span><br><span class="line">console.log(ary);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="给数字增加“逗号”分隔"><a href="#给数字增加“逗号”分隔" class="headerlink" title="给数字增加“逗号”分隔"></a>给数字增加“逗号”分隔</h2><blockquote><p>输入： ‘“123456789.012”‘  输出：123,456,789.012</p></blockquote><h4 id="正则解法："><a href="#正则解法：" class="headerlink" title="正则解法："></a>正则解法：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function parseNumber(num) &#123;</span><br><span class="line">  if (!num) return &quot;&quot;;</span><br><span class="line">  return num.replace(/(\d)(?=(\d&#123;3&#125;)+(\.|$))/g, &quot;$1,&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="非正则："><a href="#非正则：" class="headerlink" title="非正则："></a>非正则：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function formatNumber(num) &#123;</span><br><span class="line">  if (!num) return &quot;&quot;;</span><br><span class="line">  let [int, float] = num.split(&quot;.&quot;);</span><br><span class="line">  let intArr = int.split(&quot;&quot;);</span><br><span class="line">  let result = [];</span><br><span class="line">  let i = 0;</span><br><span class="line">  while (intArr.length) &#123;</span><br><span class="line">    if (i !== 0 &amp;&amp; i % 3 === 0) &#123;</span><br><span class="line">      result.unshift(intArr.pop() + &quot;,&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.unshift(intArr.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result.join(&quot;&quot;) + &quot;.&quot; + (float ? float : &quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：寒东设计师<br>链接：<a href="https://juejin.cn/post/6844903969345503240">https://juejin.cn/post/6844903969345503240</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处</p><ul><li><a href="https://juejin.cn/post/6844903969345503240#6-1" title="#6-1">实现一个reduce方法</a></li><li><a href="https://juejin.cn/post/6844903969345503240#6-2" title="#6-2">实现一个promise.all方法，要求保留错误并且并发数为3</a></li><li><a href="https://juejin.cn/post/6844903969345503240#6-3" title="#6-3">不用递归函数求一个二叉树的高度</a></li><li><a href="https://juejin.cn/post/6844903969345503240#6-4" title="#6-4">js中求两个大数相加</a></li><li><a href="https://juejin.cn/post/6844903969345503240#6-5" title="#6-5">实现一个数组随机打乱算法</a></li><li><a href="https://juejin.cn/post/6844903969345503240#6-6" title="#6-6">给数字增加“逗号”分隔符</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;h2 id=&quot;实现一个reduce方法&quot;&gt;&lt;a href=&quot;#实现一个reduce方法&quot; class=&quot;headerlink&quot; title=&quot;实</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://superq314.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="算法" scheme="https://superq314.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端开发——CSS</title>
    <link href="https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-CSS/"/>
    <id>https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-CSS/</id>
    <published>2022-06-27T13:28:26.818Z</published>
    <updated>2022-06-27T16:52:42.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="如何实现一个上中下三行布局，顶部和底部最小高度是-100px，中间自适应"><a href="#如何实现一个上中下三行布局，顶部和底部最小高度是-100px，中间自适应" class="headerlink" title="如何实现一个上中下三行布局，顶部和底部最小高度是 100px，中间自适应?"></a>如何实现一个上中下三行布局，顶部和底部最小高度是 100px，中间自适应?</h2><h2 id="如何判断一个元素-CSS-样式溢出，从而可以选择性的加-title-或者-Tooltip"><a href="#如何判断一个元素-CSS-样式溢出，从而可以选择性的加-title-或者-Tooltip" class="headerlink" title="如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip?"></a>如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip?</h2><h2 id="如何让-CSS-元素左侧自动溢出（…-溢出在左侧）"><a href="#如何让-CSS-元素左侧自动溢出（…-溢出在左侧）" class="headerlink" title="如何让 CSS 元素左侧自动溢出（… 溢出在左侧）"></a>如何让 CSS 元素左侧自动溢出（… 溢出在左侧）</h2><h2 id="CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3-新增伪类有哪些？"><a href="#CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3-新增伪类有哪些？" class="headerlink" title="CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3 新增伪类有哪些？"></a>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3 新增伪类有哪些？</h2><p>1）id 选择器（#myid）<br>2）类选择器（.myclassname）<br>3）标签选择器（div，h1，p）<br>4）相邻选择器（h1 + p）<br>5）子选择器（ul &gt; li）<br>6）后代选择器（li a）<br>7）通配符选择器（* ）<br>8）属性选择器（ a[rel &#x3D; “external”]）<br>9）伪类选择器（a: hover, li: nth - child）</p><h2 id="CSS3新增伪类举例："><a href="#CSS3新增伪类举例：" class="headerlink" title="CSS3新增伪类举例："></a>CSS3新增伪类举例：</h2><p>p:first-of-type   选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素；<br>p:last-of-type   选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素；<br>p:only-of-type  选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素；<br>p:only-child    选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素；<br>p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素；<br>:enabled  :disabled 控制表单控件的禁用状态；<br>:checked        单选框或复选框被选中。</p><h2 id="如何居中div？-如何居中一个浮动元素？"><a href="#如何居中div？-如何居中一个浮动元素？" class="headerlink" title="如何居中div？ 如何居中一个浮动元素？"></a>如何居中div？ 如何居中一个浮动元素？</h2><p>给div 设置一个宽度，然后添加 margin:0 auto 属性；div{width:200px; margin:0 auto; }</p><h2 id="居中一个浮动元素"><a href="#居中一个浮动元素" class="headerlink" title="居中一个浮动元素"></a>居中一个浮动元素</h2><p>确定容器的宽高  宽500 高300的层，设置层的外边距<br>.div{width:500px;height:300px;margin:-150px 0 0 -250px;position:relative;background:green；left：50%；头：50%}</p><h2 id="css3有哪些新特性？"><a href="#css3有哪些新特性？" class="headerlink" title="css3有哪些新特性？"></a>css3有哪些新特性？</h2><p>CSS3 实现圆角（border-radius:8px;），阴影（box-shadow:10px）,对文字加特效（text-shadow）,线性渐变（gradient），旋转（transform）<br>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);&#x2F;&#x2F;旋转，缩放，定位，倾斜<br>增加了更多的 css 选择器 多背景 rgba</p><h2 id="为什么要初始化-CSS-样式"><a href="#为什么要初始化-CSS-样式" class="headerlink" title="为什么要初始化 CSS 样式"></a>为什么要初始化 CSS 样式</h2><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。<br>当然，初始化样式会对 SEO 有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。<br>最简单的初始化方法是：*{padding:0;margin:0} (不建议)<br>淘宝的样式初始化：<br>body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, <br>        textarea, th, td { margin:0; padding:0; } <br>        body, button, input, select, textarea { font:12px&#x2F;1.5tahoma, arial, \5b8b\4f53; } <br>        h1, h2, h3, h4, h5, h6{ font-size:100%; } <br>        address, cite, dfn, em, var { font-style:normal; } <br>        code, kbd, pre, samp { font-family:couriernew, courier, monospace; } <br>        small{ font-size:12px; } <br>        ul, ol { list-style:none; } <br>        a { text-decoration:none; } <br>        a:hover { text-decoration:underline; } <br>        sup { vertical-align:text-top; } <br>        sub{ vertical-align:text-bottom; } <br>        legend { color:#000; } <br>        fieldset, img { border:0; } <br>        button, input, select, textarea { font-size:100%; } table { border-collapse:collapse; border-spacing:0; } </p><h2 id="display-inline-block-什么时候会显示间隙？"><a href="#display-inline-block-什么时候会显示间隙？" class="headerlink" title="display:inline-block 什么时候会显示间隙？"></a>display:inline-block 什么时候会显示间隙？</h2><p>移除空格，使用margin 负值、使用 font-size:0、letter-spacing 、word-spacing</p><h2 id="使用-CSS-预处理器吗？喜欢哪个？"><a href="#使用-CSS-预处理器吗？喜欢哪个？" class="headerlink" title="使用 CSS 预处理器吗？喜欢哪个？"></a>使用 CSS 预处理器吗？喜欢哪个？</h2><p>SASS</p><h2 id="什么是盒子模型？"><a href="#什么是盒子模型？" class="headerlink" title="什么是盒子模型？"></a>什么是盒子模型？</h2><p>在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。</p><h2 id="CSS实现垂直水平居中"><a href="#CSS实现垂直水平居中" class="headerlink" title="CSS实现垂直水平居中"></a>CSS实现垂直水平居中</h2><p>一道经典的问题，实现方法有很多种，以下是其中一种实现：<br>HTML结构：<br><div class="wrapper"><br>    <div class="content"><code>&lt;/div&gt;</code></p></div><p>CSS：<br>.wrapper{position:relative;}<br>    .content{<br>        background-color:#6699FF;<br>        width:200px;<br>        height:200px;<br>        position: absolute;        &#x2F;&#x2F;父元素需要相对定位<br>        top: 50%;<br>        left: 50%;<br>        margin-top:-100px ;   &#x2F;&#x2F;二分之一的height，width<br>        margin-left: -100px;<br>    } </p><h2 id="简述一下src与href的区别"><a href="#简述一下src与href的区别" class="headerlink" title="简述一下src与href的区别"></a>简述一下src与href的区别</h2><p>href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。<br>src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</p><h2 id="简述同步和异步的区别"><a href="#简述同步和异步的区别" class="headerlink" title="简述同步和异步的区别"></a>简述同步和异步的区别</h2><p>同步是阻塞模式，异步是非阻塞模式。<br>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；<br>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</p><h2 id="px和em的区别"><a href="#px和em的区别" class="headerlink" title="px和em的区别"></a>px和em的区别</h2><p>px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。<br>浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em&#x3D;16px。那么12px&#x3D;0.75em, 10px&#x3D;0.625em</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CSS&lt;/h1&gt;&lt;h2 id=&quot;如何实现一个上中下三行布局，顶部和底部最小高度是-100px，中间自适应&quot;&gt;&lt;a href=&quot;#如何实现一个上中下三行布局</summary>
      
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="CSS" scheme="https://superq314.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>语法——JS</title>
    <link href="https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-JS/"/>
    <id>https://superq314.github.io/2022/06/27/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-JS/</id>
    <published>2022-06-27T13:28:26.092Z</published>
    <updated>2022-06-27T16:42:58.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="说说js中的词法作用域"><a href="#说说js中的词法作用域" class="headerlink" title="说说js中的词法作用域"></a>说说js中的词法作用域</h2><p>js中只有词法作用域，也就是说在定义时而不是执行时确定作用域。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"> </span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bar();&lt;br&gt;//1</span><br></pre></td></tr></table></figure><p>注意： with和eval可以修改词法作用域</p><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>《深入浅出nodejs》中对闭包的定义：</p><blockquote><p>在js中，实现外部作用域访问内部作用域中变量的方法叫做“闭包”。</p></blockquote><h2 id="说说js的垃圾回收-GC"><a href="#说说js的垃圾回收-GC" class="headerlink" title="说说js的垃圾回收(GC)"></a>说说js的垃圾回收(GC)</h2><p>v8的垃圾回收策略主要基于分代式垃圾回收机制。将内存分为新生代和老生代，分别采用不同的算法。</p><h3 id="新生代采用Scavenge算法"><a href="#新生代采用Scavenge算法" class="headerlink" title="新生代采用Scavenge算法"></a>新生代采用Scavenge算法</h3><p>Scavenge为新生代采用的算法，是一种采用复制的方式实现的垃圾回收算法。它将内存分为from和to两个空间。每次gc,会将from空间的存活对象复制到to空间。然后两个空间角色对换(又称反转)。</p><p>该算法是牺牲空间换时间，所以适合新生代，因为它的对象生存周期较短。</p><h3 id="老生代采用Mark-Sweep-和-Mark-Compact"><a href="#老生代采用Mark-Sweep-和-Mark-Compact" class="headerlink" title="老生代采用Mark-Sweep 和 Mark-Compact"></a>老生代采用Mark-Sweep 和 Mark-Compact</h3><p>老生代中对象存活时间较长，不适合Scavenge算法。</p><p>Mark-Sweep是标记清除的意思。Scavenge是只复制存活对象，而Mark-Sweep是只清除死亡对象。该算法分为两个步骤：</p><ol><li>遍历堆中所有对象并标记活着的对象</li><li>清除没有标记的对象</li></ol><p>Mark-Sweep存在一个问题，清除死亡对象后会造成内存空间不连续，如果这时候再分配一个大对象，所有的空间碎片都无法完成此次分配，就会造成提前触发gc。这时候v8会使用Mark-Compact算法。</p><p>Mark-Copact是标记整理的意思。它会在标记完成之后将活着的对象往一端移动，移动完成后直接清理掉边界外的内存。因为存在整理过程，所以它的速度慢于Mark-Sweep，node中主要采用Mark-Sweep。</p><h3 id="Incremental-Marking"><a href="#Incremental-Marking" class="headerlink" title="Incremental Marking"></a>Incremental Marking</h3><p>为了避免出现Javascript应用逻辑与垃圾回收器看到的情况不一致，垃圾回收时应用逻辑会停下来。这种行为被成为全停顿(stop-the-world)。这对老生代影响较大。</p><p>Incremental Marking称为增量标记，也就是拆分为许多小的“步进”，每次做完一“步进”，就让Javascript执行一会儿，垃圾回收与应用逻辑交替执行。</p><p>采用Incremental Marking后，gc的最大停顿时间较少到原来的 1 &#x2F; 6 左右。</p><h2 id="说说你了解的设计模式"><a href="#说说你了解的设计模式" class="headerlink" title="说说你了解的设计模式"></a>说说你了解的设计模式</h2><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>在js中事件模型就相当于传统的发布订阅模式，具体实现参考<a href="#3-2" title="#3-2">实现一个node中的EventEmiter</a></p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义： 定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。</p><h5 id="策略模式实现表单校验"><a href="#策略模式实现表单校验" class="headerlink" title="策略模式实现表单校验"></a>策略模式实现表单校验</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const strategies = &#123;</span><br><span class="line">    isNoEmpty: function(value, errorMsg)&#123;</span><br><span class="line">        if(value.trim() === &#x27;&#x27;)&#123;</span><br><span class="line">            return errorMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    maxLength: function(value, errorMsg, len) &#123;</span><br><span class="line">        if(value.trim() &gt; len) &#123;</span><br><span class="line">            return errorMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Validator &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.catch = [];</span><br><span class="line">  &#125;</span><br><span class="line">  add(value, rule, errorMsg, ...others) &#123;</span><br><span class="line">    this.catch.push(function() &#123;</span><br><span class="line">      return strategies[rule].apply(this, [value, errorMsg, ...others]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  start() &#123;</span><br><span class="line">    for (let i = 0, validatorFunc; (validatorFunc = this.catch[i++]); ) &#123;</span><br><span class="line">      let msg = validatorFunc();</span><br><span class="line">      if (msg) &#123;</span><br><span class="line">        return msg;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">const validatorFunc = function() &#123;</span><br><span class="line">    const validator = new Validator();</span><br><span class="line">    validator.add(username, &#x27;isNoEmpty&#x27;, &#x27;用户名不能为空&#x27;);</span><br><span class="line">    validator.add(password, &#x27;isNoEmpty&#x27;, &#x27;密码不能为空&#x27;);</span><br><span class="line">    const USERNAME_LEN = PASSWORD_LEN = 10;</span><br><span class="line">    validator.add(username, &#x27;maxLength&#x27;, `用户名不能超过$&#123;USERNAME_LEN&#125;个字`, USERNAME_LEN);</span><br><span class="line">    validator.add(password, &#x27;isNoEmpty&#x27;, `密码不能为空$&#123;PASSWORD_LEN&#125;个字`, PASSWORD_LEN);</span><br><span class="line">    let msg = validator.start();</span><br><span class="line">    if(msg) &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>应用场景： 有时候我们要向某些对象发送请求，但不知道请求的接收者是谁，也不知道请求的操作是什么，此时希望以一种松耦合的方式来设计软件，使得请求的发送者和接收者能够消除彼此的耦合关系。</p><h5 id="命令模式实现动画"><a href="#命令模式实现动画" class="headerlink" title="命令模式实现动画"></a>命令模式实现动画</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MoveCommand &#123;</span><br><span class="line">  constructor(reciever, pos) &#123;</span><br><span class="line">    this.reciever = reciever;</span><br><span class="line">    this.pos = pos;</span><br><span class="line">    this.oldPos = null;</span><br><span class="line">  &#125;</span><br><span class="line">  excute() &#123;</span><br><span class="line">    this.reciever.start(&quot;left&quot;, this.pos, 1000);</span><br><span class="line">    this.reciever.getPos();</span><br><span class="line">  &#125;</span><br><span class="line">  undo() &#123;</span><br><span class="line">    this.reciever.start(&quot;left&quot;, this.oldPos, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单对比一下-Callback、Promise、Generator、Async-几个异步-API-的优劣？"><a href="#简单对比一下-Callback、Promise、Generator、Async-几个异步-API-的优劣？" class="headerlink" title="简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？"></a>简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？</h2><p>在 JavaScript 中利用<a href="https://juejin.cn/post/6844903843197616136#heading-3" title="https://juejin.cn/post/6844903843197616136#heading-3">事件循环机制</a>（Event Loop）可以在单线程中实现非阻塞式、异步的操作。例如</p><ul><li>Node.js 中的 Callback、<a href="https://link.juejin.cn/?target=http://nodejs.cn/api/events.html%23events_class_eventemitter" title="http://nodejs.cn/api/events.html#events_class_eventemitter">EventEmitter</a>、<a href="https://link.juejin.cn/?target=http://nodejs.cn/api/stream.html" title="http://nodejs.cn/api/stream.html">Stream</a></li><li>ES6 中的 <a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/promise" title="https://es6.ruanyifeng.com/#docs/promise">Promise</a>、<a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/generator-async" title="https://es6.ruanyifeng.com/#docs/generator-async">Generator</a></li><li>ES2017 中的 <a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/async" title="https://es6.ruanyifeng.com/#docs/async">Async</a></li><li>三方库 RxJS、<a href="https://link.juejin.cn/?target=https://github.com/kriskowal/q" title="https://github.com/kriskowal/q">Q</a> 、<a href="https://link.juejin.cn/?target=https://github.com/tj/co" title="https://github.com/tj/co">Co、</a><a href="https://link.juejin.cn/?target=https://github.com/petkaantonov/bluebird" title="https://github.com/petkaantonov/bluebird">Bluebird</a></li></ul><p>我们重点来看一下常用的几种编程方式（Callback、Promise、Generator、Async）在语法糖上带来的优劣对比。</p><h3 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a><strong>Callback</strong></h3><p>Callback（回调函数）是在 Web 前端开发中经常会使用的编程方式。这里举一个常用的定时器示例：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">IObj</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">deferExec</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">deferExecAnonymous</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">console</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">IObj</span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deferExecBind</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用箭头函数可达到一样的效果</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">console</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deferExec</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">console</span>, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">console</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">deferExecBind</span>(); <span class="comment">// hello</span></span><br><span class="line">obj.<span class="title function_">deferExec</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>回调函数经常会因为调用环境的变化而导致 <code>this</code> 的指向性变化。除此之外，使用回调函数来处理多个继发的异步任务时容易导致回调地狱（Callback Hell）:</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(fileA, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileB, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileC, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">      fs.<span class="title function_">readFile</span>(fileD, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">        <span class="comment">// 假设在业务中 fileD 的读写依次依赖 fileA、fileB 和 fileC</span></span><br><span class="line">        <span class="comment">// 或者经常也可以在业务中看到多个 HTTP 请求的操作有前后依赖（继发 HTTP 请求）</span></span><br><span class="line">        <span class="comment">// 这些异步任务之间纵向嵌套强耦合，无法进行横向复用</span></span><br><span class="line">        <span class="comment">// 如果某个异步发生变化，那它的所有上层或下层回调可能都需要跟着变化（比如 fileA 和 fileB 的依赖关系倒置）</span></span><br><span class="line">        <span class="comment">// 因此称这种现象为 回调地狱</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>回调函数不能通过 <code>return</code> 返回数据，比如我们希望调用带有回调参数的函数并返回异步执行的结果时，只能通过再次回调的方式进行参数传递：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希望延迟 3s 后执行并拿到结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAsyncResult</span>(<span class="params">result: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">3</span>;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管这是常规的编程思维方式</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">getAsyncResult</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 但是打印 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAsyncResultWithCb</span>(<span class="params">result: <span class="built_in">number</span>, cb: (result: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">cb</span>(result * <span class="number">3</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过回调的形式获取结果</span></span><br><span class="line"><span class="title function_">getAsyncResultWithCb</span>(<span class="number">3000</span>, <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result); <span class="comment">// 9000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于 JavaScript 中标准的异步 API 可能无法通过在外部进行 <code>try...catch...</code> 的方式进行错误捕获：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 下述是异常代码</span></span><br><span class="line">    <span class="comment">// 你可以在回调函数的内部进行 try...catch...</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">b</span>.<span class="property">c</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="comment">// 这里不会执行</span></span><br><span class="line">  <span class="comment">// 进程会被终止</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例讲述的都是 JavaScript 中标准的异步 API ，如果使用一些三方的异步 API 并且提供了回调能力时，这些 API 可能是非受信的，在真正使用的时候会因为 <strong>执行反转</strong> （回调函数的执行权在三方库中）导致以下一些问题：</p><ul><li>使用者的回调函数设计没有进行错误捕获，而恰恰三方库进行了错误捕获却没有抛出错误处理信息，此时使用者很难感知到自己设计的回调函数是否有错误</li><li>使用者难以感知到三方库的回调时机和回调次数，这个回调函数执行的权利控制在三方库手中</li><li>使用者无法更改三方库提供的回调参数，回调参数可能无法满足使用者的诉求</li><li>…</li></ul><p>举个简单的例子：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILib</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">params</span>: T;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="attr">params</span>: T): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">on</span>(<span class="attr">callback</span>: <span class="function">(<span class="params">params: T</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下是一个三方库，并发布成了npm 包</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">lib</span>: <span class="title class_">ILib</span>&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">params</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">params</span> = params;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// callback 回调执行权在 lib 上</span></span><br><span class="line">      <span class="comment">// lib 库可以决定回调执行多次</span></span><br><span class="line">      <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      <span class="comment">// lib 库甚至可以决定回调延迟执行</span></span><br><span class="line">      <span class="comment">// 异步执行回调函数</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 假设 lib 库的捕获没有抛出任何异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发者引入 lib 库开始使用</span></span><br><span class="line">lib.<span class="title function_">emit</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">lib.<span class="title function_">on</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用者希望 on 里的回调只执行一次</span></span><br><span class="line"><span class="comment">// 这里的回调函数的执行时机是由三方库 lib 决定</span></span><br><span class="line">  <span class="comment">// 实际上打印四次，并且其中一次是异步执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">lib.<span class="title function_">on</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 下述是异常代码</span></span><br><span class="line">  <span class="comment">// 但是执行下述代码不会抛出任何异常信息</span></span><br><span class="line">  <span class="comment">// 开发者无法感知自己的代码设计错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">a</span>.<span class="property">b</span>.<span class="property">c</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><strong>Promise</strong></h3><p>Callback 的异步操作形式除了会造成回调地狱，还会造成难以测试的问题。ES6 中的 Promise （基于<a href="https://link.juejin.cn/?target=https://promisesaplus.com/" title="https://promisesaplus.com/"> Promise A +</a> 规范的异步编程解决方案）利用<a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html" title="http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html">有限状态机</a>的原理来解决异步的处理问题，Promise 对象提供了统一的异步编程 API，它的特点如下：</p><ul><li>Promise 对象的执行状态不受外界影响。Promise 对象的异步操作有三种状态： <code>pending</code>（进行中）、 <code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败） ，只有 Promise 对象本身的异步操作结果可以决定当前的执行状态，任何其他的操作无法改变状态的结果</li><li>Promise 对象的执行状态不可变。Promise 的状态只有两种变化可能：从 <code>pending</code>（进行中）变为 <code>fulfilled</code>（已成功）或从 <code>pending</code>（进行中）变为 <code>rejected</code>（已失败）</li></ul><blockquote><p>温馨提示：有限状态机提供了一种优雅的解决方式，异步的处理本身可以通过异步状态的变化来触发相应的操作，这会比回调函数在逻辑上的处理更加合理，也可以降低代码的复杂度。</p></blockquote><p>Promise 对象的执行状态不可变示例如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 状态变更为 fulfilled 并返回结果 1 后不会再变更状态</span></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 不会变更状态</span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在 ES 6 中 Promise 的 then 回调执行是异步执行（微任务）</span></span><br><span class="line">    <span class="comment">// 在当前 then 被调用的那轮事件循环（Event Loop）的末尾执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;error: &#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>假设要实现两个继发的 HTTP 请求，第一个请求接口返回的数据是第二个请求接口的参数，使用回调函数的实现方式如下所示（这里使用 <code>setTimeout</code> 来指代异步请求）：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调地狱</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doubble</span> = (<span class="params">result: <span class="built_in">number</span>, callback: (finallResult: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// Mock 第一个异步请求</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 第二个异步请求（假设第二个请求的参数依赖第一个请求的返回结果）</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">callback</span>(result * <span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doubble</span>(<span class="number">1000</span>, <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：继发请求的依赖关系非常常见，例如人员基本信息管理系统的开发中，经常需要先展示组织树结构，并默认加载第一个组织下的人员列表信息。</p></blockquote><p>如果采用 Promise 的处理方式则可以规避上述常见的回调地狱问题：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="comment">// 将 resolve 改成 reject 会被 catch 捕获</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="comment">// 将 resolve 改成 reject 会被 catch 捕获</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">firstPromise</span>(<span class="number">1000</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">nextPromise</span>(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2s 后打印 2000</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 任何一个 Promise 到达 rejected 状态都能被 catch 捕获</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>Promise 的错误回调可以同时捕获 <code>firstPromise</code> 和 <code>nextPromise</code> 两个函数的 <code>rejected</code> 状态。接下来考虑以下调用场景：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">firstPromise</span>(<span class="number">1000</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">nextPromise</span>(result).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 后打印</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextPromise result: &#x27;</span>, result);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 先打印</span></span><br><span class="line">    <span class="comment">// 由于上一个 then 没有返回值，这里打印 undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstPromise result: &#x27;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>首先 Promise 可以注册多个 <code>then</code>（放在一个执行队列里），并且这些 <code>then</code> 会根据上一次返回值的结果依次执行。除此之外，各个 Promise 的 <code>then</code> 执行互不干扰。 我们将示例进行简单的变换：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Mock 异步请求</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">firstPromise</span>(<span class="number">1000</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 返回了 nextPromise 的 then 执行后的结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">nextPromise</span>(result).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 接着 nextPromise 的 then 执行的返回结果继续执行</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 2s 后打印 2000</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextPromise result: &#x27;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述例子中的执行结果是因为 <code>then</code> 的执行会返回一个新的 Promise 对象，并且如果 <code>then</code> 执行后返回的仍然是 Promise 对象，那么下一个 <code>then</code> 的链式调用会等待该 Promise 对象的状态发生变化后才会调用（能得到这个 Promise 处理的结果）。接下来重点看下 Promise 的错误处理：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 下述是异常代码</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">b</span>.<span class="property">c</span>);</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 去掉 catch 仍然会抛出错误，但不会退出进程终止脚本执行</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 继续执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>从上述示例可以看出 Promise 的错误不会影响其他代码的执行，只会影响 Promise 内部的代码本身，因为Promise 会在内部对错误进行异常捕获，从而保证整体代码执行的稳定性。Promise 还提供了其他的一些 API 方便多任务的执行，包括</p><ul><li><code>Promise.all</code>：适合多个异步任务并发执行但不允许其中任何一个任务失败</li><li><code>Promise.race</code> ：适合多个异步任务抢占式执行</li><li><code>Promise.allSettled</code> ：适合多个异步任务并发执行但允许某些任务失败</li></ul><p>Promise 相对于 Callback 对于异步的处理更加优雅，并且能力也更加强大， 但是也存在一些自身的缺点：</p><ul><li>无法取消 Promise 的执行</li><li>无法在 Promise 外部通过 <code>try...catch...</code> 的形式进行错误捕获（Promise 内部捕获了错误）</li><li>状态单一，每次决断只能产生一种状态结果，需要不停的进行链式调用</li></ul><blockquote><p>温馨提示：手写 Promise 是面试官非常喜欢的一道笔试题，本质是希望面试者能够通过底层的设计正确了解 Promise 的使用方式，如果你对 Promise 的设计原理不熟悉，可以深入了解一下或者手动设计一个。</p></blockquote><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a><strong>Generator</strong></h3><p>Promise 解决了 Callback 的回调地狱问题，但也造成了代码冗余，如果一些异步任务不支持 Promise 语法，就需要进行一层 Promise 封装。Generator 将 JavaScript 的异步编程带入了一个全新的阶段，它使得异步代码的设计和执行看起来和同步代码一致。Generator 使用的简单示例如下：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Generator 函数里执行的异步代码看起来和同步代码一致</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 异步代码</span></span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(result)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 异步代码</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult) <span class="comment">// 6</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行 Generator 函数</span></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">res: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 将 firstPromise 的返回值传递给第一个 yield 表单式对应的 firstResult</span></span><br><span class="line">  <span class="keyword">return</span> g.<span class="title function_">next</span>(res).<span class="property">value</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 将 nextPromise 的返回值传递给第二个 yield 表单式对应的 nextResult</span></span><br><span class="line">  <span class="keyword">return</span> g.<span class="title function_">next</span>(res).<span class="property">value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过上述代码，可以看出 Generator 相对于 Promise 具有以下优势：</p><ul><li>丰富了状态类型，Generator 通过 <code>next</code> 可以产生不同的状态信息，也可以通过 <code>return</code> 结束函数的执行状态，相对于 Promise 的 <code>resolve</code> 不可变状态更加丰富</li><li>Generator 函数内部的异步代码执行看起来和同步代码执行一致，非常利于代码的维护</li><li>Generator 函数内部的执行逻辑和相应的状态变化逻辑解耦，降低了代码的复杂度</li></ul><p><code>next</code> 可以不停的改变状态使得 <code>yield</code> 得以继续执行的代码可以变得非常有规律，例如从上述的<strong>手动执行 Generator 函数</strong>可以看出，完全可以将其封装成一个自动执行的执行器，具体如下所示：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gen</span> =  <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="built_in">number</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(): <span class="title class_">Gen</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult) <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult) <span class="comment">// 6</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator 自动执行器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen: () =&gt; Gen</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">gen</span>()</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = g.<span class="title function_">next</span>(data)</span><br><span class="line">    <span class="keyword">if</span>(result.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 通过递归的方式处理相同的逻辑</span></span><br><span class="line">      <span class="title function_">next</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一次调用 next 主要用于启动 Generator 函数</span></span><br><span class="line">  <span class="comment">// 内部指针会从函数头部开始执行，直到遇到第一个 yield 表达式</span></span><br><span class="line">  <span class="comment">// 因此第一次 next 传递的参数没有任何含义（这里传递只是为了防止 TS 报错）</span></span><br><span class="line">  <span class="title function_">next</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>(gen)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：<a href="https://link.juejin.cn/?target=https://github.com/tj" title="https://github.com/tj">TJ Holowaychuk </a>设计了一个 Generator 自动执行器 <a href="https://link.juejin.cn/?target=https://github.com/tj/co" title="https://github.com/tj/co">Co</a>，使用 Co 的前提是 <code>yield</code>  命令后必须是 Promise 对象或者 Thunk 函数。Co 还可以支持并发的异步处理，具体可查看官方的<a href="https://link.juejin.cn/?target=https://github.com/tj/co%23arrays" title="https://github.com/tj/co#arrays"> API 文档</a>。</p></blockquote><p>需要注意的是 Generator 函数的返回值是一个 Iterator 遍历器对象，具体如下所示：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gen</span> = <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(): <span class="title class_">Gen</span> &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意使用 next 是继发执行，而这里是并发执行</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([...<span class="title function_">gen</span>()]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> <span class="title function_">gen</span>()) &#123;</span><br><span class="line">  promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Generator 函数的错误处理相对复杂一些，极端情况下需要对执行和 Generator 函数进行双重错误捕获，具体如下所示：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 需要注意这里的reject 没有被捕获</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gen</span> = <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(): <span class="title class_">Gen</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Generator 函数错误捕获: &#x27;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">gen</span>();</span><br><span class="line">  g.<span class="title function_">next</span>();</span><br><span class="line">  <span class="comment">// 返回 Promise 后还需要通过 Promise.prototype.catch 进行错误捕获</span></span><br><span class="line">  g.<span class="title function_">next</span>();</span><br><span class="line">  <span class="comment">// Generator 函数错误捕获</span></span><br><span class="line">  g.<span class="keyword">throw</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">  <span class="comment">// 执行器错误捕获</span></span><br><span class="line">  g.<span class="keyword">throw</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;执行错误捕获: &#x27;</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 <code>g.throw</code> 的时候还需要注意以下一些事项：</p><ul><li>如果 Generator 函数本身没有捕获错误，那么 Generator 函数内部抛出的错误可以在执行处进行错误捕获</li><li>如果 Generator 函数内部和执行处都没有进行错误捕获，则终止进程并抛出错误信息</li><li>如果没有执行过 <code>g.next</code>，则 <code>g.throw</code> 不会在 Gererator 函数中被捕获（因为执行指针没有启动 Generator 函数的执行），此时可以在执行处进行执行错误捕获</li></ul><h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a><strong>Async</strong></h3><p>Async 是 Generator 函数的语法糖，相对于 Generator 而言 Async 的特性如下：</p><ul><li>内置执行器：Generator 函数需要设计手动执行器或者通用执行器（例如 Co 执行器）进行执行，Async 语法则内置了自动执行器，设计代码时无须关心执行步骤</li><li><code>yield</code> 命令无约束：在 Generator 中使用 Co 执行器时 <code>yield</code> 后必须是 Promise 对象或者 Thunk 函数，而 Async 语法中的 <code>await</code> 后可以是 Promise 对象或者原始数据类型对象、数字、字符串、布尔值等（此时会对其进行 <code>Promise.resolve()</code> 包装处理）</li><li>返回 Promise： <code>async</code> 函数的返回值是 Promise 对象（返回原始数据类型会被 Promise 进行封装）， 因此还可以作为 <code>await</code>  的命令参数，相对于 Generator 返回 Iterator 遍历器更加简洁实用</li></ul><p>举个简单的示例：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">await</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 1s 后打印 2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult); </span><br><span class="line">  <span class="comment">// 等待 firstPromise 的状态发生变化后执行</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> <span class="title function_">nextPromise</span>(firstResult);</span><br><span class="line">  <span class="comment">// 2s 后打印 6</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult); </span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// 6</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过上述示例可以看出，<code>async</code> 函数的特性如下：</p><ul><li>调用 <code>async</code> 函数后返回的是一个 Promise 对象，通过 <code>then</code> 回调可以拿到 async 函数内部 <code>return</code> 语句的返回值</li><li>调用 <code>async</code> 函数后返回的 Promise 对象必须等待内部所有 <code>await</code> 对应的 Promise 执行完（这使得 <code>async</code> 函数可能是阻塞式执行）后才会发生状态变化，除非中途遇到了 <code>return</code> 语句</li><li><code>await</code> 命令后如果是 Promise 对象，则返回 Promise 对象处理后的结果，如果是原始数据类型，则直接返回原始数据类型</li></ul><p>上述代码是阻塞式执行，<code>nextPromise</code> 需要等待 <code>firstPromise</code> 执行完成后才能继续执行，如果希望两者能够并发执行，则可以进行下述设计：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">firstPromise</span>(<span class="number">1</span>), <span class="title function_">nextPromise</span>(<span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// [2,3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了使用 Promise 自带的并发执行 API，也可以通过让所有的 Promise 提前并发执行来处理：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstPromise&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">10000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextPromise&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 执行 firstPromise</span></span><br><span class="line">  <span class="keyword">const</span> first = <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 和 firstPromise 同时执行 nextPromise</span></span><br><span class="line">  <span class="keyword">const</span> next = <span class="title function_">nextPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 等待 firstPromise 结果回来</span></span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">await</span> first;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult);</span><br><span class="line">  <span class="comment">// 等待 nextPromise 结果回来</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> next;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult);</span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// 3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Async 的错误处理相对于 Generator 会更加简单，具体示例如下所示：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Promise 决断错误</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">await</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult);</span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> <span class="title function_">nextPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult);</span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err); <span class="comment">// err: 2</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>async</code> 函数内部抛出的错误，会导致函数返回的 Promise 对象变为 <code>rejected</code> 状态，从而可以通过 <code>catch</code> 捕获， 上述代码只是一个粗粒度的容错处理，如果希望 <code>firstPromise</code> 错误后可以继续执行 <code>nextPromise</code>，则可以通过 <code>try...catch...</code> 在 <code>async</code> 函数里进行局部错误捕获：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Promise 决断错误</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err); <span class="comment">// err: 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// nextPromise 继续执行</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> <span class="title function_">nextPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// res: 3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：Callback 是 Node.js 中经常使用的编程方式，Node.js 中很多原生的 API 都是采用 Callback 的形式进行异步设计，早期的 Node.js 经常会有 Callback 和 Promise 混用的情况，并且在很长一段时间里都没有很好的支持 Async 语法。如果你对 Node.js 和它的替代品 Deno 感兴趣，可以观看 Ryan Dahl 在 TS Conf 2019 中的经典演讲 <a href="https://link.juejin.cn/?target=https://www.youtube.com/watch?v=1gIiZfSbEAE" title="https://www.youtube.com/watch?v=1gIiZfSbEAE">Deno is a New Way to JavaScript</a>。</p></blockquote><p>作者：子弈<br>链接：<a href="https://juejin.cn/post/6987549240436195364">https://juejin.cn/post/6987549240436195364</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS&quot;&gt;&lt;a href=&quot;#JS&quot; class=&quot;headerlink&quot; title=&quot;JS&quot;&gt;&lt;/a&gt;JS&lt;/h1&gt;&lt;h2 id=&quot;说说js中的词法作用域&quot;&gt;&lt;a href=&quot;#说说js中的词法作用域&quot; class=&quot;headerlink&quot; title=&quot;说说j</summary>
      
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="JS" scheme="https://superq314.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>语法-Html面试题</title>
    <link href="https://superq314.github.io/2022/06/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/Html%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://superq314.github.io/2022/06/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/Html%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-06-21T10:34:17.822Z</published>
    <updated>2022-06-27T17:09:45.204Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="导⼊样式时link和-import区别"><a href="#导⼊样式时link和-import区别" class="headerlink" title="导⼊样式时link和@import区别"></a>导⼊样式时link和@import区别</h2><p>区别1：link是HTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。<br>区别2：link引⽤CSS时，在页⾯载⼊时同时加载；@import需要页⾯⽹页完全载⼊以后加载。<br>区别3：link是HTML标签，⽆兼容问题；@import是在CSS2.1提出的，低版本的浏览器不⽀持。<br>区别4：link⽀持使⽤Javascript控制DOM去改变样式；⽽@import不⽀持</p><h2 id="标签语义化的理解："><a href="#标签语义化的理解：" class="headerlink" title="标签语义化的理解："></a>标签语义化的理解：</h2><p>①去掉或者丢失样式的时候能够让页⾯呈现出清晰的结构<br>②有利SEO：和搜索引擎建⽴良好沟通，有助于爬⾍抓取更多的有效信息：爬⾍依赖于标签来确定上下⽂和各个关键字权重；<br>③⽅便其他设备解析（如屏幕阅读器、盲⼈阅读器、移动设备）以意义的⽅式来渲染⽹页；<br>④便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p><h2 id="块级元素变成内联元素的方法"><a href="#块级元素变成内联元素的方法" class="headerlink" title="块级元素变成内联元素的方法"></a>块级元素变成内联元素的方法</h2><h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><p>CSS2 引入了一种新的简单选择器 - 通配选择器（universal selector），显示为一个星号（*）。该选择器可以与任何元素匹配，就像是一个通配符。</p><p>PS: 下面的规则可以使文档中的每个元素都为红色：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><h3 id="链接伪类（重点）"><a href="#链接伪类（重点）" class="headerlink" title="链接伪类（重点）"></a>链接伪类（重点）</h3><p>在支持 CSS 的浏览器中，链接的不同状态都可以不同的方式显示，这些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">a:link &#123;color: #FF0000&#125;        /* 未访问的链接 */</span><br><span class="line">a:visited &#123;color: #00FF00&#125;    /* 已访问的链接 */</span><br><span class="line">a:hover &#123;color: #FF00FF&#125;    /* 鼠标移动到链接上 */</span><br><span class="line">a:active &#123;color: #0000FF&#125;    /* 选定的链接 */</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;导⼊样式时link和-import区别&quot;&gt;&lt;a href=&quot;#导⼊样式时link和-import区别&quot; class=&quot;headerlink&quot; title=&quot;导⼊样式时link和@import区别&quot;&gt;&lt;/a&gt;导⼊样式时link和@import区别&lt;/h2&gt;</summary>
      
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="Html" scheme="https://superq314.github.io/tags/Html/"/>
    
  </entry>
  
  <entry>
    <title>语法——Html</title>
    <link href="https://superq314.github.io/2022/06/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-Html/"/>
    <id>https://superq314.github.io/2022/06/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-Html/</id>
    <published>2022-06-20T09:14:42.649Z</published>
    <updated>2022-06-27T16:48:39.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Html页面的基础结构"><a href="#Html页面的基础结构" class="headerlink" title="Html页面的基础结构"></a>Html页面的基础结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta&gt;</span><br><span class="line">    &lt;link&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">    &lt;h1&gt;我的第⼀个标题&lt;/h1&gt; </span><br><span class="line">    &lt;p&gt;我的第⼀个段落。&lt;/p&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><hr><ol><li><code>&lt;head&gt;</code>：网页头部，其内容不会出现在网页中，主要帮助浏览器或者搜索引擎来解析网页</li><li><code>&lt;meta&gt;</code>：设置网页的元数据<ol><li>name：数据的属性名</li><li>content：指定数据的内容</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、&lt;meta charset=&quot;UTF-8&quot;&gt;，解决中文乱码问题，charset是指定网页的字符集。</span><br><span class="line">2、keywords表示网站的关键字,当搜索&#x27;HTML5,前端,CSS3&#x27;这些关键词,就会出现我们编写的网页。例：</span><br><span class="line">    &lt;meta name=&quot;keywords&quot; content=&quot;HTML5,前端,CSS3&quot;&gt;</span><br><span class="line">3、description用于指定网站的描述,出现在搜索引擎的搜索结果中。例：</span><br><span class="line">    &lt;meta name=&quot;description&quot; content=&quot;这是一个不错的网站&quot;&gt;</span><br><span class="line">4、author表明作者信息。例：</span><br><span class="line">    &lt;meta name=&quot;author&quot; content=&quot;SuperQ&quot;&gt;</span><br><span class="line">5、http-equiv，意思是几秒后跳转到什么地址。例：</span><br><span class="line">    &lt;meta http-equiv=&quot;refresh&quot; content=&quot;秒数;url=跳转地址&quot;&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>&lt;link&gt;</code>：用于外链资源</li><li><code>&lt;title&gt;</code>：其内容显示在浏览器的标题栏，搜索引擎根据title中的内容来判断网页的主要内容</li><li><code>&lt;style type=&quot;text/css&quot;&gt;</code>：用于内部样式</li><li><code>&lt;script&gt;</code>：用于加载脚本文件（如JavaScript）</li><li><code>&lt;body&gt;</code>：网页主体，网页中所有可见的内容都写在body里</li></ol><h2 id="父元素高度塌陷"><a href="#父元素高度塌陷" class="headerlink" title="父元素高度塌陷"></a>父元素高度塌陷</h2><p>一个块级元素如果没有设置height，其height是由子元素撑开的。对子元素使用了浮动之后，子元素会脱离标准文档流，也就是说，父级元素中没有内容可以撑开其高度，这样父级元素的height就会被忽略，这就是所谓的高度塌陷。</p><h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><h3 id="方法1：给父级p定义高度"><a href="#方法1：给父级p定义高度" class="headerlink" title="方法1：给父级p定义高度"></a>方法1：给父级p定义高度</h3><p>原理：给父级定义固定高度（height），能解决父级无法获取高度得问题<br>优点：代码简洁<br>缺点：高度被固定死了，是适合内容固定不变的模块（不推荐使用）</p><h3 id="方法2：使用空元素，如-clear"><a href="#方法2：使用空元素，如-clear" class="headerlink" title="方法2：使用空元素，如(.clear)"></a>方法2：使用空元素，如(.clear)</h3><p>原理：添加一对空的p标签，利用css的clear:both属性清除浮动，让父级能够获取高度<br>优点：浏览器支持好<br>缺点：多出了很多空的p标签，如果页面中浮动模块多的话，就会出现很多的空置p了，这样感觉视乎不是太令人满意（不推荐使用）</p><h3 id="方法3：让父级p也一并浮起来"><a href="#方法3：让父级p也一并浮起来" class="headerlink" title="方法3：让父级p也一并浮起来"></a>方法3：让父级p也一并浮起来</h3><p>这样做可以初步解决当前的浮动问题。但是也让父级浮动起来了，又会产生新的浮动问题。 不推荐使用</p><h3 id="方法4：父级p定义display-table"><a href="#方法4：父级p定义display-table" class="headerlink" title="方法4：父级p定义display:table"></a>方法4：父级p定义display:table</h3><p>原理：将p属性强制变成表格<br>优点：不解<br>缺点：会产生新的未知问题（不推荐使用）</p><h3 id="方法5：父元素设置-overflow：hidden、auto"><a href="#方法5：父元素设置-overflow：hidden、auto" class="headerlink" title="方法5：父元素设置 overflow：hidden、auto"></a>方法5：父元素设置 overflow：hidden、auto</h3><p>原理：这个方法的关键在于触发了BFC。在IE6中还需要触发 hasLayout（zoom：1）<br>优点：代码简介，不存在结构和语义化问题<br>缺点：无法显示需要溢出的元素（亦不太推荐使用）</p><h3 id="方法6：父级p定义伪类-after-和-zoom"><a href="#方法6：父级p定义伪类-after-和-zoom" class="headerlink" title="方法6：父级p定义伪类:after 和 zoom"></a>方法6：父级p定义伪类:after 和 zoom</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">    content:’.’;</span><br><span class="line">    display:block;</span><br><span class="line">    height:0;</span><br><span class="line">    clear:both;</span><br><span class="line">    visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">    zoom:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题<br>优点：结构和语义化完全正确,代码量也适中，可重复利用率（建议定义公共类）<br>缺点：代码不是非常简洁（极力推荐使用）</p><h3 id="经益求精写法"><a href="#经益求精写法" class="headerlink" title="经益求精写法"></a>经益求精写法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix:after &#123;</span><br><span class="line">    content:”\200B”;</span><br><span class="line">    display:block;</span><br><span class="line">    height:0;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123; </span><br><span class="line">    *zoom:1; </span><br><span class="line">&#125; 照顾IE6，IE7就可以了</span><br></pre></td></tr></table></figure><h2 id="BFC相关知识"><a href="#BFC相关知识" class="headerlink" title="BFC相关知识"></a>BFC相关知识</h2><p>定义：BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有 Block-level box 参 与， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。</p><p>BFC布局规则<br>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p><p>BFC这个元素的垂直方向的边距会发生重叠，垂直方向的距离由margin决定，取最大值<br>BFC 的区域不会与浮动盒子重叠（清除浮动原理）。<br>计算 BFC 的高度时，浮动元素也参与计算。</p><h2 id="px，em，rem-的区别"><a href="#px，em，rem-的区别" class="headerlink" title="px，em，rem 的区别"></a>px，em，rem 的区别</h2><p>px 像素(Pixel)。绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一个虚拟长度单位，是计算 机系统的数字化图像长度单位，如果 px 要换算成物理长度，需要指定精度 DPI。<br>em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置， 则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。<br>rem 是 CSS3 新增的一个相对单位(root em，根 em)，使用 rem 为元素设定字体大小时，仍然是相对大小， 但相对的只是 HTML 根元素。</p><h2 id="选择器-伪类选择器-A标签的伪类选择器"><a href="#选择器-伪类选择器-A标签的伪类选择器" class="headerlink" title="选择器-伪类选择器 A标签的伪类选择器"></a>选择器-伪类选择器 A标签的伪类选择器</h2><p>1.1. <code>&lt;a&gt;&lt;/a&gt;</code>此标签还有一个提示属性，当鼠标移上去的时候有提示语句显示。</p><p>1.2. <code>&lt;a&gt;&lt;/a&gt;</code>此标签的伪类选择器有顺序，顺序具体如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    a:link &#123;</span><br><span class="line">         color:#000;</span><br><span class="line">    &#125;</span><br><span class="line">    a:visited &#123;</span><br><span class="line">         color:#000;</span><br><span class="line">    &#125;</span><br><span class="line">    a:hover &#123;</span><br><span class="line">         color:red;</span><br><span class="line">    &#125;</span><br><span class="line">    a:active &#123;</span><br><span class="line">         color:yellow;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>可以简洁记忆：l v h a 记住四个属性的首字母即可。</p><p>注意：如果不按顺序编写此伪类标签无效。</p><h2 id="字体属性设置"><a href="#字体属性设置" class="headerlink" title="字体属性设置"></a>字体属性设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    font-size: 2em;/*设置字体的大小*/</span><br><span class="line">    font-style: italic;/*设置字体的样式*/</span><br><span class="line">    font-weight: bold;/*设置字体是否加粗*/</span><br><span class="line">    font-variant: small-caps;/*设置字体变形 小型大写字体*/</span><br><span class="line">    font-family: serif times;/*设置字体系列*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h2><p>行内元素：a  b  span  img  input  select  strong<br>块级元素：div  ul  ol  li  dl  dt  dd  h1  h2  h3  h4  p  等<br>空元素：<code>&lt;br&gt;</code>  <code>&lt;hr&gt;</code>  <code>&lt;img&gt;</code>  <code>&lt;link&gt;</code> <code>&lt;meta&gt;</code></p><h2 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h2><p>1）link属于XHTML标签，而@import是css提供的；<br>2）页面被加载时，link会同时被加载，而@import引用的css会等到页面被加载完再加载；<br>3）@import只在IE5以上才能识别，而link是XHTML标签，无兼容问题；<br>4）link方式的样式的权重高于@import的权重。</p><h2 id="简述一下你对HTML语义化的理解？"><a href="#简述一下你对HTML语义化的理解？" class="headerlink" title="简述一下你对HTML语义化的理解？"></a>简述一下你对HTML语义化的理解？</h2><p>1）用正确的标签做正确的事情；<br>2）html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；<br>3）即使在没有样式css情况下也以一种文档格式显示，并且是容易阅读的；<br>4）搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO；<br>5）使于都源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Html页面的基础结构&quot;&gt;&lt;a href=&quot;#Html页面的基础结构&quot; class=&quot;headerlink&quot; title=&quot;Html页面的基础结构&quot;&gt;&lt;/a&gt;Html页面的基础结构&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="Html" scheme="https://superq314.github.io/tags/Html/"/>
    
  </entry>
  
  <entry>
    <title>语法——Html5</title>
    <link href="https://superq314.github.io/2022/06/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-Html5/"/>
    <id>https://superq314.github.io/2022/06/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-Html5/</id>
    <published>2022-06-20T09:07:11.437Z</published>
    <updated>2022-06-27T17:09:55.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Html5新特性"><a href="#Html5新特性" class="headerlink" title="Html5新特性"></a>Html5新特性</h2><ol><li>绘画canvas</li><li>用于媒介回放的video和audio元素</li><li>本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失</li><li>sessionStorage的数据在浏览器关闭后自动删除</li><li>新增语义化标签，如 <code>&lt;header&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;section&gt;、&lt;aside&gt;</code></li><li>表单控件，calendar,date,time,email,url等</li><li>新的技术webworker,websockt,Geolocation</li><li>移出的元素<ol><li>纯表现的元素：basefont,big,center,font等</li><li>产生负面影响的元素：frame frameset等</li></ol></li><li>ie8 7 6 支持通过document.createElemet 方法产生新的标签，可以利用这 一特性让这些浏览器支持html5新标签</li></ol><h2 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？</h2><p>新特性，新增元素：<br>1）内容元素：article、footer、header、nav、section<br>2）表单控件：calendar、date、time、email、url、search<br>3）控件元素：webworker，websockt，Geolocation<br>移除元素：<br>1）显现层元素：basefont，big，center，font，s，strike，tt，u<br>2）性能较差元素：frame，frameset，noframes<br>处理兼容问题有两种方式：<br>1）IE6&#x2F;IE7&#x2F;IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签。<br>2）使用是html5shim框架<br>另外，DOCTYPE声明的方式是区分HTML和HTML5标志的一个重要因素，此外，还可以根据新增的结构，功能元素来加以区分。</p><p>©著作权归作者所有：来自51CTO博客作者wx5f5619df3fb27的原创作品，请联系作者获取转载授权，否则将追究法律责任<br>史上最全HTML5面试题目汇总<br><a href="https://blog.51cto.com/u_14928332/287882">https://blog.51cto.com/u_14928332/287882</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Html5新特性&quot;&gt;&lt;a href=&quot;#Html5新特性&quot; class=&quot;headerlink&quot; title=&quot;Html5新特性&quot;&gt;&lt;/a&gt;Html5新特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;绘画canvas&lt;/li&gt;
&lt;li&gt;用于媒介回放的video和audio元素&lt;/</summary>
      
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="Html5" scheme="https://superq314.github.io/tags/Html5/"/>
    
  </entry>
  
  <entry>
    <title>语法-图标</title>
    <link href="https://superq314.github.io/2022/06/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-%E5%9B%BE%E6%A0%87%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://superq314.github.io/2022/06/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E8%AF%AD%E6%B3%95-%E5%9B%BE%E6%A0%87%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2022-06-19T16:15:31.139Z</published>
    <updated>2022-06-27T17:08:36.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Font-Awesome图标"><a href="#Font-Awesome图标" class="headerlink" title="Font Awesome图标"></a>Font Awesome图标</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>要使用Font Awesome图标，请在HTML页面的 部分中添加以下行：</p><p>1、国内推荐 CDN：</p><p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt;</code></p><p>2、海外推荐 CDN</p><p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;**https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css&quot;&gt;</code></p><p>3、直接下载到本地</p><p><a href="https://static.runoob.com/download/font-awesome-4.7.0.zip">Download</a></p><blockquote><p><strong>注意：</strong> 不太建议下载来安装，直接在 html 文档头部引用 CDN 文件即可。</p><p><strong>注意：</strong> 本教程使用的是 4.7.0 版本。</p></blockquote><h2 id="图标类型"><a href="#图标类型" class="headerlink" title="图标类型"></a>图标类型</h2><p><a href="https://www.runoob.com/font-awesome/fontawesome-reference.html">Font Awesome 参考手册</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-brand.html">品牌图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-chart.html">图表图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-currency.html">货币图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-directional.html">方向图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-filetype.html">文件类型图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-form.html">表单图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-gender.html">性别图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-hand.html">手势图标</a></p><p><a href="https://www.runoob.com/font-awesome/ffontawesome-icons-medical.html">医疗图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-payment.html">付款图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-spinner.html">加载中图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-text.html">文本图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-transportation.html">交通工具图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-video.html">音&#x2F;视频图标</a></p><p><a href="https://www.runoob.com/font-awesome/fontawesome-icons-webapp.html">Web应用图标</a></p><h1 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h1><p><a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2">参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Font-Awesome图标&quot;&gt;&lt;a href=&quot;#Font-Awesome图标&quot; class=&quot;headerlink&quot; title=&quot;Font Awesome图标&quot;&gt;&lt;/a&gt;Font Awesome图标&lt;/h1&gt;&lt;h2 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使</summary>
      
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="iconfont" scheme="https://superq314.github.io/tags/iconfont/"/>
    
    <category term="Font Awesome" scheme="https://superq314.github.io/tags/Font-Awesome/"/>
    
  </entry>
  
  <entry>
    <title>暂定</title>
    <link href="https://superq314.github.io/2022/06/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://superq314.github.io/2022/06/20/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2022-06-19T16:07:08.225Z</published>
    <updated>2022-06-27T17:08:29.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用link-rel-x3D-amp-34-shortcut-icon-amp-34-为网页标题加图标"><a href="#使用link-rel-x3D-amp-34-shortcut-icon-amp-34-为网页标题加图标" class="headerlink" title="使用link rel&#x3D;&amp;#34;shortcut icon&amp;#34;为网页标题加图标"></a>使用link rel&#x3D;&amp;#34;shortcut icon&amp;#34;为网页标题加图标</h2><p><code>&lt;title&gt;会员卡券&lt;/title&gt;</code></p><p><code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;http://GT/img/favicon.png&quot; type=&quot;image/x-icon&quot;&gt;</code></p><p>实现的效果就是这样：</p><p><img src="https://images2017.cnblogs.com/blog/1074458/201709/1074458-20170908132851319-522668898.png"><img src="/image/%E5%B0%8F%E6%8A%80%E5%B7%A7/1655654996558.png" alt="1655654996558"><img src="https://images2017.cnblogs.com/blog/1074458/201709/1074458-20170908140017319-1056040699.png"><img src="https://images2017.cnblogs.com/blog/1074458/201709/1074458-20170908132851319-522668898.png"></p><p>添加收藏夹也会有</p><p><img src="https://images2017.cnblogs.com/blog/1074458/201709/1074458-20170908140017319-1056040699.png"><img src="/image/%E5%B0%8F%E6%8A%80%E5%B7%A7/1655655008921.png" alt="1655655008921"></p><p>通过查询资料，网络上有两种写法：</p><p>语句一：<br><code>code</code></p><p>语句二：</p><p><code>&lt;link rel=&quot;icon&quot; href=&quot;图片地址&quot; type=&quot;image/gif&quot; /&gt;</code></p><p><img src="https://images2017.cnblogs.com/blog/1074458/201709/1074458-20170908135100226-1038231165.png">type可以设置多种图片类型。如：gif&#x2F;png&#x2F;ico</p><p>一般的图标尺寸都是16px*16px</p><p><img src="https://images2017.cnblogs.com/blog/1074458/201709/1074458-20170908135100226-1038231165.png"><img src="/image/%E5%B0%8F%E6%8A%80%E5%B7%A7/1655655155244.png" alt="1655655155244"><img src="https://images2017.cnblogs.com/blog/1074458/201709/1074458-20170908135100226-1038231165.png"></p><p>静态的图标文件使用：</p><p><code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;1.png&quot; type=&quot;image/x-icon&quot; /&gt;</code></p><p>动态图 gif（动画也是16*16）使用：</p><p><code>&lt;link rel=&quot;icon&quot; href=&quot;1.gif&quot; type=&quot;image/gif&quot; &gt;</code></p><p>关于shortcut icon和icon代码的区别介绍</p><p>有一个博客有写 <a href="http://blog.csdn.net/ssisse/article/details/51705626">http://blog.csdn.net/ssisse/article/details/51705626</a> 链接放在这里 方便以后看</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用link-rel-x3D-amp-34-shortcut-icon-amp-34-为网页标题加图标&quot;&gt;&lt;a href=&quot;#使用link-rel-x3D-amp-34-shortcut-icon-amp-34-为网页标题加图标&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="前端开发-语法" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="icon" scheme="https://superq314.github.io/tags/icon/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://superq314.github.io/2022/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>https://superq314.github.io/2022/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2022-06-19T09:45:21.777Z</published>
    <updated>2022-06-27T16:58:12.922Z</updated>
    
    
    
    
    <category term="计算机基础" scheme="https://superq314.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机组成原理" scheme="https://superq314.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://superq314.github.io/2022/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://superq314.github.io/2022/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-06-19T09:44:59.540Z</published>
    <updated>2022-06-27T16:59:08.173Z</updated>
    
    
    
    
    <category term="计算机基础" scheme="https://superq314.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据结构" scheme="https://superq314.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
