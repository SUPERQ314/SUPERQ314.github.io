<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>superQ的个人小站</title>
  <icon>https://www.gravatar.com/avatar/53ec4cae8bfa9696385d334042db5c18</icon>
  <subtitle>山海无畏</subtitle>
  <link href="https://superq314.github.io/atom.xml" rel="self"/>
  
  <link href="https://superq314.github.io/"/>
  <updated>2022-07-18T10:00:23.418Z</updated>
  <id>https://superq314.github.io/</id>
  
  <author>
    <name>superQ</name>
    <email>220202090@seu.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重绘重排</title>
    <link href="https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%92/"/>
    <id>https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%92/</id>
    <published>2022-07-18T09:59:39.122Z</published>
    <updated>2022-07-18T10:00:23.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重排重会的概念"><a href="#重排重会的概念" class="headerlink" title="重排重会的概念"></a>重排重会的概念</h2><h3 id="1-重绘（repaint）"><a href="#1-重绘（repaint）" class="headerlink" title="1.重绘（repaint）"></a>1.重绘（repaint）</h3><p>在不改变文档布局的情况下，文档元素发生的例如背景颜色等外观改变的行为可称为重绘。根据 Opera 的说法，重绘的成本也很高，但在处理能力较高的现代设备中，可能感觉不明显。</p><h3 id="2-重排（reflow）"><a href="#2-重排（reflow）" class="headerlink" title="2.重排（reflow）"></a>2.重排（reflow）</h3><p>reflow 有人翻译为“回流”，也有人翻译为“重构”，也有人翻译为“重排”。我选择翻译为重排，取重新排版布局之意。</p><p>那么什么是重排呢？</p><p>developers.google 上这样解释：</p><blockquote><p>重排是在网络浏览器中执行的一个流程，用于重新计算文档中各元素的位置和几何形状，以便重新呈现该文档的部分内容或全部内容。</p></blockquote><p>我对重排的理解：</p><p>会改变文档布局，会引发元素的位置、尺寸发生改变的行为可称为重排。重排比起重绘，在视觉效果上会更明显，每当操作 DOM 树、更改影响布局的样式、更改元素的 className 属性或更改浏览器窗口大小时，都会发生重排现象。</p><p>重排在性能方面的消耗是巨大的，并且是导致 DOM 脚本缓慢的主要原因之一，这在处理能力较低的设备上更为明显。在很多情况下，它们相当于重新布局整个页面，因为元素的重排可能会导致它的祖先元素和子孙元素也发生相应的改变。</p><p>现代的电脑设备处理能力普遍较强，所以一些开发者或产品设计者，没有重视应当减少重排的发生，但在一些处理能力不足的特殊终端设备这很重要。</p><h2 id="什么时候会发生重排重绘"><a href="#什么时候会发生重排重绘" class="headerlink" title="什么时候会发生重排重绘"></a>什么时候会发生重排重绘</h2><p>会引发重排的情况：</p><ul><li>浏览器窗口大小的改变，调整窗口大小</li><li>删除可见的节点或增加节点</li><li>节点尺寸的改变，例如修改元素的width或height等</li><li>节点位置的改变，例如使用float或position的改变</li><li>节点文本内容的改变，例如不断输入内容。</li><li>激活 CSS 伪类，例如 :hover（在 IE 中激活兄弟的伪类）</li><li>给元素删除或添加样式表，例如给元素添加一个新的样式，或移除原来的样式。</li></ul><p>会引发重绘的情况：</p><p>例如元素的 color，background-color 等的改变。</p><blockquote><p>tips：据说重排必定会发生重绘，但重绘未必会发生重排。</p></blockquote><p>此外，个人认为重排重绘的边界并不是没有交集的。所以可能可以把重排重绘绑在一起，认为是一件事，不必仔细区分，而我们更应该付出注意力的是在程序设计时，尽可能降低重排重绘带来的消耗，减少不必要的重排重绘发生。</p><h2 id="学完之后"><a href="#学完之后" class="headerlink" title="学完之后"></a>学完之后</h2><p>了解了重排重会之后，知道重排重绘可能会产生较大的性能消耗，总结下应该注意的事情。</p><p><strong>面对重排重绘的注意事项</strong></p><ul><li>减少不必要的 DOM 深度，例如不必要的嵌套结构。在 DOM 树中的一个级别进行更改可能会致使该树的所有级别（上至根节点，下至所修改节点的子级）都随之变化。这会导致花费更多的时间来执行重排。</li><li>尽可能减少 CSS 规则的数量，并删除未使用到的 CSS 规则。一些默认就有的 CSS 规则，就不必写了，具有继承性的样式，也不必每级节点都写。calc() 之类的计算方法应该少用。</li><li>如果您想进行复杂的渲染更改（例如动画），请在流程外执行此操作。您可以使用 position-absolute 或 position-fixed 来实现此目的。</li><li>避免使用不必要且复杂的 CSS 选择器（尤其是后代选择器），因为此类选择器需要耗用更多的 CPU 处理能力来执行选择器匹配。总之不必要的深度，不管是 css 还是 dom 都不是好的选择，这对人和机器都是同样的道理，因为读和理解起来都同样的“费力”。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重排重会的概念&quot;&gt;&lt;a href=&quot;#重排重会的概念&quot; class=&quot;headerlink&quot; title=&quot;重排重会的概念&quot;&gt;&lt;/a&gt;重排重会的概念&lt;/h2&gt;&lt;h3 id=&quot;1-重绘（repaint）&quot;&gt;&lt;a href=&quot;#1-重绘（repaint）&quot; class</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="重绘重排" scheme="https://superq314.github.io/tags/%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>预解析(提升)</title>
    <link href="https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E9%A2%84%E8%A7%A3%E6%9E%90(%E6%8F%90%E5%8D%87)/"/>
    <id>https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E9%A2%84%E8%A7%A3%E6%9E%90(%E6%8F%90%E5%8D%87)/</id>
    <published>2022-07-18T07:56:14.554Z</published>
    <updated>2022-07-19T09:23:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>JS解析器运行代码的过程分为两步：<strong>预解析 + 代码执行</strong></p><blockquote><p><strong>预解析</strong>：JS引擎会把JS里面所有的 var、function 提升到当前作用域的最前面<br><strong>代码执行</strong>：按照代码书写的顺序从上往下执行</p></blockquote><p>预解析分为：<strong>变量预解析（变量提升）</strong> 和 <strong>函数预解析（函数提升）</strong></p><h3 id="变量预解析（变量提升）"><a href="#变量预解析（变量提升）" class="headerlink" title="变量预解析（变量提升）"></a>变量预解析（变量提升）</h3><p><strong>把所有的变量声明提升到当前作用域的最前面，不提升赋值操作</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于执行了以下代码：</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">//  undefined  声明了未赋值，则是undefined</span></span><br><span class="line">num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式（匿名函数），var fun = funciton() &#123;&#125;， fun是变量名</span></span><br><span class="line"><span class="comment">// 函数表达式调用，必须写在函数表达式的下面才不会报错</span></span><br><span class="line"><span class="title function_">fun</span>(); <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">22</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于执行了以下代码：</span></span><br><span class="line"><span class="keyword">var</span> fun;</span><br><span class="line"><span class="title function_">fun</span>(); <span class="comment">// 报错  声明了一个fun的变量名，直接调用报错</span></span><br><span class="line">fun = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">22</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">22</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(); <span class="comment">// 函数表达式调用，必须写在函数表达式的下面才不会报错   正常输出：22</span></span><br></pre></td></tr></table></figure><h3 id="函数预解析（函数提升）"><a href="#函数预解析（函数提升）" class="headerlink" title="函数预解析（函数提升）"></a>函数预解析（函数提升）</h3><p><strong>把所有的函数声明提升到当前作用域的最前面，不调用函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fu</span>();  <span class="comment">// 正常输出 11</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于执行了以下代码： 先声明的函数，再调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fu</span>();  <span class="comment">// 正常输出 11</span></span><br></pre></td></tr></table></figure><h3 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h3><p>函数声明和变量声明都会被提升。但是一个值得注意的细节是，<strong>函数声明会首先被提升，然后才是变量。</strong></p><p>考虑如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里会输出 1 而不是 2 。这段代码其实等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em><strong>var foo;</strong></em> 尽管出现在 function foo() {…} 声明之前，但是它是重复声明，所以会被编译器忽略，因为函数声明会被提升到变量声明之前。</p><p>注意，尽管重复的 var 声明会被忽略，但重复的函数声明却会覆盖前一个同名函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();      <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();        <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">   cosole.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子充分说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。上面那个例子，等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">   cosole.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();      <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">foo = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();        <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>还有一些人会犯如下错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();      <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 if 并没有块作用域，所以这里的函数声明会提升到其作用域最前边，而后一个 function 声明会覆盖前一个，所以这里结果是 2 。这里代码等价如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();      <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a) &#123;&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JS解析器运行代码的过程分为两步：&lt;strong&gt;预解析 + 代码执行&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;预解析&lt;/strong&gt;：JS引擎会把JS里面所有的 var、function 提升到当前作用域的最前面&lt;br&gt;&lt;strong&gt;</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>变量</title>
    <link href="https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E5%8F%98%E9%87%8F/"/>
    <id>https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E5%8F%98%E9%87%8F/</id>
    <published>2022-07-18T07:55:14.038Z</published>
    <updated>2022-07-18T15:05:51.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="var、let、const的区别"><a href="#var、let、const的区别" class="headerlink" title="var、let、const的区别"></a>var、let、const的区别</h3><p>var 声明的变量会挂载在window上，而let和const声明的变量不会：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,<span class="variable language_">window</span>.<span class="property">a</span>);    <span class="comment">// 100 100</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b,<span class="variable language_">window</span>.<span class="property">b</span>);    <span class="comment">// 10 undefined</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c,<span class="variable language_">window</span>.<span class="property">c</span>);    <span class="comment">// 1 undefined</span></span><br></pre></td></tr></table></figure><p><code>var</code>声明变量存在变量提升，<code>let</code>和 <code>const</code>不存在变量提升:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined  ===&gt;  a已声明还没赋值，默认得到undefined值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 报错：b is not defined  ===&gt; 找不到b这个变量</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 报错：c is not defined  ===&gt; 找不到c这个变量</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>let和const声明形成块作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(1) &#123;</span><br><span class="line">   var a = 100;</span><br><span class="line">   let b = 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);  // 100</span><br><span class="line">console.log(b);  // 报错：b is not defined  ===&gt; 找不到b这个变量-------------------------------------------------------------</span><br><span class="line">if(1) &#123;</span><br><span class="line">   var a = 100;</span><br><span class="line">   const c = 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);  // 100</span><br><span class="line">console.log(c);  // 报错：c is not defined  ===&gt; 找不到c这个变量</span><br></pre></td></tr></table></figure><p>同一作用域下let和const不能声明同名变量，而var可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line">console.log(a); // 100</span><br><span class="line">var a = 10;</span><br><span class="line">console.log(a); // 10</span><br><span class="line">-------------------------------------</span><br><span class="line">let a = 100;</span><br><span class="line">let a = 10;  //  控制台报错：Identifier &#x27;a&#x27; has already been declared  ===&gt; 标识符a已经被声明了。</span><br></pre></td></tr></table></figure><p>暂存死区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 100;</span><br><span class="line">if(1) &#123;</span><br><span class="line">   a = 10;  </span><br><span class="line">   //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，  </span><br><span class="line">   // 而这时，还未到声明时候，所以控制台Error:a is not defined</span><br><span class="line">   let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   1、一旦声明必须赋值,不能使用null占位。　</span><br><span class="line">   2、声明后不能再修改　　</span><br><span class="line">   3、如果声明的是复合类型数据，可以修改其属性</span><br><span class="line">*/</span><br><span class="line">const a = 100;</span><br><span class="line"></span><br><span class="line">const list = [];</span><br><span class="line">list[0] = 10;</span><br><span class="line">console.log(list);　　// [10]</span><br><span class="line"></span><br><span class="line">const obj = &#123;a:100&#125;;</span><br><span class="line">obj.name = &#x27;apple&#x27;;</span><br><span class="line">obj.a = 10000;</span><br><span class="line">console.log(obj);　　// &#123;a:10000,name:&#x27;apple&#x27;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;var、let、const的区别&quot;&gt;&lt;a href=&quot;#var、let、const的区别&quot; class=&quot;headerlink&quot; title=&quot;var、let、const的区别&quot;&gt;&lt;/a&gt;var、let、const的区别&lt;/h3&gt;&lt;p&gt;var 声明的变量会挂载在w</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>作用域</title>
    <link href="https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2022-07-18T07:47:07.260Z</published>
    <updated>2022-07-18T15:10:09.755Z</updated>
    
    <content type="html"><![CDATA[<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>JS只有词法作用域，即在定义阶段而不是执行阶段确定作用域。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">bar</span>();<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>注意： with和eval可以修改词法作用域</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><a href="/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ECMAScript2015(ES6)%E6%96%B0%E7%89%B9%E6%80%A7/" title="ECMAScript 2015（ES6）新特性">ECMAScript 2015（ES6）新特性</a><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><ul><li>作用域<ul><li>定义变量的作用区域，自有一套访问变量的规则，从而方便管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找</li></ul></li><li>作用域链<ul><li>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数</li><li>函数内部可以访问外部数据，从而形成了作用域链，但是外部没办法访问函数内部的数据</li><li>以<strong>链式查找方式</strong>取值</li></ul></li></ul><blockquote><p>作用域链的本质：指向变量对象的指针列表。</p><p>变量对象：包含执行环境中所有变量和函数的对象</p><p>作用域链的前端始终都是当前执行上下文的变量对象。</p><p>全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</p></blockquote><p>详细资料可以参考：</p><p><a href="https://link.juejin.cn/?target=http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html" title="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html">《JavaScript 深入理解之作用域链》</a></p><p><a href="https://juejin.cn/post/6844904126216830984" title="https://juejin.cn/post/6844904126216830984">「前端料包」深究JavaScript作用域（链）知识点和闭包</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;词法作用域&quot;&gt;&lt;a href=&quot;#词法作用域&quot; class=&quot;headerlink&quot; title=&quot;词法作用域&quot;&gt;&lt;/a&gt;词法作用域&lt;/h3&gt;&lt;p&gt;JS只有词法作用域，即在定义阶段而不是执行阶段确定作用域。例如：&lt;/p&gt;
&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E5%87%BD%E6%95%B0/"/>
    <id>https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E5%87%BD%E6%95%B0/</id>
    <published>2022-07-18T07:47:04.977Z</published>
    <updated>2022-07-18T15:06:25.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名 (参数<span class="number">1</span>, 参数<span class="number">2</span>, ...) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>函数表达式用一个变量来保存函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="keyword">function</span> (<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>位于函数内部，是一个类数组，存储着函数调用时的实参。</p><blockquote><p>因为有一个length属性，可以使用数组索引表示法arguments[1]来访问单个值</p><p>但是没有数组中的内置方法，如：forEach、reduce、filter、map。</p></blockquote><p>可以使用 <code>Array.prototype.slice</code>将 <code>arguments对象</code>转换成一个数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function one() &#123;</span><br><span class="line">   return Array.prototype.slice.call(arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：箭头函数中没有 <code>arguments对象</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function one() &#123;</span><br><span class="line">   return arguments;</span><br><span class="line">&#125;</span><br><span class="line">const two = function () &#123;</span><br><span class="line">   return arguments;</span><br><span class="line">&#125;</span><br><span class="line">const three = function three() &#123;</span><br><span class="line">   return arguments;</span><br><span class="line">&#125;</span><br><span class="line">const four = () =&gt; arguments;</span><br><span class="line">four(); // Throws an error  - arguments is not defined</span><br></pre></td></tr></table></figure><p>当我们调用函数four时，它会抛出一个 <code>ReferenceError: arguments is not defined error</code>。使用rest语法，可以解决这个问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const four = (...args) =&gt; args;</span><br></pre></td></tr></table></figure><p>这会自动将所有参数值放入数组中。</p><h4 id="arguments的作用"><a href="#arguments的作用" class="headerlink" title="arguments的作用"></a>arguments的作用</h4><p>当需求改变：“<strong>无论传递多少参数过去，都得求出相加的和”</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>这时，<code>arguments</code>对象就派上用场了, 因为 <code>auguments</code>是个类数组，可以通过下标取值，我们遍历将所有实参相加，这样，无论传递多少参数，都可以实现求和。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">       sum = sum + <span class="variable language_">arguments</span>[i]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)) <span class="comment">//&gt;&gt; 28</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)) <span class="comment">//&gt;&gt; 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>()) <span class="comment">//&gt;&gt; 0</span></span><br></pre></td></tr></table></figure><blockquote><p>此外，arguments在实现<strong>call、bind、apply</strong>以及<strong>设计模式中</strong>还有着更加巧妙的作用，后面会单独讲解。</p></blockquote><h4 id="实参（arguments）与形参混用"><a href="#实参（arguments）与形参混用" class="headerlink" title="实参（arguments）与形参混用"></a>实参（arguments）与形参混用</h4><blockquote><p>参考JavaScript高级程序设计（第四版）第10章</p></blockquote><p>什么是与形参混用？看下面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + <span class="number">10</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数中，使用了2个形参和 <code>arguments</code>对象。形参 <code>num1</code>保存着和 <code>arguments[0]</code>一样的值，因此使用谁都一样。同样 <code>arguments[1]</code>也保存着与 <code>num2</code>一样的值。</p><p>此外，arguments另一个有意思的地方是，它的值始终与对应的形参保持同步。看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，把第二个实参的值重写为10。因为 <code>arguments</code>对象的值会自动同步到对应的命名参数。所以修改 <code>arguments[1]</code>的值也会修改 <code>num2</code>的值，因此二者都是10。但要注意， <strong>这不意味着它们共享同一个栈内存地址，它们在内存中还是分开的，只不过会保持同步而已</strong> 。</p><p>另外切记： <strong>如果只传递了一个参数，然后把arguments[1]设置为某个值，那么这个值并不会反映到第二个形参上。这是因为，我们前面说过，arguments的值是函数调用时传递的实参个数确定的，而非定义时给出的形参个数确定的</strong> ,如下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>)&#123;</span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2) <span class="comment">//num2不会被设置为10，因为num2在下面调用时没有传递</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">6</span>) <span class="comment">//&gt;&gt; NaN</span></span><br></pre></td></tr></table></figure><h3 id="函数柯里化的实现"><a href="#函数柯里化的实现" class="headerlink" title="函数柯里化的实现"></a>函数柯里化的实现</h3><p>&#x2F;&#x2F; 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn, args) &#123;</span><br><span class="line">  // 获取函数需要的参数长度</span><br><span class="line">  let length = fn.length;</span><br><span class="line">  args = args || [];</span><br><span class="line">  return function() &#123;</span><br><span class="line">    let subArgs = args.slice(0);</span><br><span class="line">    // 拼接得到现有的所有参数</span><br><span class="line">    for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">      subArgs.push(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断参数的长度是否已经满足函数所需参数的长度</span><br><span class="line">    if (subArgs.length &gt;= length) &#123;</span><br><span class="line">      // 如果满足，执行函数</span><br><span class="line">      return fn.apply(this, subArgs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 如果不满足，递归返回科里化的函数，等待参数的传入</span><br><span class="line">      return curry.call(this, fn, subArgs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// es6 实现</span><br><span class="line">function curry(fn, ...args) &#123;</span><br><span class="line">  return fn.length &lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/42" title="https://github.com/mqyqingfeng/Blog/issues/42">《**JavaScript **专题之函数柯里化》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;函数声明&quot;&gt;&lt;a href=&quot;#函数声明&quot; class=&quot;headerlink&quot; title=&quot;函数声明&quot;&gt;&lt;/a&gt;函数声明&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%95%B0%E7%BB%84/"/>
    <id>https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%95%B0%E7%BB%84/</id>
    <published>2022-07-18T07:46:55.085Z</published>
    <updated>2022-07-18T15:09:20.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h4><p>遍历数组，<strong>返回元素在数组中第一次出现的下标</strong></p><p>接收2个参数：</p><ul><li><strong>参数1：要查找的元素</strong></li><li><strong>参数2：开始查找的下标</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="comment">// 遍历数组，查找a元素，从下标为1的元素开始往后查找</span></span><br><span class="line">arr.<span class="title function_">indexOf</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>遍历数组，<strong>获取每一个元素，没有返回值</strong></p><p>参数为一个函数，函数的<strong>形参1</strong>代表 <strong>数组元素</strong> ，<strong>形参2</strong>代表<strong>元素的下标</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item, index</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item, index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>遍历数组，<strong>返回一个新数组，数组由参数里的返回值组成，必须使用return</strong></p><p>参数为一个函数，函数的<strong>形参1</strong>代表<strong>数组元素</strong> ，<strong>形参2</strong>代表<strong>元素的下标</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="comment">// 示例1 </span></span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> item == <span class="string">&#x27;a&#x27;</span> </span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// [true, false, false, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2</span></span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item, index</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> index</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>遍历数组，<strong>返回一个新数组：新数组由参数里面，条件为true的元素组成</strong></p><p>参数为一个函数，函数的<strong>形参1</strong>代表 <strong>数组元素</strong> ，<strong>形参2</strong>代表<strong>元素下标</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// [ &#x27;c&#x27; ,&#x27;a&#x27; ]</span></span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历对象（补充）"><a href="#遍历对象（补充）" class="headerlink" title="遍历对象（补充）"></a>遍历对象（补充）</h3><p><strong>for…in语句</strong>用于对<strong>数组</strong>或<strong>对象</strong>的属性进行循环操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;jay&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...in遍历对象</span></span><br><span class="line"><span class="keyword">for</span>(变量 <span class="keyword">in</span> 对象) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k); <span class="comment">// 变量K，输出的是所有的  属性名</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[k]); <span class="comment">// 输出对象中所有的  属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>for…in 里面的变量，一般写为 k 或 key</li></ul><p>作者：想养一只猫丫<br>链接：<a href="https://juejin.cn/post/7118259341060210701">https://juejin.cn/post/7118259341060210701</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;遍历数组&quot;&gt;&lt;a href=&quot;#遍历数组&quot; class=&quot;headerlink&quot; title=&quot;遍历数组&quot;&gt;&lt;/a&gt;遍历数组&lt;/h3&gt;&lt;h4 id=&quot;indexOf&quot;&gt;&lt;a href=&quot;#indexOf&quot; class=&quot;headerlink&quot; title=&quot;ind</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数据类型</title>
    <link href="https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-07-18T07:46:29.869Z</published>
    <updated>2022-07-18T15:09:07.523Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据类型介绍及数值的存储方式"><a href="#数据类型介绍及数值的存储方式" class="headerlink" title="数据类型介绍及数值的存储方式"></a>数据类型介绍及数值的存储方式</h3><p>具体可看：<a href="https://juejin.cn/post/6844903990904225805">「前端料包」可能是最透彻的JavaScript数据类型详解</a></p><p>JavaScript共有8种数据类型</p><ul><li>7种基本数据类型——Undefined、Null、Boolean、Number、String、Symbol（es6新增，表示独一无二的值）、BigInt（es10新增）<ul><li>直接存储在 <strong>栈</strong>（stack）中，占据空间小、大小固定，属于频繁被使用数据，所以放入栈中存储。</li></ul></li><li>1种引用数据类型——Object（本质上，由一组无序的名值对组成），其中包含 function、Array、Date等。<ul><li>同时存储在 <strong>栈</strong>（stack）和 <strong>堆</strong>（heap）中，占据空间大、大小不固定。</li><li>在 <strong>栈</strong> 中存储了指针，该指针指向 <strong>堆</strong> 中该实体的起始地址。当解释器寻找引用值时，会首先检索其在 <strong>栈</strong> 中的地址，取得地址后从 <strong>堆</strong> 中获得实体。</li></ul></li><li>JavaScript不支持创建自定义类型数据</li></ul><h4 id="undefined与undeclared的区别？"><a href="#undefined与undeclared的区别？" class="headerlink" title="undefined与undeclared的区别？"></a>undefined与undeclared的区别？</h4><p>已在作用域中声明但还没有赋值的变量，是undefined。</p><p>还没有在作用域中声明过的变量，是undeclared。</p><p>对于undeclared变量的引用，浏览器会报引用错误，如ReferenceError: b is not defined。但是我们可以使用typeof的安全防范机制来避免报错，因为对于 undeclared（或者not defined）变量，typeof会返回”undefined”。</p><h4 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h4><p>首先Undefined和Null都是基本数据类型，这两个基本数据类型分别都只有一个值，就是undefined和null。</p><p>undefined代表的含义是未定义，null代表的含义是空对象（其实不是真的对象，请看下面的 <strong>注意</strong> ！）。一般变量声明了但还没有定义的时候会返回undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>其实 <strong>null</strong> 不是对象，虽然 <strong>typeof null</strong> 会输出object，但是这只是JS存在的一个悠久Bug。在JS的最初版本中使用的是32位系统，为了性能考虑使用低位存储变量的类型信息，000开头代表是对象，然而null表示为全零，所以将它错误的判断为object。虽然现在的内部类型判断代码已经改变了，但是对于这个Bug却是一直流传下来。</p><p>undefined在js中不是一个保留字，这意味着我们可以使用undefined来作为一个变量名，这样的做法是非常危险的，它会影响我们对undefined值的判断。但是我们可以通过一些方法获得安全的undefined值，比如说void 0。</p><p>当我们对两种类型使用typeof进行判断的时候，Null类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><p>详细资料可以参考</p><p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bundefined%E4%B8%8Enull.html">《JavaScript 深入理解之 undefined 与 null》</a></p><h4 id="字符串转义字符"><a href="#字符串转义字符" class="headerlink" title="字符串转义字符"></a>字符串转义字符</h4><p>转义符皆以“\”开头的，常用转义如下：</p><table><thead><tr><th>转义符</th><th>说明</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行符</td></tr><tr><td><code>\</code></td><td>斜杠\</td></tr><tr><td><code>&#39;</code></td><td>‘’ 单引号</td></tr><tr><td><code>*</code></td><td>“” 双引号</td></tr><tr><td><code>\t</code></td><td>tab缩进</td></tr><tr><td><code>\b</code></td><td>空格，b是blank的意思</td></tr></tbody></table><h3 id="数据类型的转换方式"><a href="#数据类型的转换方式" class="headerlink" title="数据类型的转换方式"></a>数据类型的转换方式</h3><p>在 JS 中，类型转换只有三种情况，分别是：</p><ul><li><p>转换为布尔值</p><ul><li><table><thead><tr><th>方式</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>Boolean()</td><td>其他类型转换成布尔值</td><td>Boolean(‘true’)</td></tr></tbody></table></li></ul></li><li><p>转换为数值型</p><ul><li><table><thead><tr><th>方式</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>parseInt(string)</td><td>将string型转换成整型数值型</td><td>parseInt(‘28’)</td></tr><tr><td>parseFloat(string)</td><td>将string型转换成浮点数数值型</td><td>parseFloat(‘28.12’)</td></tr><tr><td>Number()强制转换</td><td>将string型转换成数值型</td><td>Number(‘12’)</td></tr><tr><td>js隐式转换 （- * &#x2F;）</td><td>利用算术运算隐式转换为数值型</td><td>‘12’ - 0</td></tr></tbody></table></li></ul></li><li><p>转换为字符串</p><ul><li><table><thead><tr><th>方式</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>.toString()</td><td>转换成字符串</td><td>var num&#x3D;1; alert(num.toString());</td></tr><tr><td>String()</td><td>转换成字符串（强制转换）</td><td>var num&#x3D;1; alert(String(num));</td></tr><tr><td>加号拼接字符串</td><td>任意类型和字符串拼接结果都是字符串</td><td>var num&#x3D;1; alert(num + ‘字符串’)</td></tr></tbody></table></li><li><code>null</code>和 <code>underfined</code>没有 <code>.toString</code>方法</li></ul></li></ul><h3 id="数据类型的判断方法——typeof，instanceof，constructor，Object-prototype-toString-call"><a href="#数据类型的判断方法——typeof，instanceof，constructor，Object-prototype-toString-call" class="headerlink" title="数据类型的判断方法——typeof，instanceof，constructor，Object.prototype.toString.call()"></a>数据类型的判断方法——typeof，instanceof，constructor，Object.prototype.toString.call()</h3><h4 id="typeof-可用于判断基本数据类型"><a href="#typeof-可用于判断基本数据类型" class="headerlink" title="typeof 可用于判断基本数据类型"></a>typeof 可用于判断<strong>基本数据类型</strong></h4><p>对于原始数据类型来说，除了null都可以显示正确的类型</p><ul><li>对于null，返回object<blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// null 的数据类型被 typeof 解释为object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br></pre></td></tr></table></figure></blockquote></li><li>除了function以外的引用类型，都会返回object</li></ul><h4 id="instanceof-可用于判断引用数据类型"><a href="#instanceof-可用于判断引用数据类型" class="headerlink" title="instanceof 可用于判断引用数据类型"></a>instanceof 可用于判断<strong>引用数据类型</strong></h4><p>因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p><p>instanceof实现原理</p><p>instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p><p>实现 instanceof：</p><ol><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  let prototype = right.prototype</span><br><span class="line">  left = left.proto</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (left === null || left === undefined)</span><br><span class="line">      return false  </span><br><span class="line">    if (prototype === left)</span><br><span class="line">      return true  </span><br><span class="line">    left = left.proto</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">2</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span>).<span class="property">constructor</span> === <span class="title class_">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;str&#x27;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(([]).<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注：如果创建了一个对象，并更改它的原型，<strong>constructor</strong>就无法做出准确的判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span> === <span class="title class_">Fn</span>);    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><p>使用 <code>Object</code> 对象的原型方法 <code>toString</code> ，使用 <code>call</code> 进行狸猫换太子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">true</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="string">&#x27;str&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>([]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(&#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">undefined</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据类型介绍及数值的存储方式&quot;&gt;&lt;a href=&quot;#数据类型介绍及数值的存储方式&quot; class=&quot;headerlink&quot; title=&quot;数据类型介绍及数值的存储方式&quot;&gt;&lt;/a&gt;数据类型介绍及数值的存储方式&lt;/h3&gt;&lt;p&gt;具体可看：&lt;a href=&quot;https://</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>对象</title>
    <link href="https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E5%AF%B9%E8%B1%A1/"/>
    <id>https://superq314.github.io/2022/07/18/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-07-18T07:45:26.631Z</published>
    <updated>2022-07-18T09:49:54.399Z</updated>
    
    <content type="html"><![CDATA[<p>详细资料可以参考：<a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html">《JavaScript 深入理解之对象创建》</a></p><h3 id="创建方式——三种（基础方式）"><a href="#创建方式——三种（基础方式）" class="headerlink" title="创建方式——三种（基础方式）"></a>创建方式——三种（基础方式）</h3><ul><li><strong>字面量</strong> 创建对象</li><li><strong>new Object</strong> 创建对象</li><li><strong>构造函数</strong> 创建对象</li></ul><h4 id="字面量——创建对象"><a href="#字面量——创建对象" class="headerlink" title="字面量——创建对象"></a>字面量——创建对象</h4><p><strong>花括号{}</strong> ：包含表达这个具体事物（对象）的<strong>属性和方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;王权&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;999&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象：</p><ul><li>里面的属性或方法采取<strong>键值对</strong>的形式</li><li>多个属性或方法中间用逗号隔开</li><li>方法冒号后面跟的是一个<strong>匿名函数</strong></li></ul><p>使用对象：</p><ul><li>调用对象的属性【1】：<strong>对象名.属性名</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用对象obj里面的name属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>)</span><br></pre></td></tr></table></figure><ul><li>调用对象的属性【2】：<strong>对象名[‘属性名’]</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure><ul><li>调用对象的方法：<strong>对象名.方法名()</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="title function_">seyHi</span>()</span><br></pre></td></tr></table></figure><h4 id="new-Object——创建对象"><a href="#new-Object——创建对象" class="headerlink" title="new Object——创建对象"></a>new Object——创建对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new Object 创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line">obj.<span class="property">name</span> = jay;</span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">obj.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>利用 &#x3D; 等号赋值的方法，给对象添加属性和方法</li><li>每个属性和方法之间用分号结束</li></ul><h4 id="构造函数——创建对象"><a href="#构造函数——创建对象" class="headerlink" title="构造函数——创建对象"></a>构造函数——创建对象</h4><p>构造函数：应用函数的方式，封装相同的代码<br><strong>构造函数：把对象里面一些相同的属性和方法抽象出来封装到函数里</strong><br>构造函数与普通函数的<strong>区别</strong> ：里面<strong>封装</strong>的不是普通代码，而是<strong>对象</strong> ，所以和普通函数不一样<br>优点：解决了工厂模式中对象类型无法识别的问题，并且创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型。<br>缺点：我们知道 ECMAScript 中的函数是对象，在使用构造函数创建对象时，每个方法都会在实例对象中重新创建一遍。拿上面的例子举例，这意味着每创建一个对象，我们就会创建一个 sayName 函数的实例，但它们其实做的都是同样的工作，因此这样便会造成内存的浪费。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数语法格式</span></span><br><span class="line"><span class="keyword">function</span> 构造函数名() &#123;</span><br><span class="line">    <span class="variable language_">this</span>.属性 = 值;</span><br><span class="line">    <span class="variable language_">this</span>.方法 = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用构造函数</span></span><br><span class="line"><span class="keyword">new</span> 构造函数名();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数的示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">name, age, sex</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params">sang</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(sang);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh =  <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>); <span class="comment">// 调用函数返回的是一个对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> ldh); <span class="comment">// Object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh.<span class="property">name</span>); <span class="comment">// 刘德华</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ldh[<span class="string">&#x27;age&#x27;</span>]);<span class="comment">// 18</span></span><br><span class="line">ldh.<span class="title function_">sing</span>(<span class="string">&#x27;冰雨&#x27;</span>); <span class="comment">// 调用构造函数里面的方法，并传值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要创建多个对象，只需要调用构造函数即可创建：</span></span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">18</span> , <span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>构造函数首字母要大写</li><li>构造函数不需要return，就可以返回结果</li><li>调用构造函数 ，必须使用new</li><li>构造函数里面的属性和方法必须添加this</li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>主要工作原理：用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。<br>优点：解决了创建多个相似对象时，代码的复用问题<br>缺点：使用工厂模式创建的对象，没有解决对象识别的问题（就是怎样知道一个对象的类型是什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    o.<span class="property">name</span> = name;</span><br><span class="line">    o.<span class="property">age</span> = age;</span><br><span class="line">    o.<span class="property">job</span> = job;</span><br><span class="line">    o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;james&quot;</span>,<span class="number">9</span>,<span class="string">&quot;student&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;kobe&quot;</span>,<span class="number">9</span>,<span class="string">&quot;student&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>每一个函数都有一个 prototype属性，这个属性指向函数的原型对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<br>通过使用原型对象来添加公用属性和方法，从而实现代码的复用。<br>优点：解决了构造函数模式中多次创建相同函数对象的问题，所有的实例可以共享同一组属性和函数。<br>缺点：</p><ol><li>首先第一个问题是原型模式省略了构造函数模式传递初始化参数的过程，所有的实例在默认情况下都会取得默认的属性值，会在一定程度上造成不方便。</li><li>因为所有的实例都是共享一组属性，对于包含基本值的属性来说没有问题，但是对于包含引用类型的值来说（例如数组对象），所有的实例都是对同一个引用类型进行操作，那么属性的操作就不是独立的，最后导致读写的混乱。我们创建的实例一般都是要有属于自己的全部属性的，因此单独使用原型模式的情况是很少存在的。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;james&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">9</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;student&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;james&quot;</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;james&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> === person2.<span class="property">sayName</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。<br>优点：采用了构造函数模式和原型模式的优点，这种混成模式是目前使用最广泛，认同度最高的一种创建自定类型的方法。<br>缺点：由于使用了两种模式，因此对于代码的封装性来说不是很好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title function_">createPerson</span>(<span class="string">&quot;james&quot;</span>，<span class="number">9</span>，<span class="string">&quot;student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title function_">createPerson</span>(<span class="string">&quot;kobe&quot;</span>，<span class="number">9</span>，<span class="string">&quot;student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// &quot;james&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// &quot;kobe&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> === person2.<span class="property">sayName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">sayName</span> !== <span class="string">&quot;function&quot;</span> )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title function_">createPerson</span>(<span class="string">&quot;james&quot;</span>，<span class="number">9</span>，<span class="string">&quot;student&quot;</span>);</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;james&quot;</span></span><br></pre></td></tr></table></figure><p>优点：解决了混成模式中封装性的问题</p><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>如果在前面几种模式不适用的情况下，可以使用寄生构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后返回新创建的对象。<br>优点：我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。<br>缺点：和工厂模式一样的问题，不能依赖 instanceof 操作符来确定对象的类型。<br>如下面的例子所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    o.<span class="property">name</span> = name;</span><br><span class="line">    o.<span class="property">age</span> = age;</span><br><span class="line">    o.<span class="property">job</span> = job;</span><br><span class="line">    o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;james&quot;</span>，<span class="number">9</span>，<span class="string">&quot;student&quot;</span>);</span><br></pre></td></tr></table></figure><p>通过上面的例子我们可以发现，其实这个模式和工厂模式基本上是一摸一样的，只不过我们是采用 new 操作符最后来创建对象。<br>注意在构造函数不返回值的情况下，默认会返回新创建的对象，而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。</p><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>Douglas Crockford 发明了 JavaScript 中的稳妥对象这个概念。所谓稳妥对象，指的就是，没有公共属性，而且其方法也不使用 this 的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序改动时使用。</p><p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用 this ；二是不使用 new 操作符调用构造函数。<br>优点：以上面为例，除了 sayName 方法外，没有别的方法可以访问数据成员，这就是稳妥构造函数提供的安全性。<br>缺点：和寄生构造函数一样，没有办法使用 instanceof 操作符来判断对象的类型<br>因此我们可以将前面的例子改写如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回对象</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  <span class="title class_">Person</span>(<span class="string">&quot;james&quot;</span>，<span class="number">9</span>，<span class="string">&quot;student&quot;</span>);</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;james&quot;</span></span><br></pre></td></tr></table></figure><h2 id="对象解构赋值"><a href="#对象解构赋值" class="headerlink" title="对象解构赋值"></a>对象解构赋值</h2><a href="/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ECMAScript2015(ES6)%E6%96%B0%E7%89%B9%E6%80%A7/" title="ECMAScript 2015（ES6）新特性">ECMAScript 2015（ES6）新特性</a>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;详细资料可以参考：&lt;a href=&quot;http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>执行上下文this指向</title>
    <link href="https://superq314.github.io/2022/07/17/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87this%E6%8C%87%E5%90%91/"/>
    <id>https://superq314.github.io/2022/07/17/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87this%E6%8C%87%E5%90%91/</id>
    <published>2022-07-17T04:37:38.781Z</published>
    <updated>2022-07-18T09:51:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>this——当函数被调用时，与函数上下文绑定，指向某个对象的引用。</p><h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><h3 id="普通函数中的-this——默认绑定"><a href="#普通函数中的-this——默认绑定" class="headerlink" title="普通函数中的 this——默认绑定"></a>普通函数中的 this——默认绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span> () &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>普通函数在非严格的全局环境下调用时，其中的 this 指向的是 window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span> () &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>用了严格模式 “use strict”，严格模式下无法再意外创建全局变量，所以 this 不为 window 而为 undefined。<br>注意：babel 转成 ES6 的，babel 会自动给 js 文件上加上严格模式。</p><h3 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h3><p>在箭头函数中，this 的指向是由外层(函数或全局)作用域来决定的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Animal</span> = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="title function_">getName</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>此时 this 指向 window。这里也印证了那句经典的话：“ <strong>匿名函数的 this 永远指向 window</strong> ”。</p><p>如果要让 this 指向 Animal 这个对象，则可以巧用箭头函数来解决。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Animal</span> = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="title function_">getName</span>() <span class="comment">// &#123;getName: ƒ&#125;</span></span><br></pre></td></tr></table></figure><p>因为  <strong>在箭头函数中，this 的指向是由外层（函数或全局）作用域来决定的</strong> 。所以上述例子中的箭头函数的外层作用域就是 Animal。</p><p>严格模式对箭头函数没有效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>我们都知道箭头函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。普通函数使用了严格模式 this 会指向 undefined 但箭头函数依然指向了 window。</p><h3 id="函数作为对象的方法中的-this——隐式绑定"><a href="#函数作为对象的方法中的-this——隐式绑定" class="headerlink" title="函数作为对象的方法中的 this——隐式绑定"></a>函数作为对象的方法中的 this——隐式绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">add</span>(); </span><br><span class="line"><span class="comment">// &#123;name: &quot;coboy&quot;, age: 18, add: ƒ&#125; &quot;coboy&quot; 18</span></span><br></pre></td></tr></table></figure><p>在对象方法中，作为对象的一个方法被调用时，this 指向调用它所在方法的对象。也就是开头我们所说的那句：“ <strong>谁调用了它，它就指向谁</strong> ”，在这里很明显是 obj 调用了它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> fn = obj.<span class="property">add</span></span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>这个时候 this 则仍然指向 window。obj 对象方法 add 赋值给 fn 之后，fn 仍然在 window 的全局环境中执行，所以 this 仍然指向 window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">add</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>如果在对象方法内部声明一个函数，这个函数的 this 在对象方法执行的时候指向就不是这个对象了，而是指向 window 了。这里为什么会指向 window 呢？上述代码中声明了一个 fn 函数，接着又马上执行了它，其实可以看做是一个匿名的自执行函数，代码可以变成如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;)()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">add</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>我们再回溯一下本文开头说到的那句经典的话：“ <strong>匿名函数的 this 永远指向 window</strong> ”，所以为什么指向 window，是不是很清楚了呢。</p><p>同样想要 this 指向 obj 可以通过箭头函数来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">add</span>() <span class="comment">// obj</span></span><br></pre></td></tr></table></figure><p>再次说明箭头函数的 this 是由外层函数作用域或者全局作用域决定的。</p><h3 id="上下文对象调用中的-this——隐式绑定"><a href="#上下文对象调用中的-this——隐式绑定" class="headerlink" title="上下文对象调用中的 this——隐式绑定"></a>上下文对象调用中的 this——隐式绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">add</span>() === obj) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>参考上文我们很容易知道 this 就是指向 obj 对象本身，所以返回 true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">dog</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;cobyte&#x27;</span>,</span><br><span class="line">        <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">animal.<span class="property">dog</span>.<span class="title function_">getName</span>() <span class="comment">// &#x27;cobyte&#x27;</span></span><br></pre></td></tr></table></figure><p>如果函数中的 this 是被上一级的对象所调用的，那么 this 指向的就是上一级的对象，也就是开头所说的：“谁调用了它，它就指向谁”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy1&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">txt</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy2&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj1.<span class="title function_">getName</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy3&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj2.<span class="title function_">getName</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">getName</span>()) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="title function_">getName</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3.<span class="title function_">getName</span>())</span><br></pre></td></tr></table></figure><p>三个最终都打印了coboy1。<br>执行 obj3.getName ，返回 obj2.getName 里面返回的结果；obj2.getName 里面返回的是 obj1.getName 的结果；obj1.getName 里的结果是 ‘coboy1’。</p><p>如果上面的题改一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy1&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">txt</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy2&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj1.<span class="title function_">getName</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy3&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> fn = obj1.<span class="property">getName</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">getName</span>()) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="title function_">getName</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3.<span class="title function_">getName</span>())</span><br></pre></td></tr></table></figure><p>这个时候输出了 coboy1, coboy1, undefined。<br>最后一个其实在上面例题5中已经有说明了。通过 const fn &#x3D; obj1.getName 的赋值进行了“裸奔”调用，因此这里的 this 指向了 window,运行结果当然是 undefined。</p><p>上述的例题10中的 obj2.getName() 如果要它输出‘coboy2’，如果不使用 bind、call、apply 方法该怎么做？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy1&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">txt</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy2&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: obj1.<span class="property">getName</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="title function_">getName</span>()) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="title function_">getName</span>())</span><br></pre></td></tr></table></figure><p>上述方法同样说明了那个重要的结论：this 指向最后调用它的对象。</p><p>我们将函数 obj1 的 getName 函数挂载到了 obj2 的对象上，getName 最终作为 obj2 对象的方法被调用。</p><h3 id="在构造函数中的-this"><a href="#在构造函数中的-this" class="headerlink" title="在构造函数中的 this"></a>在构造函数中的 this</h3><p>通过 new 操作符来构建一个构造函数的实例对象，这个构造函数中的 this 就指向这个新的实例对象。同时构造函数 prototype 属性下面方法中的 this 也指向这个新的实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// Animal &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1) <span class="comment">// Animal &#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">txt</span> = <span class="string">&#x27;coboy&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getNum</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">txt</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1.<span class="property">age</span>) <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1.<span class="title function_">getNum</span>()) <span class="comment">// &#x27;coboy&#x27;</span></span><br></pre></td></tr></table></figure><p>在构造函数中出现显式 return 的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">txt</span> = <span class="string">&#x27;coboy&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;<span class="attr">txt</span>: <span class="string">&#x27;cobyte&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1.<span class="property">txt</span>) <span class="comment">// cobyte</span></span><br></pre></td></tr></table></figure><p>此时 a1 返回的是空对象 obj。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">txt</span> = <span class="string">&#x27;coboy&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1.<span class="property">txt</span>) <span class="comment">// &#x27;coboy&#x27;</span></span><br></pre></td></tr></table></figure><p>由此可以看出，如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向返回的对象，如果返回的不是一个对象，而是基本类型，那么 this 仍然指向实例。</p><h3 id="call、apply、bind指定函数的this指向——显示绑定"><a href="#call、apply、bind指定函数的this指向——显示绑定" class="headerlink" title="call、apply、bind指定函数的this指向——显示绑定"></a>call、apply、bind指定函数的this指向——显示绑定</h3><p>如下</p><h2 id="call，apply，bind-修改-this-指向"><a href="#call，apply，bind-修改-this-指向" class="headerlink" title="call，apply，bind 修改 this 指向"></a>call，apply，bind 修改 this 指向</h2><p>call方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">txt</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;cobyte&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">getName</span>(); <span class="comment">// this指向obj</span></span><br><span class="line">obj.<span class="property">getName</span>.<span class="title function_">call</span>(obj1); <span class="comment">// this指向obj1</span></span><br><span class="line">obj.<span class="property">getName</span>.<span class="title function_">call</span>(); <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure><p>apply方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">txt</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;cobyte&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getName</span>();  <span class="comment">// this指向obj</span></span><br><span class="line">obj.<span class="property">getName</span>.<span class="title function_">apply</span>(obj1); <span class="comment">// this指向obj1</span></span><br><span class="line">obj.<span class="property">getName</span>.<span class="title function_">apply</span>();  <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure><p>call 方法和 apply 方法的区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params">name1, name2</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, name1, name2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;cobyte&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">getName</span>.<span class="title function_">call</span>(obj1, <span class="string">&#x27;coboy1&#x27;</span>, <span class="string">&#x27;coboy2&#x27;</span>)</span><br><span class="line">obj.<span class="property">getName</span>.<span class="title function_">apply</span>(obj1, [<span class="string">&#x27;coboy1&#x27;</span>, <span class="string">&#x27;coboy2&#x27;</span>])</span><br></pre></td></tr></table></figure><p>可见 call 和 apply 主要区别是在传参上。apply 方法与 call 方法用法基本相同，不同点主要是 call() 方法的第二个参数和之后的参数可以是任意数据类型，而 apply 的第二个参数是数组类型或者 arguments 参数集合。</p><p>bind 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&quot;coboy&quot;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>, </span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">txt</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&quot;cobyte&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newGetName = obj.<span class="property">getName</span>.<span class="title function_">bind</span>(obj2)</span><br><span class="line"><span class="title function_">newGetName</span>(); <span class="comment">// this指向obj2</span></span><br><span class="line">obj.<span class="title function_">getName</span>(); <span class="comment">// this仍然指向obj</span></span><br></pre></td></tr></table></figure><p>bind() 方法也能修改 this 指向，不过调用 bind() 方法不会执行 getName()函数，也不会改变 getName() 函数本身，只会返回一个已经修改了 this 指向的新函数，这个新函数可以赋值给一个变量，调用这个变量新函数才能执行 getName()。</p><p>call() 方法和 bind() 方法的区别在于</p><ol><li>bind 的返回值是函数，并且不会自动调用执行。</li><li>两者后面的参数的使用也不同。call 是 把第二个及以后的参数作为原函数的实参传进去， 而 bind 实参在其传入参数的基础上往后获取参数执行。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b, c</span>)&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn1 = fn.<span class="title function_">bind</span>(&#123;abc : <span class="number">123</span>&#125;,<span class="number">600</span>);</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>) <span class="comment">// 100,200,300 </span></span><br><span class="line"><span class="title function_">fn1</span>(<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>) <span class="comment">// 600,100,200 </span></span><br><span class="line"><span class="title function_">fn1</span>(<span class="number">200</span>,<span class="number">300</span>) <span class="comment">// 600,200,300 </span></span><br><span class="line">fn.<span class="title function_">call</span>(&#123;abc : <span class="number">123</span>&#125;,<span class="number">600</span>) <span class="comment">// 600,undefined,undefined</span></span><br><span class="line">fn.<span class="title function_">call</span>(&#123;abc : <span class="number">123</span>&#125;,<span class="number">600</span>,<span class="number">100</span>,<span class="number">200</span>) <span class="comment">// 600,100,200</span></span><br></pre></td></tr></table></figure><h2 id="this-优先级"><a href="#this-优先级" class="headerlink" title="this 优先级"></a>this 优先级</h2><p>我们通常把通过 call、apply、bind、new 对 this 进行绑定的情况称为显式绑定，而把根据调用关系确定 this 指向的情况称为隐式绑定。那么显示绑定和隐式绑定谁的优先级更高呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">txt</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy1&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: getName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy2&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: getName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">getName</span>.<span class="title function_">call</span>(obj2) <span class="comment">// &#x27;coboy2&#x27;</span></span><br><span class="line">obj2.<span class="property">getName</span>.<span class="title function_">apply</span>(obj1) <span class="comment">// &#x27;coboy1&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看出 call、apply 的显示绑定比隐式绑定优先级更高些。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">txt</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newGetName = getName.<span class="title function_">bind</span>(obj1)</span><br><span class="line"><span class="title function_">newGetName</span>(<span class="string">&#x27;coboy&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1) <span class="comment">// &#123;txt: &quot;coboy&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>当再使用 newGetName 作为构造函数时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="title function_">newGetName</span>(<span class="string">&#x27;cobyte&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">txt</span>) <span class="comment">// &#x27;cobyte&#x27;</span></span><br></pre></td></tr></table></figure><p>这个时候新对象中的 txt 属性值为 ‘cobyte’。<br>newGetName 函数本身是通过 bind 方法构造的函数，其内部已经将this绑定为 obj1,当它再次作为构造函数通过 new 被调用时，返回的实例就已经和 obj1 解绑了。也就是说，new 绑定修改了 bind 绑定中的 this 指向，所以 new 绑定的优先级比显式 bind 绑定的更高。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">txt</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">txt</span>: <span class="string">&#x27;coboy1&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">txt</span>: <span class="string">&#x27;coboy2&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newGetName = getName.<span class="title function_">call</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newGetName.<span class="title function_">call</span>(obj2)) <span class="comment">// &#x27;coboy1&#x27;</span></span><br></pre></td></tr></table></figure><p>由于 getName 中的 this 绑定到了 obj1 上，所以 newGetName(引用箭头函数) 中的 this 也会绑到 obj1 上，箭头函数的绑定无法被修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="string">&#x27;good boy&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params"></span>) =&gt; <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">txt</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">txt</span>: <span class="string">&#x27;coboy1&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">txt</span>: <span class="string">&#x27;coboy2&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newGetName = getName.<span class="title function_">call</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newGetName.<span class="title function_">call</span>(obj2)) <span class="comment">// &#x27;good boy&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> txt = <span class="string">&#x27;good boy&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getName</span> = (<span class="params"></span>) =&gt; <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">txt</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">txt</span>: <span class="string">&#x27;coboy1&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">txt</span>: <span class="string">&#x27;coboy2&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newGetName = getName.<span class="title function_">call</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newGetName.<span class="title function_">call</span>(obj2)) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>const 声明的变量不会挂到 window 全局对象上，所以 this 指向 window 时，自然也找不到 txt 变量了。</p><h2 id="箭头函数的-this-绑定无法修改"><a href="#箭头函数的-this-绑定无法修改" class="headerlink" title="箭头函数的 this 绑定无法修改"></a>箭头函数的 this 绑定无法修改</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">txt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">txt</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;cobyte&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="title class_">Fn</span>.<span class="title function_">call</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">call</span>(obj2)) <span class="comment">// &#x27;coboy&#x27;</span></span><br></pre></td></tr></table></figure><p>由于 Fn 中的 this 绑定到了 obj1 上，所以 f 中的 this 也会绑定到 obj1 上， 箭头函数的绑定无法被修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="string">&#x27;意外不&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Fn</span> = (<span class="params"></span>) =&gt; <span class="function"><span class="params">txt</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">txt</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;coboy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;cobyte&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="title class_">Fn</span>.<span class="title function_">call</span>(obj1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">call</span>(obj2)) <span class="comment">// &#x27;意外不&#x27;</span></span><br></pre></td></tr></table></figure><p>如果将 var 声明方式改成 const 或 let 则最后输出为 undefined，原因是使用 const 或 let 声明的变量不会挂载到 window 全局对象上。因此，this 指向 window 时，自然也找不到 txt 变量了。</p><h2 id="从手写-new-操作符中去理解-this"><a href="#从手写-new-操作符中去理解-this" class="headerlink" title="从手写 new 操作符中去理解 this"></a>从手写 new 操作符中去理解 this</h2><p>有一道经典的面试题，JS 的 new 操作符到底做了什么？</p><ol><li>创建一个新的空对象</li><li>把这个新的空对象的隐式原型（<code>__proto__</code>）指向构造函数的原型对象（<code>prototype</code>）</li><li>把构造函数中的 this 指向新创建的空对象并且执行构造函数返回执行结果</li><li>判断返回的执行结果是否是引用类型，如果是引用类型则返回执行结果，new 操作失败，否则返回创建的新对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  create函数要接受不定量的参数，第一个参数是构造函数（也就是new操作符的目标函数），其余参数被构造函数使用。</span></span><br><span class="line"><span class="comment">  new Create() 是一种js语法糖。我们可以用函数调用的方式模拟实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">Fn,...args</span>)&#123;</span><br><span class="line">    <span class="comment">// 1、创建一个空的对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;; <span class="comment">// let obj = Object.create(&#123;&#125;);</span></span><br><span class="line">    <span class="comment">// 2、将空对象的原型prototype指向构造函数的原型</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj,<span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// obj.__proto__ = Fn.prototype </span></span><br><span class="line">    <span class="comment">// 以上 1、2步还可以通过 const obj = Object.create(Fn.prototype) 实现</span></span><br><span class="line">    <span class="comment">// 3、改变构造函数的上下文（this）,并将参数传入</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="title class_">Fn</span>.<span class="title function_">apply</span>(obj,args);</span><br><span class="line">    <span class="comment">// 4、如果构造函数执行后，返回的结果是对象类型，则直接将该结果返回，否则返回 obj 对象</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj;</span><br><span class="line">    <span class="comment">// return typeof result === &#x27;object&#x27; &amp;&amp; result != null ? result : obj</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下构造函数没有返回值，但是作为函数，是可以有返回值的，这就解析了上面例题15和例题16的原因了。<br>在 new 的时候，会对构造函数的返回值做一些判断：如果返回值是基础数据类型，则忽略返回值，如果返回值是引用数据类型，则使用 return 的返回，也就是 new 操作符无效。</p><h2 id="从手写-call、apply、bind-中去理解-this"><a href="#从手写-call、apply、bind-中去理解-this" class="headerlink" title="从手写 call、apply、bind 中去理解 this"></a>从手写 call、apply、bind 中去理解 this</h2><h3 id="手写-call-的实现"><a href="#手写-call-的实现" class="headerlink" title="手写 call 的实现"></a>手写 call 的实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">    context = context || <span class="variable language_">window</span></span><br><span class="line">    <span class="comment">// 创建唯一的属性防止污染</span></span><br><span class="line">    <span class="keyword">const</span> key = <span class="title class_">Symbol</span>()</span><br><span class="line">    <span class="comment">// this 就是绑定的那个函数</span></span><br><span class="line">    context[key] = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> result = context[key](...args)</span><br><span class="line">    <span class="keyword">delete</span> context[key]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>myCall 中的 this 指向谁？<br>myCall 已经设置在 Function 构造函数的原型对象（prototype）上了，所以每个函数都可以调用 myCall 方法，比如函数 Fn.myCall()，根据 this 的确定规律：“ <strong>谁调用它，this 就指向谁</strong> ”，所以myCall方法内的 this 就指向了调用的函数，也可以说是要绑定的那个函数。</li><li>Fn.myCall(obj) 本质就是把函数 Fn 赋值到 对象 obj 上，然后通过对象 obj.Fn() 来执行函数 Fn，那么最终又回到那个 this 的确定规律：“ <strong>谁调用它，this 就指向谁</strong> ”，因为对象 obj 调用了 Fn 所以 Fn 内部的 this 就指向了对象 obj。</li></ol><h3 id="手写-apply-的实现"><a href="#手写-apply-的实现" class="headerlink" title="手写 apply 的实现"></a>手写 apply 的实现</h3><p>apply 的实现跟 call 的实现基本是一样的，因为他们的使用方式也基本一样，只是传参的方式不一样。apply 的参数必须以数组的形式传参。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">context, args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(args)) &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数必须是数组&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="variable language_">window</span></span><br><span class="line">    <span class="comment">// 创建唯一的属性防止污染</span></span><br><span class="line">    <span class="keyword">const</span> key = <span class="title class_">Symbol</span>()</span><br><span class="line">    <span class="comment">// this 就是绑定的那个函数</span></span><br><span class="line">    context[key] = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> result = context[key](...args)</span><br><span class="line">    <span class="keyword">delete</span> context[key]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写-bind-的实现"><a href="#手写-bind-的实现" class="headerlink" title="手写 bind 的实现"></a>手写 bind 的实现</h3><p>bind 和 call、apply 方法的区别是它不会立即执行，它是返回一个改变了 this 指向的函数，在绑定的时候可以传参，之后执行的时候，还可以继续传参数数。这个就是一个典型的闭包行为了，是不是。<br>我们先来实现一个简单版的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">ctx, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据上文我们可以知道 this 就是调用的那个函数</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">bound</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">        <span class="comment">// 在再次执行的的时候去改变 this 的指向</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="title function_">apply</span>(ctx, [...args, ...newArgs])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，就如之前在 this 优先级分析那里所展示的规则：bind 返回的函数如果作为构造函数通过 new 操作符进行实例化操作的话，绑定的 this 就会实效。</p><p>为了实现这样的规则，我们就需要区分这两种情况的调用方式，那么怎么区分呢？首先返回出去的是 bound 函数，那么 new 操作符实例化的就是 bound 函数。通过上文  “ <strong>从手写 new 操作符中去理解 this</strong> ” 中我们可以知道当函数被 new 进行实例化的时候， 构造函数内部的 this 就是指向实例化的对象，那么判断一个函数是否是一个实例化的对象的构造函数时可以通过 intanceof 操作符判断。</p><p>知识点： <strong>instanceof</strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">ctx, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据上文我们可以知道 this 就是调用的那个函数</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">bound</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">        <span class="comment">// new Fn 的时候， this 是 Fn 的实例对象</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">self</span>(...args, ...newArgs)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在再次执行的的时候去改变 this 的指向</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="title function_">apply</span>(ctx, [...args, ...newArgs])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我们也可以通过上文的实现 new 操作符的代码来实现 bind 里面的 new 操作。</p><p>完整的复杂版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">ctx</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(self) === <span class="string">&#x27;[object Function]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;myBind must be called on a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 context 进行深拷贝，防止 bind 执行后返回函数未执行期间，context 被修改</span></span><br><span class="line">  ctx = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(ctx)) || <span class="variable language_">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造函数生成对象实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> &#123;<span class="type">Object|*</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> create = <span class="keyword">function</span> (<span class="params">conFn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置原型指向，确定继承关系 */</span></span><br><span class="line">    obj.<span class="property">__proto__</span> = conFn.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、执行目标函数，绑定函数内部的属性</span></span><br><span class="line"><span class="comment">     * 2、如果目标函数有对象类型的返回值则取返回值，符合js new关键字的规范</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> res = conFn.<span class="title function_">apply</span>(obj, <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res != <span class="literal">null</span> ? res : obj;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> bound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// new 操作符操作的时候</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> bound) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">create</span>(self, args.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(ctx, args.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="为什么显式绑定的-this-要比隐式绑定的-this-优先级要高"><a href="#为什么显式绑定的-this-要比隐式绑定的-this-优先级要高" class="headerlink" title="为什么显式绑定的 this 要比隐式绑定的 this 优先级要高"></a>为什么显式绑定的 this 要比隐式绑定的 this 优先级要高</h2><p>通过上面的实现原理，我们就可以理解为什么上面的 this 优先级中通过 call、apply、bind 和 new 操作符的显式绑定的 this 要比隐式绑定的 this 优先级要高了。例如上面的 obj1.getName.call(obj2) 中的 getName 方法本来是通过 obj1 来调用的，但通过 call 方法之后，实际 getName 方法变成了 obj2.getName() 来执行了。</p><h2 id="关于-this-的一些冷知识"><a href="#关于-this-的一些冷知识" class="headerlink" title="关于 this 的一些冷知识"></a>关于 this 的一些冷知识</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">txt</span>: <span class="string">&#x27;cobyte&#x27;</span>,</span><br><span class="line">    <span class="attr">getTxt</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">txt</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">;(<span class="number">0</span>, obj.<span class="property">getTxt</span>)()</span><br></pre></td></tr></table></figure><p>这个时候打印的则是 undefined， 因为这个时候 this 指向了 window。</p><p>这其中的原理则是：<br><strong>逗号操作符</strong> ：  对它的每个操作数求值（从左到右），并返回最后一个操作数的值。</p><p>所以 obj.getTxt 返回的值是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">txt</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>;(0, obj.getTxt)() 则相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">txt</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>所以这又回到了本文篇讲的那句：“ <strong>匿名函数的 this 永远指向 window</strong> ”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本篇内容的学习，我们看到 this 的用法纷繁多样，确实不容易掌握。但总的来说可以总结为以下几条规则：</p><ul><li>在函数体中，非显式或隐式地简单调用函数时，在严格模式下，函数内的 this 会绑定到 undefined 上，在非严格模式下则会被绑定到全局对象 window&#x2F;global 上。</li><li>一般使用 new 方法调用构造函数时，构造函数内的 this 会被绑定到新创建的对象上，且优先级要比 bind 的高。</li><li>一般通过 call、apply、bind 方法显式调用函数时，函数体内的 this 会被绑定到指定参数的对象上，显式绑定的 this 要比隐式绑定的 this 优先级要高。</li><li>一般通过上下文对象调用函数时，函数体内的 this 会被绑定到该对象上。</li><li>在箭头函数中，this 的指向是由外层（函数或全局）作用域来决定的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;this——当函数被调用时，与函数上下文绑定，指向某个对象的引用。&lt;/p&gt;
&lt;h2 id=&quot;this指向&quot;&gt;&lt;a href=&quot;#this指向&quot; class=&quot;headerlink&quot; title=&quot;this指向&quot;&gt;&lt;/a&gt;this指向&lt;/h2&gt;&lt;h3 id=&quot;普通函数中的-t</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS线程</title>
    <link href="https://superq314.github.io/2022/07/15/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E7%BA%BF%E7%A8%8B/"/>
    <id>https://superq314.github.io/2022/07/15/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-07-15T15:30:31.756Z</published>
    <updated>2022-07-18T15:10:57.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS线程组成"><a href="#JS线程组成" class="headerlink" title="JS线程组成"></a><strong>JS线程组成</strong></h2><p>虽然游览器是单线程执行JavaScript代码的，但是游览器有多个线程协助操作来实现单线程异步模型。</p><ol><li>GUI渲染线程</li><li>JavaScript引擎线程</li><li>事件触发线程</li><li>定时器触发线程</li><li>http请求线程</li><li>其他线程</li></ol><p>在JavaScript代码运行的过程中实际执行程序时同时只存在一个活动线程，实现同步异步就是靠多线程切换的形式来实现。</p><p>上面的细分线程可以归纳为两条线程：</p><ol><li>【主线程】：执行页面的渲染，js代码的运行，事件的触发等</li><li>【工作线程】：在幕后工作，用来处理异步任务的执行来实现非阻塞的运行模式</li></ol><p>作者：陈梵阿<br>链接：<a href="https://juejin.cn/post/7097518995620200485">https://juejin.cn/post/7097518995620200485</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JS线程组成&quot;&gt;&lt;a href=&quot;#JS线程组成&quot; class=&quot;headerlink&quot; title=&quot;JS线程组成&quot;&gt;&lt;/a&gt;&lt;strong&gt;JS线程组成&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;虽然游览器是单线程执行JavaScript代码的，但是游览器有多个线程协助</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript执行过程</title>
    <link href="https://superq314.github.io/2022/07/15/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JavaScript%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>https://superq314.github.io/2022/07/15/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JavaScript%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</id>
    <published>2022-07-15T14:52:04.262Z</published>
    <updated>2022-07-19T09:10:16.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="headerlink" title="浏览器的工作原理"></a>浏览器的工作原理</h1><p>比如： 浏览器中输入 <a href="https://link.juejin.cn/?target=http://www.baidu.com" title="http://www.baidu.com">www.baidu.com</a>，其中做了什么？</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f277237eeac482384d90619373e5586~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="05_02.png"></p><p>步骤解析：</p><ol><li>输入<a href="http://www.baidu.com/">www.baidu.com</a>, 被 <strong>浏览器内核</strong> 解析成ip地址（假设: 111.222.333.444）,根据ip地址，找到一台服务器，服务器就会返回一个 <code>index.html</code> 文件，用来解析（注意: 这里并不是把所有的静态资源到返回了，在框架时代，就应该是所谓的<strong>分包</strong>操作吧。打包成多个 chunk.js, 用到时再加载）。</li><li>在解析 index.html 过程中，<ol><li>如果遇到 link 标签，就会去服务器中下载对应的 css 文件；</li><li>如果遇到了 script 标签，就回去服务器中下载对应的 js 文件。</li></ol></li></ol><h1 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b01811e4f0fe4197b503668a7088cd00~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="05_03.png"></p><p>根据上面的图解，可以得出以下信息：</p><ul><li>HTML 经过 HTML Parser 生成解析 DOMTree，Style 经过 CSS Parser解析生成 StyleRules。</li><li>DOMTree 和 StyleRules 结合，生成渲染树（RenderTree）</li><li>执行 layout 过程，确定每个节点在屏幕上的确切坐标。</li><li>渲染树 绘制（Painting），然后展示在屏幕上。</li></ul><blockquote><p><strong>注意</strong> ：上面的步骤并不是严格顺序执行的。浏览器引擎会以最快的速度展示内容。简单的来说，就是一边解析HTML一边构建渲染树，构建一部分，就会把以后的元素渲染出来。如果样式没有加载出来，就会以浏览器默认的样式展示。</p><p><code>正是由于浏览器引擎的尽快展示内容，就会造成样式还没加载就展示的问题。这就是经常发生的FOCU（flash of unstyled content）或则 白屏问题。</code></p></blockquote><h2 id="CSS加载不会阻塞DOM树的解析"><a href="#CSS加载不会阻塞DOM树的解析" class="headerlink" title="CSS加载不会阻塞DOM树的解析"></a>CSS加载不会阻塞DOM树的解析</h2><p>通过上面的图解可以看出，HTML解析和CSS解析，是并行的。所以CSS加载不会阻塞DOM树的解析</p><h2 id="CSS加载会阻塞DOM树的渲染"><a href="#CSS加载会阻塞DOM树的渲染" class="headerlink" title="CSS加载会阻塞DOM树的渲染"></a>CSS加载会阻塞DOM树的渲染</h2><p>渲染树（RenderTree）是 DOMTree 和 StyleRules 的结合。所以，就算DOMTree加载完成，也要等到CSS加载完成并解析完成，才能生成渲染树。</p><h2 id="JS执行会阻塞DOM树的解析"><a href="#JS执行会阻塞DOM树的解析" class="headerlink" title="JS执行会阻塞DOM树的解析"></a>JS执行会阻塞DOM树的解析</h2><p>从渲染图可以知道 HTML 解析成 DOMTree， 如果遇到 JavaScript 代码， 就会停止解析HTML，就会把控制权交给  <strong>JS引擎</strong> ， 去执行 JavaScript 代码。当 JavaScript 执行完成后，浏览器再从中断的地方继续解析生成DOM。</p><blockquote><p>这也是建议将 script 标签放在 body 标签底部的原因。</p></blockquote><p><strong>特殊情况：</strong></p><p>在上面也说过了，CSS加载不会阻塞DOM树的解析。但是呢？如果在解析DOM的时候，里面加入script标签，引入了JavaScript代码（js是万能的，也可以修改DOM，也可以修改样式）。如果JavaScript代码，需要修改样式，那么就需要等待CSS加载完毕，才能操作CSS。所以在这种特殊的情况下， <strong>css加载也是会阻塞DOM的解析</strong> 。</p><h2 id="优化渲染过程"><a href="#优化渲染过程" class="headerlink" title="优化渲染过程"></a>优化渲染过程</h2><ul><li>使用内联的JS、CSS，减少JS、CSS文件的下载。</li><li>webpack等工具对JS、CSS文件压缩，减少文件的大小。</li><li>使用 async 或者 defer。</li><li>使用CDN。</li></ul><h1 id="JavaScript在浏览器中的执行过程"><a href="#JavaScript在浏览器中的执行过程" class="headerlink" title="JavaScript在浏览器中的执行过程"></a>JavaScript在浏览器中的执行过程</h1><p><a href="https://juejin.cn/post/7097961831670480910">参考</a></p><p>JavaScript是一门高级语言，需要转化成机器指令，才能在电脑的CPU中运行。使JavaScript代码转换成机器指令，是通过JavaScript引擎来完成的。</p><p>JavaScript引擎在把JavaScript代码转换成机器指令过程中，先对JavaScript代码进行解析（词法分析，语法分析），生成AST树，然后在通过一些列操作转换成机器指令，从而在CPU中运行。</p><p>运行过程：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28348dbdbbe842ab9ed0bdd6672cee4f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="05_04.png"></p><p>从上面图中，就可以看出，JavaScript代码一定需要经过解析，才能运行（后面会体现出来）。</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>执行上下文栈（Execution Context Stack，简写ECS），也被称为 <strong>函数调用栈</strong> 。</p><p>JavaScript引擎内部实现了一个执行上文栈，目的就是为了执行代码。只要有代码执行，一定是在执行上下文栈中执行的。</p><p>从名字可以看出，这是一个 <strong>栈结构</strong> ，意味着可以进行<strong>入栈</strong>和<strong>出栈</strong>操作，也有着<strong>栈底</strong>和<strong>栈顶</strong>的概念。</p><h2 id="全局执行上下文"><a href="#全局执行上下文" class="headerlink" title="全局执行上下文"></a>全局执行上下文</h2><p>全局执行上下文（Global Execution Context，简写GEC）。</p><p>只要代码想要执行，一定经过执行上下文栈，而执行上下文栈也被称为函数调用栈，也就意味着代码是以函数的形式被调用。但是全局代码（比如定义变量，定义函数等）并不是函数的形式，我们并不能主动调用代码，而被动的需要浏览器去调用代码。起到该作用的就是 <strong>全局执行上下文</strong> ，先解析全局代码然后执行。</p><p><code>全局执行上下文放在函数调用栈的栈底</code>。</p><h2 id="函数执行上下文"><a href="#函数执行上下文" class="headerlink" title="函数执行上下文"></a>函数执行上下文</h2><p>函数执行上下文（Function Execution Context，简写FEC）。</p><p>在执行代码的过程中，如果遇到函数的主动调用，就会生成一个函数执行上下文，<strong>入栈</strong>到函数调用栈中；当函数调动完成之后，就会执行出栈操作。</p><p>三者大致的关系如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ccba36353634269b357c4eae0d3e164~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="06_2.png"></p><h2 id="理解执行上下文"><a href="#理解执行上下文" class="headerlink" title="理解执行上下文"></a>理解执行上下文</h2><p>全局执行上下文和函数执行上下文，大致也分为两个阶段：<strong>编译阶段</strong>和 <strong>执行阶段</strong> 。</p><ul><li><p>编译阶段：其实就是解析代码的过程。（难点也是重点）</p><blockquote><p>解析过程中，保存了三个重要的信息：</p><ol><li><code>VO</code>(Variable Object)对象：该对象保存了当前执行上下文中的变量和函数地址（也就是当前作用域）。</li><li><code>作用域链</code>：VO(当前作用域) + ParentScope(父级作用域)</li><li><code>this的指向</code>： 视情况而定。</li></ol></blockquote></li><li><p>执行阶段：依次执行代码，给变量赋值等等一些操作。</p></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5487b7d351b4692a4137bb8513b5591~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="06_3.png"></p><p>我的简单理解就是：<code>编译创建信息，执行使用信息</code>。</p><h2 id="JavaScript的执行过程分析"><a href="#JavaScript的执行过程分析" class="headerlink" title="JavaScript的执行过程分析"></a>JavaScript的执行过程分析</h2><p>上面说到了太多的概念，可能会云里雾里的。那么直接看一段代码的执行过程，可以加深对上面的概念认识和理解。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;copyer&#x27;</span></span><br><span class="line"> <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"> <span class="title function_">foo</span>()</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> city = <span class="string">&#x27;cq&#x27;</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(city)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(age)</span><br></pre></td></tr></table></figure><p><strong>分析代码：</strong></p><h3 id="第一步：初始化全局对象"><a href="#第一步：初始化全局对象" class="headerlink" title="第一步：初始化全局对象"></a>第一步：初始化全局对象</h3><p>变量定义（name、age），函数定义（foo）,都是需要全局执行上下文来进行处理的。</p><p>全局执行上下文的两个阶段：</p><ul><li>编译阶段：在解析的过程中，会在堆内存中开辟一个地址（0x100），来保存一个GO对象; GO对象里面记录着JavaScript全局提供的一些属性和方法，和自己写的全局变量（还没有赋值）和全局函数。确定了三个信息：<ul><li>VO：指向GO的地址</li><li>Scope Chain: VO（因为全局就是最顶层的作用域，就没有父级作用域）</li><li>this: window</li></ul></li><li>执行阶段：依次执行代码，对GO对象，进行变量初始化，以及对函数的调用。</li></ul><blockquote><p><strong>认识GO对象</strong> ：</p><p>GO：Global Object，即全局对象，在全局执行上下文的编译阶段生成。</p><p>GO里面保存了JavaScript内部提供的一些全局的函数和属性（setTimeout,window,Math等等）。</p><p>在编译阶段，也会把自己写的全局变量添加进去（name，age）；解析是函数的话，也会在堆内存中开辟一个新的地址（0x200）来保存函数信息。在GO对象中，就会以key-value的形式保存（key:函数名，value:内存地址）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> <span class="title class_">GlobalObject</span> = &#123;</span><br><span class="line">     <span class="comment">//自带的</span></span><br><span class="line">     <span class="title class_">Math</span>: xxx,</span><br><span class="line">     <span class="attr">setTimeout</span>: xxx，</span><br><span class="line">     <span class="variable language_">window</span>：<span class="title class_">GlobalObject</span>，</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 新增的</span></span><br><span class="line">     name：<span class="literal">undefined</span>，</span><br><span class="line">     <span class="attr">age</span>: <span class="literal">undefined</span>,</span><br><span class="line">     <span class="attr">foo</span>: <span class="number">0x200</span></span><br><span class="line"> &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>函数内存空间</strong> ：</p><p>在解析过程中，如果遇到函数，就会在堆内存中开辟一个新的空间，来保存函数的一些信息。那么保存的有哪些内容呢？</p><ol><li>父级作用域（<code>parentScope</code>）: 函数的父级作用域在定义的时候就已经确定了。</li><li>函数执行体</li></ol></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1273ec0ba66482ab5df32abacd24dc2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="06_6.png"></p><h3 id="第二步：执行全局代码过程中，遇到函数调用"><a href="#第二步：执行全局代码过程中，遇到函数调用" class="headerlink" title="第二步：执行全局代码过程中，遇到函数调用"></a>第二步：执行全局代码过程中，遇到函数调用</h3><p>如果在执行的过程中，遇到的函数调用，就会产生一个函数执行上下文添加到函数调用栈中（ <strong>入栈</strong> ）；函数调用完成之后，就会弹出函数调用栈（ <strong>出栈</strong> ）。</p><p>函数执行上下文的两个阶段：</p><ul><li>编译阶段：在解析的函数过程中，会在堆内存中开辟一个地址（0x300），来保存一个AO对象; AO对象里面记录着函数形参（arguments）和定义的变量（包括内部函数定义）。确定了三个信息：<ul><li>VO：指向AO的地址</li><li>Scope Chain: AO + parentScope（函数定义的时候，parentScope就已经确认了）</li><li>this: window（一般根据调用的情况而定，这里是window调用的）</li></ul></li><li>执行阶段：依次执行函数体中的代码，对AO对象，进行变量初始化，以及对函数的调用。执行完毕之后，就弹出函数调用栈，也会自动清空堆内存中的AO对象。</li></ul><blockquote><p><strong>认识AO对象</strong> ：</p><p>AO：Activation Object，即活跃对象（当前函数处于激活的状态），在函数执行上下文的编译阶段生成。</p><p>里面保存了函数形参（arguments）和函数内部的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> <span class="title class_">ActivationObject</span> = &#123;</span><br><span class="line">     <span class="attr">arguments</span>: <span class="regexp">/是一个数组，这里保存的也是地址/</span></span><br><span class="line">     <span class="attr">city</span>: <span class="literal">undefined</span>,</span><br><span class="line"> &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f7af37701f94e8696c64d7a8662adb5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="06_7.png"></p><h2 id="JavaScript的变量提升"><a href="#JavaScript的变量提升" class="headerlink" title="JavaScript的变量提升"></a>JavaScript的变量提升</h2><p>JavaScript中有一种现象就是 <strong>变量提升</strong> 。这一过程，就发生在 （全局，函数）执行上下文的 <strong>编译阶段</strong> 。</p><p>在对JavaScript进行词法分析的时候，就会把变量保存在一个对象（GO、AO）中，只是没有赋值而已。对于函数定义而言，在解析的过程也会在堆内存中开辟一个新的地址，保存函数内容。所以，函数也能提前调用，不会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name)  <span class="comment">// undefined</span></span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;copyer&#x27;</span></span><br><span class="line"> <span class="title function_">foo</span>() <span class="comment">// 不会报错</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从内存的角度，真的能解释很多现象。</p><h2 id="JavaScript的作用域链"><a href="#JavaScript的作用域链" class="headerlink" title="JavaScript的作用域链"></a>JavaScript的作用域链</h2><p>在（全局，函数）执行上下文的<strong>编译阶段</strong>保存了三个信息，其中两个就是关于作用域的：</p><ul><li>VO：指向一个对象（AO，GO），也可以简单的理解为 <code>当前作用域</code></li><li>Scope Chain: <code>作用域链</code></li></ul><p>看下面的一段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> message = <span class="string">&#x27;copyer&#x27;</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="title function_">bar</span>()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">foo</span>()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p> <strong>代码分析</strong> ：</p><p>全局执行上下文：编译阶段生成GO对象(0x100)</p><ul><li>VO：0x100（GO）</li><li>scope chain：GO</li></ul><p>函数执行上下文（foo）：编译阶段生成AO对象（0x200）</p><ul><li>VO: 0x200（AO对象，foo）</li><li>scope chain：VO（0x200） + GO（0x100, parentScope）</li></ul><p>函数执行上下文（bar）：编译阶段生成AO对象（0x300）</p><ul><li>VO: 0x300 （AO, bar）</li><li>scope chain: VO（0x300） + AO（0x200, parentScope）</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b317b30d46c84b5bac9bb2a75d415b35~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="06_8.png"></p><p>在执行 bar 函数体的时候，发现message 在当前VO（0x300）中没有，就会沿着scope chain继续寻找。</p><ul><li>在 VO（0x300）中没有message，就会去parentScope（0x200）中去寻找。</li><li>在 VO（0x200）中也没有message，就会继续去parentScope（0x100）中去寻找。</li><li>在 VO（0x100）中发现message，也就是GO，所以打印 message 为 copyer</li></ul><p>这就是所谓的作用域链。</p><p> <strong>记住两句话</strong> ：</p><ol><li>父级作用域在编译阶段就已经确定了。</li><li>查找变量就是按照作用域链查找（找到近停止）。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>理解执行上下文栈（函数调用栈）： 所有代码执行的地方。</li><li>理解全局执行上下文： 针对全局代码。</li><li>理解函数执行上下文： 针对函数。</li><li>执行上下文的两个阶段： 编译阶段和执行阶段。</li><li>理解VO，GO，AO。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浏览器的工作原理&quot;&gt;&lt;a href=&quot;#浏览器的工作原理&quot; class=&quot;headerlink&quot; title=&quot;浏览器的工作原理&quot;&gt;&lt;/a&gt;浏览器的工作原理&lt;/h1&gt;&lt;p&gt;比如： 浏览器中输入 &lt;a href=&quot;https://link.juejin.cn/?ta</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://superq314.github.io/2022/07/15/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/Promise/"/>
    <id>https://superq314.github.io/2022/07/15/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/Promise/</id>
    <published>2022-07-15T04:55:01.578Z</published>
    <updated>2022-07-18T15:11:15.323Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7115732604057288734">掌握 Promise，三步即可</a></p><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>Callback 由于异步操作会造成回调地狱，还会造成难以测试的问题。</p><p>ES6 中的 Promise （基于<a href="https://promisesaplus.com/"> Promise A +</a> 规范的异步编程解决方案）</p><blockquote><p>基于<a href="http://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html">有限状态机</a>的原理</p></blockquote><p>主要解决如下问题：</p><ol><li>统一编码规范。只要开发者使用promise，就会给他一个承诺，成功的时候调用then方法，失败的时候调用catch方法等等一些列规范。</li><li>promise的链式调用解决了回调地狱的问题，提升了代码的可读性和可维护性。</li></ol><h3 id="Promise-对象的异步操作有三种状态"><a href="#Promise-对象的异步操作有三种状态" class="headerlink" title="Promise 对象的异步操作有三种状态"></a>Promise 对象的异步操作有三种状态</h3><blockquote><p><code>pending</code>（进行中）<br><code>fulfilled</code>（已成功）<br><code>rejected</code>（已失败）</p></blockquote><ul><li>只有异步操作结果可以决定当前的执行状态，任何其他操作无法改变状态的结果</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果</li><li>Promise 的状态只有两种变化：<ul><li>从 <code>pending</code>（进行中）变为 <code>fulfilled</code>（已成功）</li><li>从 <code>pending</code>（进行中）变为 <code>rejected</code>（已失败）</li><li>&#96;&#96;&#96;js<br>new Promise((resolve, reject) &#x3D;&gt; {<br>resolve() &#x2F;&#x2F; 状态：pending -&gt; fulfilled<br>reject()  &#x2F;&#x2F; 这里的状态就无法改动了（反过来也是一样）<br>})<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 温馨提示：</span><br><span class="line">&gt; 有限状态机提供了一种优雅的解决方式，异步的处理本身可以通过异步状态的变化来触发相应的操作，这会比回调函数在逻辑上的处理更加合理，也可以降低代码的复杂度。</span><br><span class="line"></span><br><span class="line">### Promise的流程图</span><br><span class="line"></span><br><span class="line">从上面的 promise的使用 和 promise的三种状态，可以总结出以下的流程过程：</span><br><span class="line">![10_02.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dfbc2602ecf413ea38c4b4786f288d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)</span><br><span class="line"></span><br><span class="line">### Promise的缺点</span><br><span class="line"></span><br><span class="line">* 无法取消 `Promise`，一旦新建它就会立即执行，无法中途取消。</span><br><span class="line">* 无法在 Promise 外部通过 `try...catch...` 的形式进行错误捕获（Promise 内部捕获了错误）</span><br><span class="line">* 状态单一，每次决断只能产生一种状态结果，需要不停的进行链式调用</span><br><span class="line"></span><br><span class="line">### Promise的传参</span><br><span class="line"></span><br><span class="line">ES6 中提供了一个构造函数 `Promise`, 也可以被称为一个类，需要通过 `new` 的方式来进行调用，生成一个实例对象。</span><br><span class="line"></span><br><span class="line">构造函数 Promise 接受一个回调函数作为参数，被称为 `executor`。该回调函数(executor) 会立即被执行，**同步**的表现方式。</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line"> const executor = function() &#123;</span><br><span class="line">     console.log(&#x27;executor函数会被立即执行&#x27;)</span><br><span class="line"> &#125;</span><br><span class="line"> const promise = new Promise(executor) // 接受一个回调函数，立即执行，同步表现形式</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><code>executor</code> 函数也接受两个回调函数作为参数，分别取名是：<code>resolve</code> 和 <code>reject</code>。这两个回调函数是内部实现的，对于<strong>开发者</strong>而言只需要调用即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> executor = <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;executor函数会被立即执行&#x27;</span>)</span><br><span class="line">     <span class="comment">// 成功了调用resolve</span></span><br><span class="line">     <span class="title function_">resolve</span>()</span><br><span class="line">     <span class="comment">// 失败了调用reject</span></span><br><span class="line">     <span class="title function_">reject</span>()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(executor)</span><br></pre></td></tr></table></figure><p>一般简写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> promsie = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;executor函数会被立即执行&#x27;</span>)</span><br><span class="line">     <span class="comment">// 成功了调用resolve</span></span><br><span class="line">     <span class="title function_">resolve</span>()</span><br><span class="line">     <span class="comment">// 失败了调用reject</span></span><br><span class="line">     <span class="title function_">reject</span>()</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h3 id="模拟promise源码的实现"><a href="#模拟promise源码的实现" class="headerlink" title="模拟promise源码的实现"></a>模拟promise源码的实现</h3><p>上面使用大量的回调函数作为参数，可能会看晕，那么使用class来模拟promise的源码，加深一下印象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> resolve = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">     <span class="keyword">const</span> reject = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="title function_">executor</span>(resolve, reject); <span class="comment">// 调用executor函数，传递两个内部函数作为参数</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">       <span class="comment">// 如果 executor 不是回调函数，报错</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Promise resolver #&lt;<span class="subst">$&#123;<span class="keyword">typeof</span> executor&#125;</span>&gt; is not a function`</span>)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重要法则"><a href="#重要法则" class="headerlink" title="重要法则"></a>重要法则</h3><h4 id="resolve——executor函数接受的第一个参数"><a href="#resolve——executor函数接受的第一个参数" class="headerlink" title="resolve——executor函数接受的第一个参数"></a>resolve——<code>executor</code>函数接受的第一个参数</h4><p>作用：将 <code>Promise</code>对象的状态从 <code>等待(pending)</code>变为 <code>成功(fulfilled)</code>。</p><p><strong>resolve接受一个参数，供调用then方法的时候使用。</strong></p><p>参数分为三种：</p><ol><li>参数是一个普通的值或对象（就是不包含下面的两种情况）</li><li>参数是promise</li><li>参数是thenable对象</li></ol><h5 id="情况一：普通值"><a href="#情况一：普通值" class="headerlink" title="情况一：普通值"></a>情况一：普通值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1、数字</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">resolve</span>(<span class="number">231</span>)</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 231</span></span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 2、字符串</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">resolve</span>(<span class="string">&#x27;copyer&#x27;</span>)</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// copyer</span></span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 3、对象（thenable对象除外）</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">resolve</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;copyer&quot;</span> &#125;);</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// &#123;name: &#x27;copyer&#x27;&#125;</span></span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 4、boolean</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">resolve</span>(<span class="literal">false</span>);</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// false</span></span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 5、undefined</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">resolve</span>(<span class="literal">undefined</span>);</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// undefined</span></span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 6、null</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">resolve</span>(<span class="literal">null</span>);</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// null</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>不难发现，针对普通值，resolve传递什么，then就接受什么。</p><h5 id="情况二：-promise"><a href="#情况二：-promise" class="headerlink" title="情况二： promise"></a>情况二： promise</h5><p>当 <code>(外promise)</code>的resolve的参数为<strong>promise对象(<code>内promise</code>)</strong> 的时候，那么 <code>外promise</code>的状态是由 <code>内promise</code>所决定的。</p><p>这里可以先使用<strong>then方法</strong>来操作下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 外promise</span></span><br><span class="line"> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">resolve</span>(p);</span><br><span class="line"> &#125;).<span class="title function_">then</span>(</span><br><span class="line">   <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功回调:&quot;</span>, res); </span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;失败回调:&quot;</span>, err);</span><br><span class="line">   &#125;</span><br><span class="line"> );</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 内promise</span></span><br><span class="line"> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);  <span class="comment">// 成功回调: success</span></span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">reject</span>(<span class="string">&quot;failure&quot;</span>);  <span class="comment">// 失败回调: failure</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><ul><li>当 <code>内promise</code> 调用了<strong>resolve</strong>方法，<code>外promise</code>的状态变为 <strong>fulfilled</strong> ，成功回调。</li><li>当 <code>内promise</code> 调用了<strong>reject</strong>方法，<code>外promise</code>的状态变为 <strong>rejected</strong> , 失败回调。</li></ul><h5 id="情况三：thenable方法"><a href="#情况三：thenable方法" class="headerlink" title="情况三：thenable方法"></a>情况三：thenable方法</h5><p>当传递的一个对象，对象的属性包含then方法，那么就会执行对象中then的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;thenable的方法会被执行&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(thenable); <span class="comment">// 会执行对象中的then方法</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功回调&quot;</span>, res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="reject——executor函数的第二个参数"><a href="#reject——executor函数的第二个参数" class="headerlink" title="reject——executor函数的第二个参数"></a>reject——<code>executor</code>函数的第二个参数</h4><p>作用：将 <code>Promise</code>对象的状态从 <code>等待(pending)</code>变为 <code>成功(rejected)</code>。</p><p>reject是一个表示失败的回调函数，接受<strong>一个任意类型</strong>的参数，在<strong>then的第二个回调函数</strong>中或则<strong>catch的回调函数</strong>中，拿到失败的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一： catch的回调函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;reject不合格的原因&quot;</span>);  <span class="comment">// 1、传递一个不合格的原因</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;   </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// reject 不合格的原因</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二： then的第二个回调函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;reject不合格的原因&quot;</span>);  <span class="comment">// 1、传递一个不合格的原因</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err) <span class="comment">// reject不合格原因</span></span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>相对于 <code>resolve</code>接受的不同类型的参数，表现出不同的形式; <code>reject</code>就相当的简单一点，reject传递过去什么，接受到的值就是什么（没有这么多的花里胡哨）。</p><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>then是promise对象上的一个方法（准确的来说，是在promise的原型 <strong>Promise.prototype.then</strong> ），供实例调用的。下面具体详解then的具体使用。</p><h5 id="接受两个参数"><a href="#接受两个参数" class="headerlink" title="接受两个参数"></a>接受两个参数</h5><p>在上面的 <code>resolve</code>，<code>reject</code>方法中，也提及到了 <code>then</code> 的大致使用，接受两个参数：</p><ul><li>参数一：回调函数，接受resolve的成功回调传递的值</li><li>参数二：回调函数，接受reject的失败回调传递的值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;成功的值&quot;</span>); <span class="comment">// 情况一</span></span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;失败的值&quot;</span>);  <span class="comment">// 情况二</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 情况一： 成功的值</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// 情况二： 失败的值</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>聊完了then的参数，接下来就来聊一聊then的其他特殊情况吧。</p><h5 id="then的多次调用"><a href="#then的多次调用" class="headerlink" title="then的多次调用"></a>then的多次调用</h5><p>这里的多次调用，并不是指的是链式调用（<strong>不同promise</strong>的实例），而是针对<strong>同一promise</strong>实例的then方法多次调用。</p><p>当执行resolve方法时，状态变为了 <strong>fulfilled</strong> ，then方法中的回调函数都会执行。（内部实现，就是then中的回调函数，存放在数组中，当状态变为fulfilled时，遍历数组，依次执行函数。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;copyer&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);  <span class="comment">// copyer</span></span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// copyer</span></span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// copyer</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="then的返回值"><a href="#then的返回值" class="headerlink" title="then的返回值"></a>then的返回值</h5><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;copyer&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// copyer</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在链式调用的时候，第二个then的 <code>res</code>为什么是 <code>undefined</code>?</p><p>先搞清楚一件事：</p><blockquote><p>为什么可以链式调用？<br><code>then</code>是promise原型上的方法，promise的实例可以调用。<br>当第二次继续调用then方法的时候，说明也是调用的promise的then方法，那就说明了两种情况：</p><ol><li>then的回调函数中返回了 <code>this</code>，promise的实例对象，可以调用then方法</li><li>then的回调函数返回了一个新的Promise实例，也是可以调用then方法的</li></ol><p>promise内部采用的是： <strong>第二种</strong> 。因为第一种是没有意义的，针对同一个promise，后面拿取的结果跟第一次拿取的结果是一样的。<br><strong>结论一：then方法的回调函数，返回一个promise</strong><br><strong>结论二：then方法的链式调用，是针对不同的promise（即每次都是一个新的promise）</strong></p></blockquote><p>知道了promise的链式调用的原理之后，就来看看返回值的类型吧。</p><p>then的返回值也是三种情况（跟 resolve 的三种情况是一样的）：</p><ul><li>普通的值（除了下面的两种情况）</li><li>promise</li><li>thenable</li></ul><h5 id="情况一：-普通的值"><a href="#情况一：-普通的值" class="headerlink" title="情况一： 普通的值"></a><strong>情况一： 普通的值</strong></h5><p>该值会被作为resolve的参数，作为下个promise的返回值。<code>Promise.resolve(返回值)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通的值</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;copyer&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// copyer</span></span><br><span class="line">  <span class="comment">// 函数的默认返回值： undefined ====&gt; 被内部转化为 Promise.resolve(undefined)</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// undefined</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;copyer&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// copyer</span></span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">&#x27;james&#x27;</span>&#125; <span class="comment">// 被内部转化为 Promise.resolve(&#123;name: &#x27;james&#x27;&#125;)</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// &#123;name: &#x27;james&#x27;&#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="情况二：promise"><a href="#情况二：promise" class="headerlink" title="情况二：promise"></a><strong>情况二：promise</strong></h5><p>如果then方法是一个普通的值，会被转化成promise。如果返回值，本身就是promise，那就不需要转化了，直接根据返回的promise状态执行对应的成功回调还是失败回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功回调</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;copyer&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// copyer</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;返回值的new_promise_success&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 返回值的new_promise_success</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败回调</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&quot;copyer&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// copyer</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;返回值的new_promise_failure&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 这里不会执行，因为返回的promise状态为rejected</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err) <span class="comment">// 返回值的new_promise_failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="情况三：thenable对象"><a href="#情况三：thenable对象" class="headerlink" title="情况三：thenable对象"></a><strong>情况三：thenable对象</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行thenable对象中的then方法&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;copyer&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// copyer</span></span><br><span class="line">  <span class="keyword">return</span> thenable;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 这里不会执行，会执行thenable对象的then方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>catch是promise对象上的一个方法（准确的来说，是在promise的原型 <strong>Promise.prototype.catch</strong> ），供实例调用的。用于拿取<strong>失败</strong>的信息。</p><p>简单使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&quot;32132&quot;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// 32132</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一般情况下，reject传递什么，catch就接受什么；但是如果reject的参数是一个promise的话，就影响catch的捕获异常。</p><h5 id="catch的捕获时机"><a href="#catch的捕获时机" class="headerlink" title="catch的捕获时机"></a>catch的捕获时机</h5><p>两个promise片段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// params_promise</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;2321&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main_promise</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(p);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err); <span class="comment">// 视情况而定</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果 <code>main_promise</code> 是 rejected 状态, <code>params_promise</code>是 fulfilled 状态，那么 catch 捕获的是 <code>main_promsie</code>的异常信息。</li><li>如果 <code>main_promise</code> 是 fulfilled 状态, <code>params_promise</code>是 rejected 状态，那么 catch 捕获的是 <code>params_promsie</code>的异常信息。</li><li>如果 <code>main_promise</code> 是 rejected 状态, <code>params_promise</code>是 rejected 状态，那么 catch 捕获的是 <code>main_promsie</code>的异常信息。</li></ul><p>从而可以知道： <strong>catch的捕获规则是是 <code>由外向内</code>的（<code>就远原则</code>），在依次执行代码的时候，如果遇到异常，就直捕获停止，不会向下再去捕获。</strong></p><p>catch的返回值还是一个promise，又开启一个新的流程了。</p><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>finally是promise对象上的一个方法（准确的来说，是在promise的原型 <strong>Promise.prototype.finally</strong> ），供实例调用的。</p><p>finally 是ES9（ES2018）新增的一个特性：表示Promise对象无论变成fulfilled还是rejected状态，最终都会被执行。</p><p>finally 方法是不接收参数的。</p><p> <strong>无论promise的状态是成功还是失败，都会执行该方法</strong> 。返回值也是一个promise，可以链式调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(p);</span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">21321</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">231321321321</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>Promise.all</code>：适合多个异步任务并发执行但不允许其中任何一个任务失败</li><li><code>Promise.race</code> ：适合多个异步任务抢占式执行</li><li><code>Promise.allSettled</code> ：适合多个异步任务并发执行但允许某些任务失败</li></ul><h1 id="理解-Promise-的类方法（下篇）"><a href="#理解-Promise-的类方法（下篇）" class="headerlink" title="理解 Promise 的类方法（下篇）"></a>理解 Promise 的类方法（下篇）</h1><p>在中篇中，学习了 promise 的then、catch、finally方法，它们都是放在原型上的，供实例对象使用的。接下来，了解的几个方法都是Promise的类方法。</p><h3 id="3-1、resolve"><a href="#3-1、resolve" class="headerlink" title="3.1、resolve"></a>3.1、resolve</h3><p>类方法resolve方法其实跟executor方法中的resolve方法是一致的，并且情况都是等价的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;copyer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;copyer&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>参数也分为三种情况：</p><ol><li>普通的值</li><li>promise</li><li>thenable对象</li></ol><p>上面提及到了，就不讲述了。</p><h3 id="3-2、reject"><a href="#3-2、reject" class="headerlink" title="3.2、reject"></a>3.2、reject</h3><p>reject方法，会将Promise对象的状态设置为rejected状态。</p><p>Promise.reject的用法相当于 new Promise，然后调用reject</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;copyer&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;copyer&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Promise.reject传入的参数无论时候什么类型，都会直接作为reject的参数传递到catch方法中。</p><h3 id="3-3、all"><a href="#3-3、all" class="headerlink" title="3.3、all"></a>3.3、all</h3><p>将多个Promise包裹成一个新的Promise，新的Promise的状态由包裹的Promise的状态共同决定。</p><ul><li>当所有的Promise的状态变为fulfilled时，新的Promise的状态为fulfilled，并且会将所有Promise的返回值组成一个数组。</li><li>当有一个Promise的状态为reject时，新的Promise的状态为reject，并且会将第一个reject的返回值作为参数。</li></ul><p> <strong>参数接受一个数组</strong> 。</p><p><strong>正常情况</strong>下的使用：promise组成一个数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;, <span class="number">20</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">30</span>);</span><br><span class="line">  &#125;, <span class="number">30</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p1、p2、p3组成一个数组</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// [10,20,30]</span></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p> <strong>少数情况一</strong> ：数组中包含数字，字符串等等其他类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="number">1</span>, <span class="string">&quot;copyer&quot;</span>, p1]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// [1, &#x27;copyer&#x27;, 10]</span></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当all方法执行是，会遍历里面的数组，检查里面的item是不是promise对象，如果不是，就会转化成promise，比如</p><ul><li><code>1</code> 会被转化成 <code>Promise.resolve(1)</code></li><li><code>copyer</code> 会被转化成 <code>Promise.resolve(&#39;copyer&#39;)</code></li></ul><p>当每项都成为 promise对象之后，再来确定新的 promise 的状态。</p><p> <strong>少数情况二</strong> ：传递了一个thenable对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">321</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="number">1</span>, thenable, p1]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>会直接执行 thenable 对象中的then方法，不会执行promise中的then方法。</p><blockquote><p>解释说明：正常情况是在开发中常见的，少数情况是在开发中基本上不可见的</p></blockquote><h3 id="3-4、allSettled"><a href="#3-4、allSettled" class="headerlink" title="3.4、allSettled"></a>3.4、allSettled</h3><p>all方法有一个缺陷：当其中的一个Promise变成reject状态时，新Promise的状态也就变成了reject状态。</p><ul><li>那对对于一些已经resolved的结果，也是拿不到的。</li></ul><p>在ES11（ES2020）中，添加了一个新的API来解决此类问题，用法跟all基本上是一样的。</p><ul><li>该方法会在所有的Promise都有结果（settled），无论是fulfilled，还是reject时，才会有最终的状态，返回一个新的Promise。</li><li>并且这个Promise的结果一定是fulfilled的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;, <span class="number">20</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="number">30</span>);</span><br><span class="line">  &#125;, <span class="number">30</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res); </span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>返回的格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="built_in">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, value: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="built_in">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>, value: <span class="number">20</span> &#125;, // 成功时value</span><br><span class="line">  &#123; <span class="built_in">status</span>: <span class="string">&#x27;rejected&#x27;</span>, reason: <span class="number">30</span> &#125;  // 失败是reason</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>status</code>: 表示其中Promise的状态</p><p><code>value</code>: 成功的返回值</p><p><code>reason</code>: 失败的返回值</p><h3 id="3-5、race"><a href="#3-5、race" class="headerlink" title="3.5、race"></a>3.5、race</h3><p>如果有一个Promise有了结果，我们就希望决定最终新Promise的状态，那么可以使用race方法：</p><ul><li>race是竞技、竞赛的意思，表示多个Promise相互竞争，谁先有结果，那么就使用谁的结果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;, <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;, <span class="number">20</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">30</span>);</span><br><span class="line">  &#125;, <span class="number">30</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);  <span class="comment">// 10</span></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="3-6、any"><a href="#3-6、any" class="headerlink" title="3.6、any"></a>3.6、any</h3><p>any方法是ES12中新增的方法，和all方法基本上相反。(还是实验性的语法，暂时没有被所有浏览器支持)。</p><p><code>MDN</code>对Promise.any的解释：</p><p><code>Promise.any()</code> 接收一个 <code>Promise</code>可迭代对象，只要其中的一个 <code>promise</code> 成功，就返回那个已经成功的 <code>promise</code> 。如果可迭代对象中没有一个 <code>promise</code> 成功（即所有的 <code>promises</code> 都失败&#x2F;拒绝），就返回一个失败的 <code>promise </code>和 <code>AggregateError</code>类型的实例</p><p>作者：copyer_xyf<br>链接：<a href="https://juejin.cn/post/7115732604057288734">https://juejin.cn/post/7115732604057288734</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7115732604057288734&quot;&gt;掌握 Promise，三步即可&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;意义&quot;&gt;&lt;a href=&quot;#意义&quot; class=&quot;headerlink&quot; title=&quot;意义&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="https://superq314.github.io/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://superq314.github.io/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2022-07-14T10:29:26.716Z</published>
    <updated>2022-07-18T15:08:08.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js的深浅拷贝"><a href="#js的深浅拷贝" class="headerlink" title="js的深浅拷贝"></a>js的深浅拷贝</h2><p>JavaScript的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础版的。所以在写这条之前我拜读了收藏夹里各路大佬写的博文。具体可以看下面我贴的链接，这里只做简单的总结。</p><ul><li>浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li><li>深拷贝：将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</li></ul><p><strong>浅拷贝的实现方式：</strong></p><ul><li>Object.assign()方法：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</li><li>Array.prototype.slice()：slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</li><li>拓展运算符…：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  name: &quot;Jake&quot;,</span><br><span class="line">  flag: &#123;</span><br><span class="line">    title: &quot;better day by day&quot;,</span><br><span class="line">    time: **&quot;2020-05-31&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = &#123;...a&#125;;</span><br></pre></td></tr></table></figure><p><strong>深拷贝的实现方式：</strong></p><ul><li>乞丐版：JSON.parse(JSON.stringify(object))，缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）</li><li>基础版（面试够用）：浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function cloneDeep(target, map = new WeakMap()) &#123;</span><br><span class="line">  if(typeOf taret === &#x27;object&#x27;)&#123;</span><br><span class="line">    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">    if(map.get(target)) &#123;</span><br><span class="line">      return target;</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line">    for(const key in target)&#123;</span><br><span class="line">      cloneTarget[key] = cloneDeep(target[key], map);</span><br><span class="line">    &#125;</span><br><span class="line">    return cloneTarget</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>终极版：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">const mapTag = &#x27;[object Map]&#x27;;</span><br><span class="line">const setTag = &#x27;[object Set]&#x27;;</span><br><span class="line">const arrayTag = &#x27;[object Array]&#x27;;</span><br><span class="line">const objectTag = &#x27;[object Object]&#x27;;</span><br><span class="line">const argsTag = &#x27;[object Arguments]&#x27;;</span><br><span class="line"></span><br><span class="line">const boolTag = &#x27;[object Boolean]&#x27;;</span><br><span class="line">const dateTag = &#x27;[object Date]&#x27;;</span><br><span class="line">const numberTag = &#x27;[object Number]&#x27;;</span><br><span class="line">const stringTag = &#x27;[object String]&#x27;;</span><br><span class="line">const symbolTag = &#x27;[object Symbol]&#x27;;</span><br><span class="line">const errorTag = &#x27;[object Error]&#x27;;</span><br><span class="line">const regexpTag = &#x27;[object RegExp]&#x27;;</span><br><span class="line">const funcTag = &#x27;[object Function]&#x27;;</span><br><span class="line"></span><br><span class="line">const deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class="line"></span><br><span class="line">function forEach(array, iteratee) &#123;</span><br><span class="line">  let index = -1;</span><br><span class="line">  const length = array.length;</span><br><span class="line">  while (++index &lt; length) &#123;</span><br><span class="line">    iteratee(array[index], index);</span><br><span class="line">  &#125;</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isObject(target) &#123;</span><br><span class="line">  const type = typeof target;</span><br><span class="line">  return target !== null &amp;&amp; (type === &#x27;object&#x27; || type === &#x27;function&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getType(target) &#123;</span><br><span class="line">  return Object.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getInit(target) &#123;</span><br><span class="line">  const Ctor = target.constructor;</span><br><span class="line">  return new Ctor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneSymbol(targe) &#123;</span><br><span class="line">  return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneReg(targe) &#123;</span><br><span class="line">  const reFlags = /\w$/;</span><br><span class="line">  const result = new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class="line">  result.lastIndex = targe.lastIndex;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneFunction(func) &#123;</span><br><span class="line">  const bodyReg = /(?&lt;=&#123;)(.|\n)+(?=&#125;)/m;</span><br><span class="line">  const paramReg = /(?&lt;=\().+(?=\)\s+&#123;)/;</span><br><span class="line">  const funcString = func.toString();</span><br><span class="line">  if (func.prototype) &#123;</span><br><span class="line">    const param = paramReg.exec(funcString);</span><br><span class="line">    const body = bodyReg.exec(funcString);</span><br><span class="line">    if (body) &#123;</span><br><span class="line">      if (param) &#123;</span><br><span class="line">        const paramArr = param[0].split(&#x27;,&#x27;);</span><br><span class="line">        return new Function(...paramArr, body[0]);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return new Function(body[0]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return eval(funcString);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneOtherType(targe, type) &#123;</span><br><span class="line">  const Ctor = targe.constructor;</span><br><span class="line">  switch (type) &#123;</span><br><span class="line">    case boolTag:</span><br><span class="line">    case numberTag:</span><br><span class="line">    case stringTag:</span><br><span class="line">    case errorTag:</span><br><span class="line">    case dateTag:</span><br><span class="line">      return new Ctor(targe);</span><br><span class="line">    case regexpTag:</span><br><span class="line">      return cloneReg(targe);</span><br><span class="line">    case symbolTag:</span><br><span class="line">      return cloneSymbol(targe);</span><br><span class="line">    case funcTag:</span><br><span class="line">      return cloneFunction(targe);</span><br><span class="line">    default:</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">function clone(target, map = new WeakMap()) &#123;</span><br><span class="line">  // 克隆原始类型</span><br><span class="line">  if (!isObject(target)) &#123;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 初始化</span><br><span class="line">  const type = getType(target);</span><br><span class="line">  let cloneTarget;</span><br><span class="line">  if (deepTag.includes(type)) &#123;</span><br><span class="line">    cloneTarget = getInit(target, type);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return cloneOtherType(target, type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 防止循环引用</span><br><span class="line">  if (map.get(target)) &#123;</span><br><span class="line">    return map.get(target);</span><br><span class="line">  &#125;</span><br><span class="line">  map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">  // 克隆set</span><br><span class="line">  if (type === setTag) &#123;</span><br><span class="line">    target.forEach(value =&gt; &#123;</span><br><span class="line">      cloneTarget.add(clone(value, map));</span><br><span class="line">    &#125;);</span><br><span class="line">    return cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 克隆map</span><br><span class="line">  if (type === mapTag) &#123;</span><br><span class="line">    target.forEach((value, key) =&gt; &#123;</span><br><span class="line">      cloneTarget.set(key, clone(value, map));</span><br><span class="line">    &#125;);</span><br><span class="line">    return cloneTarget;</span><br><span class="line">  &#125;</span><br><span class="line">  // 克隆对象和数组</span><br><span class="line">  const keys = type === arrayTag ? undefined : Object.keys(target);</span><br><span class="line">  forEach(keys || target, (value, key) =&gt; &#123;</span><br><span class="line">    if (keys) &#123;</span><br><span class="line">      key = value;</span><br><span class="line">    &#125;</span><br><span class="line">    cloneTarget[key] = clone(target[key], map);</span><br><span class="line">  &#125;);</span><br><span class="line">  return cloneTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  clone</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s/vXbFsG59L1Ba0DMcZeU2Bg" title="https://mp.weixin.qq.com/s/vXbFsG59L1Ba0DMcZeU2Bg">如何写出一个惊艳面试官的深拷贝</a></p><p><a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000016672263" title="https://segmentfault.com/a/1190000016672263">深拷贝的终极探索（**99%**的人都不知道）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;js的深浅拷贝&quot;&gt;&lt;a href=&quot;#js的深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;js的深浅拷贝&quot;&gt;&lt;/a&gt;js的深浅拷贝&lt;/h2&gt;&lt;p&gt;JavaScript的深浅拷贝一直是个难点，如果现在面试官让我写一个深拷贝，我可能也只是能写出个基础</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS异步编程</title>
    <link href="https://superq314.github.io/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://superq314.github.io/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</id>
    <published>2022-07-14T10:24:58.940Z</published>
    <updated>2022-07-19T09:10:51.618Z</updated>
    
    <content type="html"><![CDATA[<p>异步API</p><h2 id="简单对比Callback、Promise、Generator、Async几个异步API的优劣"><a href="#简单对比Callback、Promise、Generator、Async几个异步API的优劣" class="headerlink" title="简单对比Callback、Promise、Generator、Async几个异步API的优劣"></a>简单对比Callback、Promise、Generator、Async几个异步API的优劣</h2><p>在 JavaScript 中利用<a href="https://juejin.cn/post/6844903843197616136#heading-3" title="https://juejin.cn/post/6844903843197616136#heading-3">事件循环机制</a>（Event Loop）可以在单线程中实现非阻塞式、异步的操作。例如</p><ul><li>Node.js 中的 Callback、<a href="https://link.juejin.cn/?target=http://nodejs.cn/api/events.html%23events_class_eventemitter" title="http://nodejs.cn/api/events.html#events_class_eventemitter">EventEmitter</a>、<a href="https://link.juejin.cn/?target=http://nodejs.cn/api/stream.html" title="http://nodejs.cn/api/stream.html">Stream</a></li><li>ES6 中的 <a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/promise" title="https://es6.ruanyifeng.com/#docs/promise">Promise</a>、<a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/generator-async" title="https://es6.ruanyifeng.com/#docs/generator-async">Generator</a></li><li>ES2017 中的 <a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/async" title="https://es6.ruanyifeng.com/#docs/async">Async</a></li><li>三方库 RxJS、<a href="https://link.juejin.cn/?target=https://github.com/kriskowal/q" title="https://github.com/kriskowal/q">Q</a> 、<a href="https://link.juejin.cn/?target=https://github.com/tj/co" title="https://github.com/tj/co">Co、</a><a href="https://link.juejin.cn/?target=https://github.com/petkaantonov/bluebird" title="https://github.com/petkaantonov/bluebird">Bluebird</a></li></ul><h3 id="Callback-回调-函数"><a href="#Callback-回调-函数" class="headerlink" title="Callback(回调)函数"></a><strong>Callback(回调)函数</strong></h3><p>Callback（回调函数）是在 Web 前端开发中经常会使用的编程方式。它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。这里举一个常用的定时器示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">IObj</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">deferExec</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">deferExecAnonymous</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">console</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">obj</span>: <span class="title class_">IObj</span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deferExecBind</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用箭头函数可达到一样的效果</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">console</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deferExec</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">console</span>, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">console</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">deferExecBind</span>(); <span class="comment">// hello</span></span><br><span class="line">obj.<span class="title function_">deferExec</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>回调函数经常会因为调用环境的变化而导致 <code>this</code> 的指向性变化。除此之外，使用回调函数来处理多个继发的异步任务时容易导致回调地狱（Callback Hell）:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(fileA, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileB, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileC, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">      fs.<span class="title function_">readFile</span>(fileD, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">        <span class="comment">// 假设在业务中 fileD 的读写依次依赖 fileA、fileB 和 fileC</span></span><br><span class="line">        <span class="comment">// 或者经常也可以在业务中看到多个 HTTP 请求的操作有前后依赖（继发 HTTP 请求）</span></span><br><span class="line">        <span class="comment">// 这些异步任务之间纵向嵌套强耦合，无法进行横向复用</span></span><br><span class="line">        <span class="comment">// 如果某个异步发生变化，那它的所有上层或下层回调可能都需要跟着变化（比如 fileA 和 fileB 的依赖关系倒置）</span></span><br><span class="line">        <span class="comment">// 因此称这种现象为 回调地狱</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>回调函数不能通过 <code>return</code> 返回数据，比如我们希望调用带有回调参数的函数并返回异步执行的结果时，只能通过再次回调的方式进行参数传递：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希望延迟 3s 后执行并拿到结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAsyncResult</span>(<span class="params">result: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result * <span class="number">3</span>;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽管这是常规的编程思维方式</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">getAsyncResult</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 但是打印 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAsyncResultWithCb</span>(<span class="params">result: <span class="built_in">number</span>, cb: (result: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">cb</span>(result * <span class="number">3</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过回调的形式获取结果</span></span><br><span class="line"><span class="title function_">getAsyncResultWithCb</span>(<span class="number">3000</span>, <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;result: &#x27;</span>, result); <span class="comment">// 9000</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于 JavaScript 中标准的异步 API 可能无法通过在外部进行 <code>try...catch...</code> 的方式进行错误捕获：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 下述是异常代码</span></span><br><span class="line">    <span class="comment">// 你可以在回调函数的内部进行 try...catch...</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">b</span>.<span class="property">c</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="comment">// 这里不会执行</span></span><br><span class="line">  <span class="comment">// 进程会被终止</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例讲述的都是 JavaScript 中标准的异步 API ，如果使用一些三方的异步 API 并且提供了回调能力时，这些 API 可能是非受信的，在真正使用的时候会因为 <strong>执行反转</strong> （回调函数的执行权在三方库中）导致以下一些问题：</p><ul><li>使用者的回调函数设计没有进行错误捕获，而恰恰三方库进行了错误捕获却没有抛出错误处理信息，此时使用者很难感知到自己设计的回调函数是否有错误</li><li>使用者难以感知到三方库的回调时机和回调次数，这个回调函数执行的权利控制在三方库手中</li><li>使用者无法更改三方库提供的回调参数，回调参数可能无法满足使用者的诉求</li></ul><p>举个简单的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILib</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">params</span>: T;</span><br><span class="line">  <span class="title function_">emit</span>(<span class="attr">params</span>: T): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">on</span>(<span class="attr">callback</span>: <span class="function">(<span class="params">params: T</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下是一个三方库，并发布成了npm 包</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">lib</span>: <span class="title class_">ILib</span>&lt;<span class="built_in">string</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">params</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">params</span> = params;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">on</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// callback 回调执行权在 lib 上</span></span><br><span class="line">      <span class="comment">// lib 库可以决定回调执行多次</span></span><br><span class="line">      <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      <span class="comment">// lib 库甚至可以决定回调延迟执行</span></span><br><span class="line">      <span class="comment">// 异步执行回调函数</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">params</span>);</span><br><span class="line">      &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 假设 lib 库的捕获没有抛出任何异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开发者引入 lib 库开始使用</span></span><br><span class="line">lib.<span class="title function_">emit</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">lib.<span class="title function_">on</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用者希望 on 里的回调只执行一次</span></span><br><span class="line"><span class="comment">// 这里的回调函数的执行时机是由三方库 lib 决定</span></span><br><span class="line">  <span class="comment">// 实际上打印四次，并且其中一次是异步执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">lib.<span class="title function_">on</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 下述是异常代码</span></span><br><span class="line">  <span class="comment">// 但是执行下述代码不会抛出任何异常信息</span></span><br><span class="line">  <span class="comment">// 开发者无法感知自己的代码设计错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">a</span>.<span class="property">b</span>.<span class="property">c</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise及手写实现方式"><a href="#Promise及手写实现方式" class="headerlink" title="Promise及手写实现方式"></a><strong>Promise及手写实现方式</strong></h3><blockquote><p>相关资料：<br><a href="#heading-69" title="https://juejin.cn/post/6844904064614924302#heading-69">「硬核JS」深入了解异步解决方案</a><br><a href="https://link.juejin.cn/?target=https://www.ituring.com.cn/article/66566%23" title="https://www.ituring.com.cn/article/66566#">「翻译」Promises&#x2F;A+规范</a></p></blockquote><h3 id="Iterator是什么，有什么作用？"><a href="#Iterator是什么，有什么作用？" class="headerlink" title="Iterator是什么，有什么作用？"></a><strong>Iterator是什么，有什么作用？</strong></h3><p><strong>Iterator</strong>是理解第61条的先决知识，也许是我IQ不够<strong>Iterator</strong>和Generator看了很多遍还是一知半解，即使当时理解了，过一阵又忘得一干二净。。。</p><p>Iterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p><strong>Iterator语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  [Symbol.iterator]:function()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[Symbol.iterator]属性名是固定的写法，只要拥有了该属性的对象，就能够用迭代器的方式进行遍历。</p><p>迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 next 方法，改变指针的指向，让其指向下一条数据 每一次的 next 都会返回一个对象，该对象有两个属性</p><p>· value 代表想要获取的数据</p><p>· done 布尔值，false表示当前指针指向的数据有值，true表示遍历已经结束</p><p><strong>Iterator 的作用有三个：</strong></p><ol><li>为各种数据结构，提供一个统一的、简便的访问接口；</li><li>使得数据结构的成员能够按某种次序排列；</li><li>ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。</li></ol><p><strong>遍历过程：</strong></p><ol><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li></ol><p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#123;num:1&#125;,2,3]</span><br><span class="line">let it = arr[Symbol.iterator]() // 获取数组中的迭代器</span><br><span class="line">console.log(it.next()) // &#123; value: Object &#123; num: 1 &#125;, done: false &#125;</span><br><span class="line">console.log(it.next()) // &#123; value: 2, done: false &#125;</span><br><span class="line">console.log(it.next()) // &#123; value: 3, done: false &#125;</span><br><span class="line">console.log(it.next()) // &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure><h3 id="Generator函数及其作用"><a href="#Generator函数及其作用" class="headerlink" title="Generator函数及其作用"></a><strong>Generator函数及其作用</strong></h3><p>Promise 解决了 Callback 的回调地狱问题，但也造成了代码冗余，如果一些异步任务不支持 Promise 语法，就需要进行一层 Promise 封装。Generator 将 JavaScript 的异步编程带入了一个全新的阶段，它使得异步代码的设计和执行看起来和同步代码一致。Generator 使用的简单示例如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Generator 函数里执行的异步代码看起来和同步代码一致</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gen</span>(<span class="params">result: <span class="built_in">number</span></span>): <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// 异步代码</span></span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(result)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 异步代码</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult) <span class="comment">// 6</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">gen</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行 Generator 函数</span></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function">(<span class="params">res: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 将 firstPromise 的返回值传递给第一个 yield 表单式对应的 firstResult</span></span><br><span class="line">  <span class="keyword">return</span> g.<span class="title function_">next</span>(res).<span class="property">value</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 将 nextPromise 的返回值传递给第二个 yield 表单式对应的 nextResult</span></span><br><span class="line">  <span class="keyword">return</span> g.<span class="title function_">next</span>(res).<span class="property">value</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过上述代码，可以看出 Generator 相对于 Promise 具有以下优势：</p><ul><li>丰富了状态类型，Generator 通过 <code>next</code> 可以产生不同的状态信息，也可以通过 <code>return</code> 结束函数的执行状态，相对于 Promise 的 <code>resolve</code> 不可变状态更加丰富</li><li>Generator 函数内部的异步代码执行看起来和同步代码执行一致，非常利于代码的维护</li><li>Generator 函数内部的执行逻辑和相应的状态变化逻辑解耦，降低了代码的复杂度</li></ul><p><code>next</code> 可以不停的改变状态使得 <code>yield</code> 得以继续执行的代码可以变得非常有规律，例如从上述的<strong>手动执行 Generator 函数</strong>可以看出，完全可以将其封装成一个自动执行的执行器，具体如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gen</span> =  <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;, <span class="built_in">number</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(): <span class="title class_">Gen</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult) <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult) <span class="comment">// 6</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">nextPromise</span>(firstResult)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator 自动执行器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen: () =&gt; Gen</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">gen</span>()</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = g.<span class="title function_">next</span>(data)</span><br><span class="line">    <span class="keyword">if</span>(result.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 通过递归的方式处理相同的逻辑</span></span><br><span class="line">      <span class="title function_">next</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一次调用 next 主要用于启动 Generator 函数</span></span><br><span class="line">  <span class="comment">// 内部指针会从函数头部开始执行，直到遇到第一个 yield 表达式</span></span><br><span class="line">  <span class="comment">// 因此第一次 next 传递的参数没有任何含义（这里传递只是为了防止 TS 报错）</span></span><br><span class="line">  <span class="title function_">next</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>(gen)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：<a href="https://link.juejin.cn/?target=https://github.com/tj" title="https://github.com/tj">TJ Holowaychuk </a>设计了一个 Generator 自动执行器 <a href="https://link.juejin.cn/?target=https://github.com/tj/co" title="https://github.com/tj/co">Co</a>，使用 Co 的前提是 <code>yield</code>  命令后必须是 Promise 对象或者 Thunk 函数。Co 还可以支持并发的异步处理，具体可查看官方的<a href="https://link.juejin.cn/?target=https://github.com/tj/co%23arrays" title="https://github.com/tj/co#arrays"> API 文档</a>。</p></blockquote><p>需要注意的是 Generator 函数的返回值是一个 Iterator 遍历器对象，具体如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gen</span> = <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(): <span class="title class_">Gen</span> &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意使用 next 是继发执行，而这里是并发执行</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([...<span class="title function_">gen</span>()]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> <span class="title function_">gen</span>()) &#123;</span><br><span class="line">  promise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Generator 函数的错误处理相对复杂一些，极端情况下需要对执行和 Generator 函数进行双重错误捕获，具体如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 需要注意这里的reject 没有被捕获</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Gen</span> = <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(): <span class="title class_">Gen</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">nextPromise</span>(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Generator 函数错误捕获: &#x27;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="title function_">gen</span>();</span><br><span class="line">  g.<span class="title function_">next</span>();</span><br><span class="line">  <span class="comment">// 返回 Promise 后还需要通过 Promise.prototype.catch 进行错误捕获</span></span><br><span class="line">  g.<span class="title function_">next</span>();</span><br><span class="line">  <span class="comment">// Generator 函数错误捕获</span></span><br><span class="line">  g.<span class="keyword">throw</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">  <span class="comment">// 执行器错误捕获</span></span><br><span class="line">  g.<span class="keyword">throw</span>(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;执行错误捕获: &#x27;</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 <code>g.throw</code> 的时候还需要注意以下一些事项：</p><ul><li>如果 Generator 函数本身没有捕获错误，那么 Generator 函数内部抛出的错误可以在执行处进行错误捕获</li><li>如果 Generator 函数内部和执行处都没有进行错误捕获，则终止进程并抛出错误信息</li><li>如果没有执行过 <code>g.next</code>，则 <code>g.throw</code> 不会在 Gererator 函数中被捕获（因为执行指针没有启动 Generator 函数的执行），此时可以在执行处进行执行错误捕获</li></ul><h3 id="Async-x2F-await及其工作方式"><a href="#Async-x2F-await及其工作方式" class="headerlink" title="Async&#x2F;await及其工作方式"></a><strong>Async&#x2F;await及其工作方式</strong></h3><p><strong>async</strong>是异步的意思，而<strong>await</strong>是<strong>async wait</strong>的简写，即异步等待。</p><p>Async是Generator函数的语法糖，Async的特性如下：</p><ul><li>内置执行器：Generator函数需要设计手动执行器或者通用执行器（例如Co执行器）进行执行，Async语法则内置了自动执行器，设计代码时无须关心执行步骤</li><li><code>yield</code> 命令无约束：在 Generator 中使用 Co 执行器时 <code>yield</code> 后必须是 Promise 对象或者 Thunk 函数，而 Async 语法中的 <code>await</code> 后可以是 Promise 对象或者原始数据类型对象、数字、字符串、布尔值等（此时会对其进行 <code>Promise.resolve()</code> 包装处理）</li><li>返回 Promise： <code>async</code> 函数的返回值是 Promise 对象（返回原始数据类型会被 Promise 进行封装）， 因此还可以作为 <code>await</code>  的命令参数，相对于 Generator 返回 Iterator 遍历器更加简洁实用</li><li>async&#x2F;await有一个限制就是 <strong>必须在函数中使用</strong> ，因此我们将代码包进一个函数，并 <strong>在函数前加上async，这样我们便可以在函数中使用await关键字</strong> 。</li></ul><p>举个简单的示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">await</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 1s 后打印 2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult); </span><br><span class="line">  <span class="comment">// 等待 firstPromise 的状态发生变化后执行</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> <span class="title function_">nextPromise</span>(firstResult);</span><br><span class="line">  <span class="comment">// 2s 后打印 6</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult); </span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// 6</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过上述示例可以看出，<code>async</code> 函数的特性如下：</p><ul><li>调用 <code>async</code> 函数后返回的是一个 Promise 对象，通过 <code>then</code> 回调可以拿到 async 函数内部 <code>return</code> 语句的返回值</li><li>调用 <code>async</code> 函数后返回的 Promise 对象必须等待内部所有 <code>await</code> 对应的 Promise 执行完（这使得 <code>async</code> 函数可能是阻塞式执行）后才会发生状态变化，除非中途遇到了 <code>return</code> 语句</li><li><code>await</code> 命令后如果是 Promise 对象，则返回 Promise 对象处理后的结果，如果是原始数据类型，则直接返回原始数据类型</li></ul><p>上述代码是阻塞式执行，<code>nextPromise</code> 需要等待 <code>firstPromise</code> 执行完成后才能继续执行，如果希望两者能够并发执行，则可以进行下述设计：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">firstPromise</span>(<span class="number">1</span>), <span class="title function_">nextPromise</span>(<span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// [2,3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了使用 Promise 自带的并发执行 API，也可以通过让所有的 Promise 提前并发执行来处理：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstPromise&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">2</span>), <span class="number">10000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextPromise&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 执行 firstPromise</span></span><br><span class="line">  <span class="keyword">const</span> first = <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 和 firstPromise 同时执行 nextPromise</span></span><br><span class="line">  <span class="keyword">const</span> next = <span class="title function_">nextPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 等待 firstPromise 结果回来</span></span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">await</span> first;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult);</span><br><span class="line">  <span class="comment">// 等待 nextPromise 结果回来</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> next;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult);</span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// 3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Async 的错误处理相对于 Generator 会更加简单，具体示例如下所示：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Promise 决断错误</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> firstResult = <span class="keyword">await</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;firstResult: &#x27;</span>, firstResult);</span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> <span class="title function_">nextPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextResult: &#x27;</span>, nextResult);</span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err); <span class="comment">// err: 2</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>async</code> 函数内部抛出的错误，会导致函数返回的 Promise 对象变为 <code>rejected</code> 状态，从而可以通过 <code>catch</code> 捕获， 上述代码只是一个粗粒度的容错处理，如果希望 <code>firstPromise</code> 错误后可以继续执行 <code>nextPromise</code>，则可以通过 <code>try...catch...</code> 在 <code>async</code> 函数里进行局部错误捕获：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Promise 决断错误</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(result * <span class="number">2</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextPromise = (<span class="attr">result</span>: <span class="built_in">number</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(result * <span class="number">3</span>), <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">co</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">firstPromise</span>(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err); <span class="comment">// err: 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// nextPromise 继续执行</span></span><br><span class="line">  <span class="keyword">const</span> nextResult = <span class="keyword">await</span> <span class="title function_">nextPromise</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> nextResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res: &#x27;</span>, res); <span class="comment">// res: 3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;err: &#x27;</span>, err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>温馨提示：Callback 是 Node.js 中经常使用的编程方式，Node.js 中很多原生的 API 都是采用 Callback 的形式进行异步设计，早期的 Node.js 经常会有 Callback 和 Promise 混用的情况，并且在很长一段时间里都没有很好的支持 Async 语法。如果你对 Node.js 和它的替代品 Deno 感兴趣，可以观看 Ryan Dahl 在 TS Conf 2019 中的经典演讲 <a href="https://link.juejin.cn/?target=https://www.youtube.com/watch?v=1gIiZfSbEAE" title="https://www.youtube.com/watch?v=1gIiZfSbEAE">Deno is a New Way to JavaScript</a>。</p></blockquote><p>相比于<strong>Promise</strong>，<strong>async&#x2F;await</strong>能更好地处理 then 链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function takeLongTime(n) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; resolve(n + 200), n);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function step1(n) &#123;</span><br><span class="line">  console.log(step1 with $&#123;n&#125;);</span><br><span class="line">  return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function step2(n) &#123;</span><br><span class="line">  console.log(step2 with $&#123;n&#125;);</span><br><span class="line">  return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line">function step3(n) &#123;</span><br><span class="line">  console.log(step3 with $&#123;n&#125;);</span><br><span class="line">  return takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在分别用<strong>Promise</strong> 和<strong>async&#x2F;await</strong>来实现这三个步骤的处理。</p><p><strong>使用Promise</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function doIt() &#123;</span><br><span class="line">  console.time(&quot;doIt&quot;);</span><br><span class="line">  const time1 = 300;</span><br><span class="line">  step1(time1)</span><br><span class="line">    .then(time2 =&gt; step2(time2))</span><br><span class="line">    .then(time3 =&gt; step3(time3))</span><br><span class="line">    .then(result =&gt; &#123;</span><br><span class="line">      console.log(result is $&#123;result&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();// step1 with 300// step2 with 500// step3 with 700// result is 900</span><br></pre></td></tr></table></figure><p><strong>使用</strong>async&#x2F;await</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function doIt() &#123;</span><br><span class="line">  console.time(&quot;doIt&quot;);</span><br><span class="line">  const time1 = 300;</span><br><span class="line">  const time2 = await step1(time1);</span><br><span class="line">  const time3 = await step2(time2);</span><br><span class="line">  const result = await step3(time3);</span><br><span class="line">  console.log(result is $&#123;result&#125;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，优雅整洁，几乎跟同步代码一样。</p><p><strong>await</strong>关键字只能在async function中使用。在任何非async function的函数中使用await关键字都会抛出错误。await关键字在执行下一行代码之前等待右侧表达式(可能是一个Promise)返回。</p><p><strong>优缺点：</strong><br><strong>async&#x2F;await</strong>的优势在于处理 then 的调用链，能够更清晰准确的写出代码，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;异步API&lt;/p&gt;
&lt;h2 id=&quot;简单对比Callback、Promise、Generator、Async几个异步API的优劣&quot;&gt;&lt;a href=&quot;#简单对比Callback、Promise、Generator、Async几个异步API的优劣&quot; class=&quot;header</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>手写call、apply、bind函数</title>
    <link href="https://superq314.github.io/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%89%8B%E5%86%99call%E3%80%81apply%E3%80%81bind%E5%87%BD%E6%95%B0/"/>
    <id>https://superq314.github.io/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%89%8B%E5%86%99call%E3%80%81apply%E3%80%81bind%E5%87%BD%E6%95%B0/</id>
    <published>2022-07-14T10:22:59.068Z</published>
    <updated>2022-07-18T15:08:53.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手写call、apply及bind函数"><a href="#手写call、apply及bind函数" class="headerlink" title="手写call、apply及bind函数"></a>手写call、apply及bind函数</h2><h3 id="apply、call、bind-的异同"><a href="#apply、call、bind-的异同" class="headerlink" title="apply、call、bind 的异同"></a>apply、call、bind 的异同</h3><ol><li>三者都可以改变this的指向，第一个参数都是this，如果指向是null或者undefined则指向window</li><li>apply的参数是数组，call是列表，而bind可以多次传入</li><li>apply和call是改变this的指向之后直接运行函数，而bind则是返回绑定之后的函数</li></ol><p>三个函数的使用</p><ol><li>call()：参数一个一个传入，第一个实参是对象，实参传入个数可大于功能实现所需参数个数，返回函数运行结果。</li><li>apply()：参数为一个对象和一个数组，数组内的元素个数可大于功能实现所需参数个数，返回函数运行结果。</li><li>bind()：参数传入和call()一样，但bind()调用后会返回一个函数，需要一个新的变量来接收它返回的函数，再调用返回的新函数才能实现功能。用bind()进行显示绑定时，参数可以一次性传入，也可以分为两部分，第二部分传入返回的新函数。</li></ol><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p><code>call()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值和分别地提供的参数（参数的列表）。语法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.<span class="title function_">call</span>(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>注：</p><ul><li><code>thisArg</code> 指的是在 <code>fun</code> 函数中指定的 <code>this</code> 的值。如果指定了 null 或者 undefined 则内部 <code>this</code> 指向 window，同时值为原始值（数字，字符串，布尔值）的 <code>this</code> 会指向该原始值的自动包装对象。是一个可选项。</li><li>arg1, arg2, …指定的参数列表。也是可选项。</li><li>使用调用者提供的 <code>this</code> 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined。</li><li><code>call()</code> 允许为不同的对象分配和调用属于一个对象的函数&#x2F;方法。</li><li><code>call()</code> 提供新的 <code>this</code> 值给当前调用的函数&#x2F;方法。你可以使用 <code>call()</code> 来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。</li></ul><p><strong>call 函数的实现步骤</strong></p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call函数实现————运用隐式绑定原理</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window，避免报错</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取除对象以外的所有参数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将调用函数设为对象的方法—————隐式绑定</span></span><br><span class="line">  <span class="comment">// 进行优化</span></span><br><span class="line">  <span class="comment">// 创建独一无二的变量fn，避免与window原本带有的属性冲突</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;fn&#x27;</span>);  <span class="comment">// this指向调用myCall的函数</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;        <span class="comment">// 调用myCall的函数添加到对象context</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数</span></span><br><span class="line">  <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args); <span class="comment">// 隐式绑定，将参数一个一个按fn接收的类型传进调用fn,得到执行结果</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除fn，将实参对象恢复原样</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回执行结果 </span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><code>apply()</code> 方法与 <code>call()</code> 方法类似，唯一的区别是 <code>call()</code> 方法接受的是参数，<code>apply()</code> 方法接受的是数组。语法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.<span class="title function_">apply</span>(thisArg, [argsArray]);</span><br></pre></td></tr></table></figure><p><strong>apply 函数的实现步骤</strong></p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply 函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p><code>bind()</code> 方法创建一个新的函数（称为绑定函数），在调用时设置 <code>this</code> 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。语法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.<span class="title function_">bind</span>(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><p>注：参数 thisArg：当绑定函数被调用时，该参数会作为原函数运行时的 <code>this</code> 指向。当使用 <code>new</code> 操作符调用绑定函数时，该参数无效。参数：arg1，arg2，…表示当目标函数被调用时，预先添加到绑定函数的参数列表中的参数。</p><p><strong>bind 函数的实现步骤</strong></p><ol><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind 函数实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 等价于</span></span><br><span class="line">  <span class="comment">// var bindArge = Array.prototype.slice.call(arguments, 1);</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 引用另存为</span></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context, args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://juejin.cn/book/6844733763675488269/section/6844733763767762952" title="https://juejin.cn/book/6844733763675488269/section/6844733763767762952">《手写** call**、apply 及 bind 函数》</a></p><p><a href="https://link.juejin.cn/?target=https://github.com/mqyqingfeng/Blog/issues/11" title="https://github.com/mqyqingfeng/Blog/issues/11">《**JavaScript **深入之 call 和 apply 的模拟实现》</a></p><h2 id="手动实现-Array-prototype-map-方法"><a href="#手动实现-Array-prototype-map-方法" class="headerlink" title="手动实现 Array.prototype.map 方法"></a>手动实现 Array.prototype.map 方法</h2><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function map(arr, mapCallback) &#123;</span><br><span class="line">  // 首先，检查传递的参数是否正确。</span><br><span class="line">  if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== &#x27;function&#x27;) &#123;</span><br><span class="line">    return [];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class="line">    // 因为我们不想改变原始数组。</span><br><span class="line">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      result.push(mapCallback(arr[i], i, arr));</span><br><span class="line">      // 将 mapCallback 返回的结果 push 到 result 数组中</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手动实现-Array-prototype-filter-方法"><a href="#手动实现-Array-prototype-filter-方法" class="headerlink" title="手动实现 Array.prototype.filter 方法"></a>手动实现 Array.prototype.filter 方法</h2><p>**filter()**方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function filter(arr, filterCallback) &#123;</span><br><span class="line">  // 首先，检查传递的参数是否正确。</span><br><span class="line">  if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== &#x27;function&#x27;) &#123;</span><br><span class="line">    return [];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    // 每次调用此函数时，我们都会创建一个 result 数组</span><br><span class="line">    // 因为我们不想改变原始数组。</span><br><span class="line">    for (let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      // 检查 filterCallback 的返回值是否是真值</span><br><span class="line">      if (filterCallback(arr[i], i, arr)) &#123;</span><br><span class="line">        // 如果条件为真，则将数组元素 push 到 result 中</span><br><span class="line">        result.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result; // return the result array</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手动实现-Array-prototype-reduce-方法"><a href="#手动实现-Array-prototype-reduce-方法" class="headerlink" title="手动实现 Array.prototype.reduce 方法"></a>手动实现 Array.prototype.reduce 方法</h2><p><a href="https://link.juejin.cn/?target=">reduce()</a> 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function reduce(arr, reduceCallback, initialValue) &#123;</span><br><span class="line">  // 首先，检查传递的参数是否正确。</span><br><span class="line">  if (!Array.isArray(arr) || !arr.length || typeof reduceCallback !== &#x27;function&#x27;) &#123;</span><br><span class="line">    return [];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果没有将initialValue传递给该函数，我们将使用第一个数组项作为initialValue</span><br><span class="line">    let hasInitialValue = initialValue !== undefined;</span><br><span class="line">    let value = hasInitialValue ? initialValue : arr[0];</span><br><span class="line">  </span><br><span class="line">    // 如果有传递 initialValue，则索引从 1 开始，否则从 0 开始</span><br><span class="line">    for (let i = hasInitialValue ? 1 : 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">      value = reduceCallback(value, arr[i], i, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;手写call、apply及bind函数&quot;&gt;&lt;a href=&quot;#手写call、apply及bind函数&quot; class=&quot;headerlink&quot; title=&quot;手写call、apply及bind函数&quot;&gt;&lt;/a&gt;手写call、apply及bind函数&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript 2015（ES6）新特性</title>
    <link href="https://superq314.github.io/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ECMAScript2015(ES6)%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://superq314.github.io/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/ECMAScript2015(ES6)%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2022-07-14T10:07:26.240Z</published>
    <updated>2022-07-18T08:09:51.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6新增数据类型 <code>Symbol</code>。</p><blockquote><p>表示一个独一无二的值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="title class_">Symbol</span>(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> test2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test, test2)      <span class="comment">//Symbol(one) Symbol(one)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test === test2)   <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>一般用于防止对象属性重复，全局下即便不知道是什么属性，只要是Symbol类型就不会重复</p><blockquote><p>即使对象键值相同，实际却不相同</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="title class_">Symbol</span>(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> test2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   [test]: <span class="number">1</span>,</span><br><span class="line">   [test2]: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)<span class="comment">//&#123;Symbol(one): 1, Symbol(one): 1&#125;</span></span><br></pre></td></tr></table></figure><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>es6多出两个块级作用域：<code>const</code>与 <code>let</code>。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p><code>const</code>定义常量，常量不可重新赋值，一般只用于读取不作修改变量时使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>;      <span class="comment">//错误，不可重新赋值</span></span><br></pre></td></tr></table></figure><p>由于栈内存不可变，堆内存可以进行修改。</p><blockquote><p>因此，<code>const</code>声明的数组和对象仍然可以添加或删除内容。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line">arr = [<span class="number">1</span>];      <span class="comment">//错误，不可重复赋值</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">1</span>);   <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span> &#125;;<span class="comment">//错误，不可重复赋值</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;name&#x27;</span>;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let</code>声明可变变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>只在块级中有作用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">   <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)    <span class="comment">//1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)          <span class="comment">//错误，提示你没有声明</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)          <span class="comment">//错误，提示你没有声明</span></span><br></pre></td></tr></table></figure><p> <strong>声明变量时优先使用常量const，其余非常量都使用let</strong>。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>适用于需要匿名函数的地方。</p><p><strong>任何可以使用函数表达式的地方，都可以使用箭头函数:</strong> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">arrowAdd</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// &gt;&gt; 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">arrowAdd</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// &gt;&gt; 3</span></span><br></pre></td></tr></table></figure><blockquote><p>注：不能用作构造函数。</p></blockquote><p>一个普通的箭头函数，参数是state，返回值是res：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5 Version</span></span><br><span class="line"><span class="keyword">function</span>(<span class="params">state</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES6 Version</span></span><br><span class="line">(state) =&gt; &#123; <span class="keyword">return</span> res &#125;</span><br></pre></td></tr></table></figure><p>如果后面的内容<strong>直接返回</strong>，可以去掉{}，或者使用()：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5 Version</span></span><br><span class="line"><span class="keyword">var</span> getCurrentDate = <span class="keyword">function</span> (<span class="params">state</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES6 Version</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getCurrentDate</span> = (<span class="params">state</span>) =&gt; <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure><p>单一入参的话，前面的括号()也可省略，多参数必须保留：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5 Version</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;Hello &#x27;</span> + name + <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES6 Version</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params">name</span>) =&gt; <span class="title class_">Hello</span> $&#123;name&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greet2</span> = name =&gt; <span class="title class_">Hello</span> $&#123;name&#125;;</span><br></pre></td></tr></table></figure><h3 id="箭头函数没有argument对象"><a href="#箭头函数没有argument对象" class="headerlink" title="箭头函数没有argument对象"></a>箭头函数没有argument对象</h3><blockquote><p>箭头函数没有arguments、super、new.target，也不能用作构造函数。</p><p>此外，箭头函数也没有prototype属性。</p></blockquote><blockquote><p>但可以使用rest参数来获得在箭头函数中传递的所有参数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getArgs</span> = (<span class="params"></span>) =&gt; <span class="variable language_">arguments</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getArgs2</span> = (<span class="params">...rest</span>) =&gt; rest</span><br></pre></td></tr></table></figure><p>箭头函数没有自己的this值。它捕获词法作用域函数的this值，在此示例中，addAll函数将复制computeResult方法中的this值，如果我们在全局作用域声明箭头函数，则this值为 window 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">   <span class="attr">result</span>: <span class="number">0</span>,</span><br><span class="line">   <span class="attr">nums</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">   <span class="title function_">computeResult</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 这里的“this”指的是“data”对象</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">addAll</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nums</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, cur</span>) =&gt;</span> total + cur, <span class="number">0</span>)</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">result</span> = <span class="title function_">addAll</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数默认参数、剩余参数"><a href="#函数默认参数、剩余参数" class="headerlink" title="函数默认参数、剩余参数"></a>函数默认参数、剩余参数</h2><p><strong>默认参数</strong>：函数在没有得到入参时可以使用默认参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = (<span class="params">param = <span class="number">1</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(param)  <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>()</span><br></pre></td></tr></table></figure><p><strong>剩余参数</strong>：可将<strong>未声明参数的部分</strong>全部合在一起成一个<strong>数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = (<span class="params">param, ...other</span>) =&gt; &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(param, other)  <span class="comment">//1 [2,3,4]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="对象解构赋值"><a href="#对象解构赋值" class="headerlink" title="对象解构赋值"></a>对象解构赋值</h2><p>对象解构：从数组或者对象中将<strong>栈内存</strong>取出进行使用。<br>一般都是只进行使用不进行修改，所以解构一般都用<strong>const</strong>声明。</p><h3 id="基础解构"><a href="#基础解构" class="headerlink" title="基础解构"></a>基础解构</h3><p>在对象中解构时声明的名称与key一一对应：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">   <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = obj<span class="comment">// 解构语法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name)<span class="comment">// John</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age)<span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>在数组中按照位置对应，声明名称可以随意：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;name&#x27;</span>, <span class="number">18</span>]</span><br><span class="line"><span class="keyword">const</span> &#123; a, b &#125; = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)<span class="comment">//name 18</span></span><br></pre></td></tr></table></figure><h3 id="别名解构"><a href="#别名解构" class="headerlink" title="别名解构"></a>别名解构</h3><p>把对象属性赋值给属性名不一致的变量名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">   <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: newName, age &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newName, age)<span class="comment">//name 18</span></span><br></pre></td></tr></table></figure><h3 id="默认值解构"><a href="#默认值解构" class="headerlink" title="默认值解构"></a>默认值解构</h3><p>当对象中不存在特定属性的解构，会赋值为 <code>undefined</code> ，如果不希望是 <code>undefined</code> ，可以为其设置一个默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;Quintion&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&quot;Tang&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">firstName</span>: trueName, lastName, age = <span class="number">18</span> &#125; = fullName; <span class="comment">// 解构语法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trueName); <span class="comment">// Quintion</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lastName); <span class="comment">// Tang</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>下面来看下存在 <code>age</code> 属性下的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;Quintion&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&quot;Tang&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">firstName</span>: trueName, lastName, age = <span class="number">18</span> &#125; = fullName; <span class="comment">// 解构语法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trueName); <span class="comment">// Quintion</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lastName); <span class="comment">// Tang</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><h3 id="REST解构"><a href="#REST解构" class="headerlink" title="REST解构"></a>REST解构</h3><p>如果想从一个对象中解构一个属性，剩下的属性结构为另一个变量，如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> fullName = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;Quintion&quot;</span>,</span><br><span class="line">    lastName: <span class="string">&quot;Tang&quot;</span>,</span><br><span class="line">    age: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> &#123; age, ...username &#125; = fullName; <span class="comment">// 解构语法</span></span><br><span class="line">console.<span class="built_in">log</span>(username); <span class="comment">// &#123; firstName: &#x27;Quintion&#x27;, lastName: &#x27;Tang&#x27; &#125;</span></span><br><span class="line">console.<span class="built_in">log</span>(age); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><h3 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">   <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">   <span class="attr">info</span>: &#123;</span><br><span class="line">   <span class="attr">address</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age, <span class="attr">info</span>: &#123; address &#125; &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age, address)<span class="comment">//name 18 北京</span></span><br></pre></td></tr></table></figure><h2 id="对象展开运算符"><a href="#对象展开运算符" class="headerlink" title="对象展开运算符"></a>对象展开运算符</h2><p>类似函数剩余参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">   <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">   <span class="attr">address</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; ...all &#125; = obj</span><br><span class="line"><span class="keyword">const</span> &#123; name, ...other &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(all, other)<span class="comment">//&#123;name: &#x27;name&#x27;, age: 18, address: &#x27;北京&#x27;&#125; &#123;age: 18, address: &#x27;北京&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>在react组件传值时可以使用到，比如需要把一整个对象的属性都传入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">   <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">   <span class="attr">address</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; ...all &#125; = obj</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">Component</span> ...all&gt;&lt;<span class="title class_">Component</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>字符串中需要添加变量时用于代替+号连接的方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="number">123</span></span><br><span class="line"><span class="keyword">const</span> mes = <span class="string">&#x27;id是&#x27;</span> + id    <span class="comment">//旧方案</span></span><br><span class="line"><span class="keyword">const</span> mes2 = <span class="string">`id是<span class="subst">$&#123;id&#125;</span>`</span>   <span class="comment">//模板字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mes, mes2)     <span class="comment">//id是123 id是123</span></span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类(class)是在JS中编写构造函数的新方法。<br>它是使用构造函数的语法糖，在底层中使用仍然是原型和基于原型的继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5 Version</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">firstName, lastName, age, address</span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">lastName</span> = lastName;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">address</span> = address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">self</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;[object Person]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getFullName</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 Version</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">firstName, lastName, age, address</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lastName</span> = lastName;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">address</span> = address;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="title function_">self</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;[object Person]&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">getFullName</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> $&#123;<span class="variable language_">this</span>.<span class="property">firstName</span>&#125; $&#123;<span class="variable language_">this</span>.<span class="property">lastName</span>&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写方法并从另一个类继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5 Version</span></span><br><span class="line"><span class="title class_">Employee</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Employee</span>(<span class="params">firstName, lastName, age, address, jobTitle, yearStarted</span>) &#123;</span><br><span class="line">   <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, firstName, lastName, age, address);</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">jobTitle</span> = jobTitle;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">yearStarted</span> = yearStarted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Employee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">describe</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> I am $&#123;<span class="variable language_">this</span>.<span class="title function_">getFullName</span>()&#125; and I have a position <span class="keyword">of</span> $&#123;<span class="variable language_">this</span>.<span class="property">jobTitle</span>&#125; and I started at $&#123;<span class="variable language_">this</span>.<span class="property">yearStarted</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Employee</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;[object Employee]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 Version</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>  &#123;</span><br><span class="line">   <span class="comment">//Inherits from &quot;Person&quot; </span></span><br><span class="line">   <span class="keyword">class</span>  <span class="title class_">constructor</span>(firstName, lastName, age, address, jobTitle, yearStarted) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(firstName, lastName, age, address);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">jobTitle</span> = jobTitle;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">yearStarted</span> = yearStarted;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">describe</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> I am $&#123;<span class="variable language_">this</span>.<span class="title function_">getFullName</span>()&#125; and I have a position <span class="keyword">of</span> $&#123;<span class="variable language_">this</span>.<span class="property">jobTitle</span>&#125; and I started at $&#123;<span class="variable language_">this</span>.<span class="property">yearStarted</span>&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// Overriding the &quot;toString&quot; method of &quot;Person&quot;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;[object Employee]&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们要怎么知道它在内部使用原型？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Something</span> &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AnotherSomething</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">as</span> = <span class="keyword">new</span> <span class="title class_">AnotherSomething</span>();</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Something</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Something</span>);         <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">AnotherSomething</span>);  <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">as</span>.<span class="title function_">toString</span>());            <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">as</span>.<span class="title function_">toString</span>());            <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">as</span>.<span class="property">toString</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">toString</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>相关资料：<br><a href="https://link.juejin.cn/?target=https://www.zhihu.com/question/29789315" title="https://www.zhihu.com/question/29789315">《ECMAScript 6实现了 class，对 JavaScript 前端开发有什么意义？》</a></p><p><a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/class" title="http://es6.ruanyifeng.com/#docs/class">《Class的基本语法》</a></p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><ol><li>CommonJS输出的是值的拷贝，ES6模块输出的是值的引用。<blockquote><p>也就是说CommonJS引用后改变模块内变量的值，其他引用模块不会改变，而ES6模块会改变。</p></blockquote></li><li>CommonJS是运行时加载，ES6模块是编译时输出接口。<blockquote><p>之所以Webpack的Tree Shaking是基于ES6的，就是因为ES6在编译的时候就能确定依赖。因为使用babel-preset-2015这个预设默认是会把ES6模块编译为CommonJS的，所以想使用Tree Shaking还需要手动修改这个预设。</p></blockquote></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        exclude: /(node_modules|bower_components)/,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: &#x27;babel-loader&#x27;,</span><br><span class="line">          options: &#123;</span><br><span class="line">            presets: [[&#x27;babel-preset-es2015&#x27;, &#123;modules: false&#125;]],</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async函数实现原理"><a href="#async函数实现原理" class="headerlink" title="async函数实现原理"></a>async函数实现原理</h2><p>async函数是基于generator实现，所以涉及到generator相关知识。在没有async函数之前，通常使用co库来执行generator，所以通过co我们也能模拟async的实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Asyncfn</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">co</span>(<span class="keyword">function</span>*() &#123;</span><br><span class="line">      <span class="comment">//.....</span></span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fn = <span class="title function_">gen</span>();</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data</span>) &#123;</span><br><span class="line">         <span class="keyword">let</span> &#123; value, done &#125; = fn.<span class="title function_">next</span>(data);</span><br><span class="line">         <span class="keyword">if</span> (done) <span class="keyword">return</span> <span class="title function_">resolve</span>(value);</span><br><span class="line">         <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(res);</span><br><span class="line">         &#125;, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>();</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Symbol&quot;&gt;&lt;a href=&quot;#Symbol&quot; class=&quot;headerlink&quot; title=&quot;Symbol&quot;&gt;&lt;/a&gt;Symbol&lt;/h2&gt;&lt;p&gt;ES6新增数据类型 &lt;code&gt;Symbol&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;表示一</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>模块化开发</title>
    <link href="https://superq314.github.io/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>https://superq314.github.io/2022/07/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/</id>
    <published>2022-07-14T00:57:07.222Z</published>
    <updated>2022-07-18T15:07:20.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谈谈你对模块化开发的理解？"><a href="#谈谈你对模块化开发的理解？" class="headerlink" title="谈谈你对模块化开发的理解？"></a>谈谈你对模块化开发的理解？</h2><p>我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</p><p>由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。</p><p>后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。</p><p>现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</p><p>相关资料：</p><p><a href="https://juejin.cn/post/6844903581661790216" title="https://juejin.cn/post/6844903581661790216">-《浅谈模块化开发》</a></p><p><a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" title="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">《**Javascript **模块化编程（一）：模块的写法》</a></p><p><a href="https://juejin.cn/post/6844903576309858318" title="https://juejin.cn/post/6844903576309858318">《前端模块化：<strong>CommonJS</strong>，AMD，CMD，ES6》</a></p><p><a href="https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/module" title="http://es6.ruanyifeng.com/#docs/module">《**Module **的语法》</a></p><h2 id="js的模块规范"><a href="#js的模块规范" class="headerlink" title="js的模块规范"></a>js的模块规范</h2><p>js中现在比较成熟的有四种模块加载方案：</p><ol><li>CommonJS方案，它通过require来引入模块，通过module.exports定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。<ul><li>值引用</li><li>可动态加载</li><li>可被缓存</li><li>默认严格模式</li></ul></li><li>AMD方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js实现了AMD规范。</li><li>CMD方案，这种方案和AMD方案都是为了解决异步模块加载的问题，sea.js实现了CMD规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</li><li>ES6提出的方案，使用import和export的形式来导入导出模块。</li></ol><h2 id="AMD和CMD规范的区别？"><a href="#AMD和CMD规范的区别？" class="headerlink" title="AMD和CMD规范的区别？"></a>AMD和CMD规范的区别？</h2><p>它们之间的主要区别有两个方面。</p><ol><li>第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而CMD推崇就近依赖，只有在用到某个模块的时候再去 require。</li><li>第二个方面是对依赖模块的执行时机处理不同。首先AMD和CMD对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(</span><br><span class="line">   function(require, exports, module) &#123;</span><br><span class="line">      var a = require(&quot;./a&quot;);</span><br><span class="line">      a.doSomething();</span><br><span class="line">      // 此处略去 100 行</span><br><span class="line">      var b = require(&quot;./b&quot;);</span><br><span class="line">      // 依赖可以就近书写</span><br><span class="line">      b.doSomething();*</span><br><span class="line">      // ...</span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// AMD 默认推荐</span><br><span class="line">define([&quot;./a&quot;, &quot;./b&quot;], function(a, b) &#123;</span><br><span class="line">   // 依赖必须一开始就写好</span><br><span class="line">   a.doSomething();</span><br><span class="line">   // 此处略去 100 行</span><br><span class="line">   b.doSomething();</span><br><span class="line">   // ...</span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>相关资料：<br><a href="https://juejin.cn/post/6844903541853650951" title="https://juejin.cn/post/6844903541853650951">《前端模块化，AMD 与 CMD 的区别》</a></p><h2 id="ES6模块与CommonJS模块的差异"><a href="#ES6模块与CommonJS模块的差异" class="headerlink" title="ES6模块与CommonJS模块的差异"></a>ES6模块与CommonJS模块的差异</h2><p>l <strong>CommonJS</strong>模块输出的是一个值的拷贝，ES6模块输出的是值的引用。<strong>CommonJS</strong>模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6模块的运行机制与CommonJS不一样。JS引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p><p>l <strong>CommonJS</strong>模块是运行时加载，ES6模块是编译时输出接口。<strong>CommonJS</strong>模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p><h3 id="requireJS的核心原理"><a href="#requireJS的核心原理" class="headerlink" title="requireJS的核心原理"></a>requireJS的核心原理</h3><p>require.js的核心原理是通过动态创建script脚本来异步引入模块，然后对每个脚本的load事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p><p>详细资料可以参考：</p><p><a href="https://link.juejin.cn/?target=https://github.com/HRFE/blog/issues/10" title="https://github.com/HRFE/blog/issues/10">《requireJS 的用法和原理分析》</a></p><p><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/55039478" title="https://zhuanlan.zhihu.com/p/55039478">《requireJS 的核心原理是什么？》</a></p><p><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/5a39535909e4" title="https://www.jianshu.com/p/5a39535909e4">《requireJS 原理分析》</a></p><h1 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h1><blockquote><p>（Modular design）　所谓的 <strong>模块化设计</strong> ，简单地说就是将产品的某些要素组合在一起，构成一个具有特定功能的子系统，将这个子系统作为通用性的模块与其他产品要素进行多种组合，构成新的系统，产生多种不同功能或相同功能、不同性能的系列产品。</p></blockquote><p>这是在整个设计行业对模块化的定义。对于编程语言中的模块化设计，其基本思路就是将有相同功能的部分代码封装在一起，形成一个通用的，可复用的 <strong>模块</strong> ，使之在其它系统中可以重复利用，并不会对模块内部产生影响。所以设计模式中模块化设计的三大特征也要遵循：</p><ol><li>相对独立性</li><li>互换性</li><li>通用性</li></ol><p>换做在编程语言中，相对独立性即要使私有成员无法被外部访问并暴露给外部指定的方法。通用性在程序设计中多被称为 <strong>可复用性</strong> ，而模块设计的原则和目的也是可复用性。模块可以减少我们对重复代码的编写，提高开发的效率。</p><h2 id="JavaScript对模块的需求"><a href="#JavaScript对模块的需求" class="headerlink" title="JavaScript对模块的需求"></a>JavaScript对模块的需求</h2><p>最初JavaScript是作为网页开发的脚本而开发，Brendan Eich 可能也不会想到当初十几天开发出的一个脚本语言如今会焕发如此的生命力，也正是因为开发周期如此之短，使之缺点在当今工程化的JavaScript中被极大的放大。其中一个就是模块的概念，JavaScript原生并没有模块的概念，就如同没有原生的类一样（尽管ES6推出了所谓的类）。为此，开发者想出了很多方法从语言层面来模拟模块化。</p><h1 id="初期的模块化"><a href="#初期的模块化" class="headerlink" title="初期的模块化"></a>初期的模块化</h1><p>在各类框架，插件没有流行，JavaScript仅作为一门脚本语言的时候，开发人员想出了一些方法来对项目中一些方法集合进行封装，形成类似于模块的模式。</p><h2 id="原生写法"><a href="#原生写法" class="headerlink" title="原生写法"></a>原生写法</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>模块就是实现特定功能的一组方法。</p><p>只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>“污染”了全局变量，无法保证不与其他模块发生变量名冲突</li><li>模块成员之间看不出直接关系。</li></ol><h2 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>为了解决上面的“全局变量污染的问题”，又利用了对象这一数据类型，使一个模块成为一个对象，模块的成员作为对象的成员变量。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123;</span><br><span class="line"></span><br><span class="line">    _count : <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    m1 : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    m2 : <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>私有变量被直接暴露给外部，如上面的 <code>_count</code>应该是一个保留的私有变量，但是在外部我们也是可以访问到的。</li></ol><h2 id="立即执行函数（IIFE）写法"><a href="#立即执行函数（IIFE）写法" class="headerlink" title="立即执行函数（IIFE）写法"></a>立即执行函数（IIFE）写法</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>又为了解决无法保有私有成员的问题（其本质是JavaScript没有局部作用域的问题，具体看<a href="https://link.juejin.cn/?target=https://michaelwang.top/2021/01/31/%25E5%2585%25A8%25E9%259D%25A2%25E7%2590%2586%25E8%25A7%25A3JavaScript%25E4%25BD%259C%25E7%2594%25A8%25E5%259F%259F%25E4%25B8%258E%25E9%2597%25AD%25E5%258C%2585/" title="https://michaelwang.top/2021/01/31/%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/">这里</a>），这里利用了立即执行函数形成一个闭包的同时也形成了一个局部作用域，这个作用域内的变量在外部是无法访问到的。这样就解决了上面的私有便变量的问题。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m1 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m2 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        m1 : m1,</span><br><span class="line">        m2 : m2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里 <code>module1</code>形成了一个闭包，返回一个对象，我们只能访问到对象暴露的 <code>m1</code>和 <code>m2</code>方法，内部的 <code>_count</code>是无法被访问到了。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>提高性能：通过 IIFE 的参数传递常用全局对象 window、document，在作用域内引用这些全局对象。JavaScript 解释器首先在作用域内查找属性，然后一直沿着链向上查找，直到全局范围，因此将全局对象放在 IIFE 作用域内可以提升js解释器的查找速度和性能；</li><li>压缩空间：通过参数传递全局对象，压缩时可以将这些全局对象匿名为一个更加精简的变量名；</li></ol><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ol><li>不能很好的管理依赖，缺少一个依赖管理者。比如依赖的调用顺序，在没有管理者时，我们必须自己确定调用顺序，比如：<br>我们要调用 <code>module1</code>的 <code>mock</code>方法，<br>而 <code>module1</code>又依赖 <code>module2</code><br><code>module2</code>又依赖 <code>module3</code><br><code>module4</code>又依赖 <code>module3</code><br>我们则必须按这个顺序加载脚本文件<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;./module4&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;./module3&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;./module2&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;./module1&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">module1.mock()</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ol><h3 id="立即执行函数（IIFE）的衍生写法"><a href="#立即执行函数（IIFE）的衍生写法" class="headerlink" title="立即执行函数（IIFE）的衍生写法"></a>立即执行函数（IIFE）的衍生写法</h3><h4 id="放大模式"><a href="#放大模式" class="headerlink" title="放大模式"></a>放大模式</h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。</p><h5 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="keyword">function</span> (<span class="params">mod</span>)&#123;</span><br><span class="line"></span><br><span class="line">    mod.<span class="property">m3</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line"></span><br><span class="line">&#125;)(module1);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的代码为 <code>module</code>添加了一个 <code>m3</code>属性。并将新的模块实体返回。</p><h4 id="宽放大模式"><a href="#宽放大模式" class="headerlink" title="宽放大模式"></a>宽放大模式</h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>对于上面的放大模式，存在一定的问题。由于在浏览器中，所有的资源都是异步加载的，所以上面的参数可能不存在，所以我们必须要考虑这种情况，增强代码的健壮性。</p><h5 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = ( <span class="keyword">function</span> (<span class="params">mod</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mod;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="variable language_">window</span>.<span class="property">module1</span> || &#123;&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面的代码相当于是给函数参数设置了一个默认参数为 <code>&#123;&#125;</code>，当 <code>window.module1</code>不存在的时候，在对 <code>&#123;&#125;</code>空对象进行操作。</p><h1 id="现代模块设计"><a href="#现代模块设计" class="headerlink" title="现代模块设计"></a>现代模块设计</h1><p>恩格斯说：“社会一旦有技术上的需要，则这种需要会比十所大学更能把科学院推向前进。”随着进入大前端时代，网站的规模越来越大，逻辑层面越来越复杂。模块化的管理成为必然，很多模块管理框架应运而生。具有代表性的有：</p><ul><li>Node.js中CommonJS</li><li>基于 AMD 的 RequireJS</li><li>基于 CMD 的 SeaJS</li><li>ECMAScript规定的ES Module</li></ul><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>CommonJS 是Node.js中采用的一种规范，其基本原则有：</p><ol><li><strong>由于 <code>Node</code>是在服务端运行，所以 <code>CommonJS</code>的模块加载是同步进行的，所以其在浏览器中并不适用，因为浏览器中的文件都是通过网络加载的，并不适合同步加载。</strong></li><li>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</li><li>每个模块内部有一个全局变量 <code>module</code>，这个变量是一个对象，它的 <code>exports</code>属性（即 <code>module.export</code>）用于导出模块。</li><li>每个模块内部有一个全局变量 <code>require</code>，其是一个函数，用于导入模块，参数即模块的地址。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ol><h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3><h5 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js</span></span><br><span class="line"><span class="keyword">let</span> _temp = -<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="keyword">let</span> exchange = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    _temp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = _temp</span><br><span class="line">    <span class="keyword">return</span> [a,b]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">export</span>.<span class="property">pi</span> = pi</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">export</span>.<span class="property">exchange</span> = exchange</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这么写</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">export</span>.<span class="property">sum</span> = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> module1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(module1.<span class="title function_">exchange</span>(<span class="number">1</span>, <span class="number">2</span>))<span class="comment">//[2, 1]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(module1.<span class="property">pi</span>)<span class="comment">//3.1415926</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><p><code>Node</code>内部提供一个 <code>Module</code>构建函数。所有的模块都是 <code>Module</code>的实例。</p><p>查看 <code>Node</code>源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Module</span>(<span class="params">id, parent</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">exports</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parent</span> = parent;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以发现其是一个构造器函数，其中设置了以下属性：</p><ul><li><code>module.id</code>：模块的识别符，通常是带有绝对路径的模块文件名。</li><li><code>module.filename</code> 模块的文件名，带有绝对路径。</li><li><code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。</li><li><code>module.parent</code> 返回一个对象，表示调用该模块的父级块。</li><li><code>module.children</code> 返回一个数组，表示该模块要用到的其他子级模块。</li><li><code>module.exports</code> 表示模块对外输出的值。</li></ul><p>实际上我们模块导入的过程就是为对应模块的 <code>module.exports</code>对象增加成员的过程。</p><h4 id="目录加载规则"><a href="#目录加载规则" class="headerlink" title="目录加载规则"></a>目录加载规则</h4><p>通常一个项目都有一个入口文件（或函数），比如C语言，Java中的 <code>main</code>函数。在 <code>Node</code>项目中，一般也会指定一个入口文件，让 <code>require</code>方法可以通过这个入口文件，加载整个项目。</p><p>一般这个入口放在 <code>packge.json</code>文件，并将入口文件写入 <code>main</code>字段。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//packge.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;new_project&quot;</span>,</span><br><span class="line">    <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./main/index.js&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>require</code>发现参数字符串指向一个目录以后，会自动查看该目录的 <code>packge.json</code>文件，然后加载 <code>main</code>字段指定的入口文件。如果 <code>packge.json</code>文件没有 <code>main</code>字段，或者没有 <code>packge.json</code>文件，则会加载该目录下的 <code>index.js</code>文件或者 <code>index.node</code>文件。</p><h4 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h4><p>Node会在第一次加载模块后，缓冲该模块（实际上是缓存该模块的 <code>module.exports</code>属性）。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./moudle1.js&#x27;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./moudle1.js&#x27;</span>).<span class="property">num</span> = <span class="number">1</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./moudle1.js&#x27;</span>).<span class="property">num</span><span class="comment">//1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面三次导入一个模块，但是我们添加的成员变量在第三次缓冲时仍然可以访问到，证明其是被缓冲在内存中的。</p><p>我们可以通过删除 <code>require.cache</code>的对应属性来删除模块缓冲。</p><h5 id="删除模块缓冲"><a href="#删除模块缓冲" class="headerlink" title="删除模块缓冲"></a>删除模块缓冲</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定模块</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">require</span>.<span class="property">cache</span>[moduleName]</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(<span class="built_in">require</span>.<span class="property">cache</span>, moduleName)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有模块的缓存</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="built_in">require</span>.<span class="property">cache</span>).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">require</span>.<span class="property">cache</span>[key];</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h4><p><code>CommonJS</code> 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。</p><p>下面是一个模块文件 <code>lib.js</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面代码输出内部变量 <code>counter</code> 和改写这个变量的内部方法 <code>incCounter</code>。</p><p>然后，加载上面的模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).<span class="property">counter</span>;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).<span class="property">incCounter</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter);  <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面代码说明，<code>counter</code> 输出以后，<code>lib.js</code> 模块内部的变化就影响不到 <code>counter</code> 了。</p><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><h3 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h3><p>AMD 全称为  <strong>Asynchromous Module Definition（异步模块定义）</strong> 。 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，它是一个在浏览器端模块化开发的规范。 AMD 模式可以用于浏览器环境并且允许<strong>异步</strong>加载模块，同时又能保证正确的顺序，也可以按需动态加载模块。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><code>AMD</code>是依赖前置，即提前声明需要的依赖。</li><li>对依赖的加载是提前进行的，在运行前就加载所有的依赖。</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>模块通过 <code>define</code> 函数定义在闭包中，格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(id?: <span class="title class_">String</span>, dependencies?: <span class="title class_">String</span>[], <span class="attr">factory</span>: <span class="title class_">Function</span>|<span class="title class_">Object</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>id</code> 是模块的名字，它是可选的参数。</p><p><code>dependencies</code> 指定了所要依赖的模块列表，它是一个数组，也是可选的参数，每个依赖的模块的输出将作为参数一次传入 <code>factory</code> 中。如果没有指定 <code>dependencies</code>，那么它的默认值是 <code>[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;&#125;）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>factory</code> 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。</p><h3 id="例子-require-js"><a href="#例子-require-js" class="headerlink" title="例子(require.js)"></a>例子(<code>require.js</code>)</h3><h4 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;jquery&#x27;</span>], <span class="keyword">function</span>(<span class="params">$</span>)P&#123;</span><br><span class="line"> <span class="keyword">var</span> num = <span class="number">555</span></span><br><span class="line">     <span class="keyword">var</span> _version = <span class="number">0.01</span></span><br><span class="line">   </span><br><span class="line">     <span class="keyword">var</span> showMessage = <span class="keyword">function</span>(<span class="params">message</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!message)&#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                $(<span class="string">&#x27;#messageBox&#x27;</span>).<span class="title function_">html</span>(<span class="string">&#x27;欢迎访问&#x27;</span> + name)</span><br><span class="line">            &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span>&#123;</span><br><span class="line">         <span class="string">&#x27;num&#x27;</span>:num,</span><br><span class="line">         <span class="string">&#x27;showMessage&#x27;</span>: showMessage</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//_version为内部维护变量，无法被外部访问到</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置文件</span></span><br><span class="line"><span class="built_in">require</span>.<span class="title function_">config</span>(&#123;</span><br><span class="line">    <span class="attr">baseUrl</span>: <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">    <span class="attr">paths</span>: &#123;</span><br><span class="line">        <span class="attr">jquery</span>: <span class="string">&#x27;lib/jquery-1.11.1&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;script/hello&#x27;</span>],<span class="keyword">function</span> (<span class="params">$, hello</span>) &#123;</span><br><span class="line">    $(<span class="string">&quot;#btn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      hello.<span class="title function_">showMessage</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><h3 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h3><p>CMD（Common Module Definition） 是 SeaJS 在推广过程中对模块定义的规范化产出。CMD 规范的前身是 Modules&#x2F;Wrappings 规范。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>CMD推崇依赖就近，即在依赖使用时才引入。</li><li>CMD是延迟执行的，即使用的时候才延迟执行的。</li></ul><h3 id="用法（SeaJS）"><a href="#用法（SeaJS）" class="headerlink" title="用法（SeaJS）"></a>用法（SeaJS）</h3><p>1、 <strong><code>seajs.config</code></strong> ({…});  &#x2F;&#x2F;用来对 Sea.js 进行配置。<br>2、 <strong><code>seajs.use</code></strong> ([‘a’,’b’],function(a,b){…});  &#x2F;&#x2F;用来在页面中加载一个或多个模块。<br>3、 <strong><code>define</code></strong> (function(require, exports, module){…});  &#x2F;&#x2F;用来定义模块。Sea.js 推崇一个模块一个文件，遵循统一的写法：<br>4、 <strong><code>require</code></strong> (function(require){var a &#x3D; require(“xModule”); … });  &#x2F;&#x2F;require 用来获取指定模块的接口。<br>5、 <strong><code>require.async</code></strong> ,  &#x2F;&#x2F;用来在模块内部异步加载一个或多个模块。 例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span></span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.<span class="title function_">async</span>([<span class="string">&#x27;aModule&#x27;</span>,<span class="string">&#x27;bModule&#x27;</span>],<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;  <span class="comment">// 异步加载多个模块，在加载完成时，执行回调</span></span><br><span class="line">    a.<span class="title function_">func</span>();</span><br><span class="line">    b.<span class="title function_">func</span>();</span><br><span class="line">    &#125;)  </span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>6、 <strong><code>exports</code></strong> , &#x2F;&#x2F;用来在模块内部对外提供接口。 例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span></span>)&#123;</span><br><span class="line">    <span class="built_in">exports</span>.<span class="property">varName01</span> = <span class="string">&#x27;varValue&#x27;</span>;  <span class="comment">// 对外提供 varName01 属性  </span></span><br><span class="line">    <span class="built_in">exports</span>.<span class="property">funName01</span> = <span class="keyword">function</span>(<span class="params">p1,p2</span>)&#123;  <span class="comment">// 对外提供 funName01 方法</span></span><br><span class="line">    ....</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>7、 <strong><code>module.exports</code></strong> , 与 exports 类似，用来在模块内部对外提供接口。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;  </span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  <span class="comment">// 对外提供接口</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="attr">doSomething</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;...&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h3><h4 id="定义模块-1"><a href="#定义模块-1" class="headerlink" title="定义模块"></a>定义模块</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// seajs 的简单配置</span></span><br><span class="line">seajs.<span class="title function_">config</span>(&#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&quot;../sea-modules/&quot;</span>,</span><br><span class="line">  <span class="attr">alias</span>: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery/jquery/1.10.1/jquery.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有模块都通过 define 来定义</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 require 引入依赖</span></span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">Spinning</span> = <span class="built_in">require</span>(<span class="string">&#x27;./spinning&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 exports 对外提供接口</span></span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">doSomething</span> = ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者通过 module.exports 提供整个接口</span></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//或者使用return向外提供接口</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">someVal</span>: someVal,</span><br><span class="line">      <span class="attr">doSomething</span>: doSomething</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果 <code>retunr</code>语句是模块的唯一代码，还可以简化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(&#123;</span><br><span class="line">  <span class="attr">someVal</span>: someVal,</span><br><span class="line">  <span class="attr">doSomething</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="引入模块-1"><a href="#引入模块-1" class="headerlink" title="引入模块"></a>引入模块</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//单一模式</span></span><br><span class="line">seajs.<span class="title function_">use</span>(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//回调模式</span></span><br><span class="line">seajs.<span class="title function_">use</span>(<span class="string">&#x27;./a&#x27;</span>, <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  a.<span class="title function_">run</span>()</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//多模块模式</span></span><br><span class="line">seajs.<span class="title function_">use</span>([<span class="string">&#x27;./a&#x27;</span>, <span class="string">&#x27;./b&#x27;</span>], <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  a.<span class="title function_">run</span>()</span><br><span class="line">  b.<span class="title function_">run</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一个模块中引入其他模块</span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">    <span class="comment">//同步引入其他模块</span></span><br><span class="line">    <span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//异步引入其他模块</span></span><br><span class="line">    <span class="keyword">var</span> module2 = <span class="built_in">require</span>.<span class="title function_">async</span>(<span class="string">&#x27;./module2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p> <strong>注意</strong> ：</p><ul><li>对 <code>module.exports</code> 的赋值需要同步执行，不能放在回调函数里。</li><li>在 <code>html</code>中 ，为 <code>script</code>标签添加 <code>data-main = true</code>确定其为主入口。data-main通常用在只有一个入口的情况，use可以用在多个入口的情况</li></ul><h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><h3 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h3><p>UMD（Universal Module Definition），AMD模块以浏览器第一的原则发展，异步加载模块。CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式UMD （Universal Module Definition）。希望解决跨平台的解决方案。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>兼容 AMD 和 CommonJS 规范的同时，还兼容全局引用的方式</li></ul><h3 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">        <span class="comment">//AMD</span></span><br><span class="line">        <span class="title function_">define</span>([<span class="string">&#x27;jquery&#x27;</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//Node, CommonJS之类的</span></span><br><span class="line">        <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//浏览器全局变量(root 即 window)</span></span><br><span class="line">        root.<span class="property">returnExports</span> = <span class="title function_">factory</span>(root.<span class="property">jQuery</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">$</span>) &#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">    <span class="comment">//暴露公共方法</span></span><br><span class="line">    <span class="keyword">return</span> myFunc;</span><br><span class="line">&#125;));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h2><h3 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h3><p>在 ES Module 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES Module 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES Module 的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。</p><p>CommonJS 和 AMD 模块，其本质是在运行时生成一个<strong>对象</strong>进行导出，称为“运行时加载”，没法进行“编译优化”，而 ES Module 不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code> 命令输入。这称为“编译时加载”或者静态加载，即 ES Module 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES Module 模块本身，因为它不是对象。</p><p>由于 ES Module 是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p><p>除了静态加载带来的各种好处，ESz  Module 还有以下好处：</p><ul><li>不再需要 UMD 模块格式了，将来服务器和浏览器都会支持 ES Module 格式。目前，通过各种工具库，其实已经做到了这一点。</li><li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者 navigator 对象的属性。</li><li>不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块提供。</li></ul><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul><li>静态编译</li><li>输出的值引用，而非值拷贝</li><li><code>import</code> 只能写在顶层，因为是静态语法</li><li>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上 <code>&quot;use strict&quot;;</code>。（具体严格模式内容不再赘述）</li></ul><h3 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h3><h4 id="导出模块"><a href="#导出模块" class="headerlink" title="导出模块"></a>导出模块</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module1.js</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="number">3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="string">&#x27;default&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bactch1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> bactch2 = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> bactch3 = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导出已定义的变量</span></span><br><span class="line"><span class="keyword">export</span> pi</span><br><span class="line"><span class="keyword">export</span> sum</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接导出声明的变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> e = <span class="number">2.718281828459</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;bactch1, bactch2, bactch3&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出默认</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> d</span><br><span class="line"><span class="comment">//对导出变量重命名,并且重命名为default，与上面的说法一致</span></span><br><span class="line"><span class="keyword">export</span> &#123;d <span class="keyword">as</span> <span class="keyword">default</span>&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p><code>export default</code> 命令用于指定模块的默认输出。<code>export default</code> 就是输出一个叫做 <code>default</code> 的变量或方法，然后系统允许你为它取任意名字</p></li><li><p><code>export default</code>只能导出变量，不能在后面声明变量。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> pi = <span class="number">3.1415926</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><p><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。<br>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> foo = <span class="string">&#x27;baz&#x27;</span>, <span class="number">500</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>面代码输出变量 <code>foo</code>，值为 <code>bar</code>，500 毫秒之后变成 <code>baz</code>。</p></li></ul><h4 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接导入模块所有成员</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">&#x27;module1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//批量导入模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;pi, e, sum&#125; <span class="keyword">from</span> <span class="string">&#x27;module1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接执行所加载的模块</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一条import语句中，同时输入默认方法和其他接口</span></span><br><span class="line"><span class="keyword">import</span> _, &#123; each, forEach &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li><code>export</code>后无法直接接变量内容。如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">3</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ol><h4 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h4><p><code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行（<code>import</code>命令叫做“连接” binding 其实更合适）。所以 <code>import</code>和 <code>export</code>命令只能在模块的顶层，不能在代码块之中。如，下面的代码会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="title class_">MyModual</span> <span class="keyword">from</span> <span class="string">&#x27;./myModual&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但是有时候我们需要按需引入又该怎么办，<a href="https://link.juejin.cn/?target=https://github.com/tc39/proposal-dynamic-import" title="https://github.com/tc39/proposal-dynamic-import">ES2020提案</a> 引入 <code>import()</code>函数，支持动态加载模块。</p><p><code>import(specifier)</code></p><h5 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h5><ol><li><code>import</code>函数的参数 <code>specifier</code>，指定所要加载的模块的位置。</li><li><code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</li><li><code>import()</code>返回一个 Promise 对象。模块作为 <code>Promise</code>的参数返回下面是一个例子。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="title function_">loadPageInto</span>(main);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    main.<span class="property">textContent</span> = err.<span class="property">message</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与 <code>import</code>语句不相同。<code>import()</code>类似于 Node 的 <code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0047ec8a0384bc9853163c873d28cea~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="ESModule兼容性.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前JavaScript的模块规范就是上面谈到的四种，CommonJS、AMD、CMD、ES Module。 CommonJS 用在服务器端，AMD 和CMD 用在浏览器环境，ES Module 是作为终极通用解决方案，时下热议的<a href="https://link.juejin.cn/?target=https://github.com/vitejs/vite" title="https://github.com/vitejs/vite">vite</a>即利用了ES Module。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="AMD-和-CMD-的区别"><a href="#AMD-和-CMD-的区别" class="headerlink" title="AMD 和 CMD 的区别"></a>AMD 和 CMD 的区别</h3><ul><li>执行时机： AMD 是提前执行，CMD 是延迟执行。</li><li>对依赖的处理：AMD 推崇依赖前置，CMD 推崇依赖就近。</li><li>API 设计理念：AMD 的 API 默认是一个当多个用，非常灵活，CMD 的 API 严格区分，推崇职责单一。</li><li>遵循的规范：RequireJS 遵循的是 Modules&#x2F;AMD 规范，SeaJS 遵循的是 Mdoules&#x2F;Wrappings 规范的 define 形式。</li><li>设计理念：SeaJS 设计理念是 focus on web, 努力成为浏览器端的模块加载器，RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino &#x2F; Node 等环境的模块加载器。</li></ul><h3 id="CommonJS-和-ES-Module-的区别"><a href="#CommonJS-和-ES-Module-的区别" class="headerlink" title="CommonJS 和 ES Module 的区别"></a>CommonJS 和 ES Module 的区别</h3><ul><li>加载时机：CommonJS 是运行时加载（动态加载），ES Module 是编译时加载（静态加载）</li><li>加载模块：CommonJS 模块就是对象，加载的是该对象，ES Module 模块不是对象，加载的不是对象，是接口</li><li>加载结果：CommonJS 加载的是整个模块，即将所有的接口全部加载进来，ES Module 可以单独加载其中的某个接口（方法）</li><li>输出：CommonJS 输出值的拷贝，ES Module 输出值的引用</li><li>this: CommonJS 指向当前模块，ES Module 指向 undefined</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.cn/post/6844903826600755214" title="https://juejin.cn/post/6844903826600755214">JavaScript 模块化总结</a></li><li><a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/?search=import&x=0&y=0%23docs/module" title="https://es6.ruanyifeng.com/?search=import&amp;x=0&amp;y=0#docs/module">Module 的语法-阮一峰</a></li><li><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import" title="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import">import-MDN</a></li><li><a href="https://link.juejin.cn/?target=http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" title="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">Javascript模块化编程（一）：模块的写法-阮一峰</a></li></ul><p>作者：MW530<br>链接：<a href="https://juejin.cn/post/7116775733887762445">https://juejin.cn/post/7116775733887762445</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;谈谈你对模块化开发的理解？&quot;&gt;&lt;a href=&quot;#谈谈你对模块化开发的理解？&quot; class=&quot;headerlink&quot; title=&quot;谈谈你对模块化开发的理解？&quot;&gt;&lt;/a&gt;谈谈你对模块化开发的理解？&lt;/h2&gt;&lt;p&gt;我对模块的理解是，一个模块是实现一个特定功能的一组方</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="https://superq314.github.io/2022/07/13/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://superq314.github.io/2022/07/13/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2022-07-13T13:03:21.902Z</published>
    <updated>2022-07-18T15:06:12.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js-的节流与防抖"><a href="#js-的节流与防抖" class="headerlink" title="js 的节流与防抖"></a>js 的节流与防抖</h2><p><strong>函数防抖</strong> 是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p><p><strong>函数节流</strong> 是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 函数防抖的实现</span><br><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">  var timer = null;</span><br><span class="line">  return **function() &#123;</span><br><span class="line">    var context = this,</span><br><span class="line">        args = arguments;</span><br><span class="line">  </span><br><span class="line">    // 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br><span class="line">    if (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = null;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    // 设置定时器，使事件间隔指定事件后执行</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数节流的实现</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  var preTime = Date.now();</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context = this,</span><br><span class="line">        args = arguments,</span><br><span class="line">        nowTime = Date.now();</span><br><span class="line">  </span><br><span class="line">    // 如果两次时间间隔超过了指定时间，则执行函数</span><br><span class="line">    if (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      preTime = Date.now();</span><br><span class="line">      return fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://juejin.cn/post/6844903535125987335" title="https://juejin.cn/post/6844903535125987335">《轻松理解 JS 函数节流和函数防抖》</a><br><a href="https://juejin.cn/post/6844903575663935496" title="https://juejin.cn/post/6844903575663935496">《JavaScript 事件节流和事件防抖》</a><br><a href="https://juejin.cn/post/6844903618827517965" title="https://juejin.cn/post/6844903618827517965">《JS 的防抖与节流》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;js-的节流与防抖&quot;&gt;&lt;a href=&quot;#js-的节流与防抖&quot; class=&quot;headerlink&quot; title=&quot;js 的节流与防抖&quot;&gt;&lt;/a&gt;js 的节流与防抖&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;函数防抖&lt;/strong&gt; 是指在事件被触发 n 秒后再执行回调，如</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://superq314.github.io/2022/07/13/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://superq314.github.io/2022/07/13/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-07-13T13:02:33.100Z</published>
    <updated>2022-07-19T09:19:05.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。</p><h3 id="2-设计原则"><a href="#2-设计原则" class="headerlink" title="2. 设计原则"></a>2. 设计原则</h3><p><strong>S – Single Responsibility Principle 单一职责原则</strong><br>o 一个程序只做好一件事<br>o 如果功能过于复杂就拆分开，每个部分保持独立</p><p><strong>O – OpenClosed Principle 开放&#x2F;封闭原则</strong><br>o 对扩展开放，对修改封闭<br>o 增加需求时，扩展新代码，而非修改已有代码</p><p><strong>L – Liskov Substitution Principle 里氏替换原则</strong><br>o 子类能覆盖父类<br>o 父类能出现的地方子类就能出现</p><p><strong>I – Interface Segregation Principle 接口隔离原则</strong><br>o 保持接口的单一独立<br>o 类似单一职责原则，这里更关注接口</p><p><strong>D – Dependency Inversion Principle 依赖倒转原则</strong><br>o 面向接口编程，依赖于抽象而不依赖于具<br>o 使用方只关注接口而不关注具体类的实现</p><h3 id="3-设计模式的类型"><a href="#3-设计模式的类型" class="headerlink" title="3. 设计模式的类型"></a>3. 设计模式的类型</h3><ol><li><strong>结构型模式（</strong>Structural Patterns<strong>）：</strong> 通过识别系统中组件间的简单关系来简化系统的设计。</li><li><strong>创建型模式（</strong>Creational Patterns<strong>）：</strong> 处理对象的创建，根据实际情况使用合适的方式创建对象。常规的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。</li><li><strong>行为型模式（</strong>Behavioral Patterns<strong>）：</strong> 用于识别对象之间常见的交互模式并加以实现，如此，增加了这些交互的灵活性。</li></ol><h2 id="9种前端常见的设计模式"><a href="#9种前端常见的设计模式" class="headerlink" title="9种前端常见的设计模式"></a>9种前端常见的设计模式</h2><h3 id="1-外观模式（Facade-Pattern）"><a href="#1-外观模式（Facade-Pattern）" class="headerlink" title="1. 外观模式（Facade Pattern）"></a>1. 外观模式（Facade Pattern）</h3><p>外观模式是最常见的设计模式之一，它为子系统中的一组接口提供一个统一的高层接口，使子系统更容易使用。简而言之外观设计模式就是把多个子系统中复杂逻辑进行抽象，从而提供一个更统一、更简洁、更易用的API。很多我们常用的框架和库基本都遵循了外观设计模式，比如JQuery就把复杂的原生DOM操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。其实在平时工作中我们也会经常用到外观模式进行开发，只是我们不自知而已。</p><ol><li>兼容浏览器事件绑定</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let addMyEvent = function (el, ev, fn) &#123;  </span><br><span class="line">  if (el.addEventListener) &#123;</span><br><span class="line">    el.addEventListener(ev, fn, false)</span><br><span class="line">  &#125; else if (el.attachEvent) &#123;</span><br><span class="line">    el.attachEvent(&#x27;on&#x27; + ev, fn)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    el[&#x27;on&#x27; + ev] = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>封装接口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myEvent = &#123;</span><br><span class="line">  // ...   </span><br><span class="line">  stop: e =&gt; &#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>场景</strong><br>· 设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观Facade<br>· 在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。<br>· 在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观Facade也是非常合适的，为系系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互，Facade与遗留代码交互所有的复杂工作。</p><p><strong>优点</strong><br>· 减少系统相互依赖。<br>· 提高灵活性。<br>· 提高了安全性</p><p><strong>缺点</strong><br>· 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p><h3 id="2-代理模式（Proxy-Pattern）"><a href="#2-代理模式（Proxy-Pattern）" class="headerlink" title="2. 代理模式（Proxy Pattern）"></a>2. 代理模式（Proxy Pattern）</h3><p>是为一个对象提供一个代用品或占位符，以便控制对它的访问</p><blockquote><p>假设当A 在心情好的时候收到花，小明表白成功的几率有60%，而当A 在心情差的时候收到花，小明表白的成功率无限趋近于0。 小明跟A 刚刚认识两天，还无法辨别A 什么时候心情好。如果不合时宜地把花送给A，花 被直接扔掉的可能性很大，这束花可是小明吃了7 天泡面换来的。 但是A 的朋友B 却很了解A，所以小明只管把花交给B，B 会监听A 的心情变化，然后选 择A 心情好的时候把花转交给A，代码如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let Flower = function() &#123;&#125;</span><br><span class="line">let xiaoming = &#123;</span><br><span class="line">  sendFlower: function(target) &#123;</span><br><span class="line">    let flower = new Flower()</span><br><span class="line">    target.receiveFlower(flower)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let B = &#123;</span><br><span class="line">  receiveFlower: function(flower) &#123;</span><br><span class="line">    A.listenGoodMood(**function() &#123;</span><br><span class="line">      A.receiveFlower(flower)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let A = &#123;</span><br><span class="line">  receiveFlower: function(flower) &#123;</span><br><span class="line">    console.log(&#x27;收到花&#x27;+ flower)</span><br><span class="line">  &#125;,</span><br><span class="line">  listenGoodMood: function(fn) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      fn()</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xiaoming.sendFlower(B)</span><br></pre></td></tr></table></figure><p><strong>场景</strong></p><ul><li>HTML元 素事件代理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;ul&quot;&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let ul = document.querySelector(&#x27;#ul&#x27;);</span><br><span class="line">  ul.addEventListener(&#x27;click&#x27;, event =&gt; &#123;</span><br><span class="line">    console.log(event.target);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>ES6 的 proxy <a href="https://link.juejin.cn/?target=https://es6.ruanyifeng.com/%23docs/proxy" title="https://es6.ruanyifeng.com/#docs/proxy">阮一峰<strong>Proxy</strong></a></li><li>jQuery.proxy()方法</li></ul><p><strong>优点</strong></p><ul><li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；<br><strong>缺点</strong></li><li>处理请求速度可能有差别，非直接访问存在开销</li></ul><h3 id="3-工厂模式（Factory-Pattern）"><a href="#3-工厂模式（Factory-Pattern）" class="headerlink" title="3. 工厂模式（Factory Pattern）"></a>3. 工厂模式（Factory Pattern）</h3><p><a href="https://segmentfault.com/a/1190000021247238">JavaScript设计模式第2篇：工厂模式 - SegmentFault 思否</a></p><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    console.log(&#x27;init&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  fun() &#123;</span><br><span class="line">    console.log(&#x27;fun&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Factory &#123;</span><br><span class="line">  create(name) &#123;</span><br><span class="line">    return new Product(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// use</span><br><span class="line">let factory = new Factory()</span><br><span class="line">let p = factory.create(&#x27;p1&#x27;)</span><br><span class="line">p.init()</span><br><span class="line">p.fun()</span><br></pre></td></tr></table></figure><p><strong>场景</strong><br>· 如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择<br>· 将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；<br>· 需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</p><p><strong>优点</strong><br>· 创建对象的过程可能很复杂，但我们只需要关心创建结果。<br>· 构造函数和创建者分离, 符合“开闭原则”<br>· 一个调用者想创建一个对象，只要知道其名称就可以了。<br>· 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</p><p><strong>缺点</strong><br>· 添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度<br>· 考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</p><p><strong>什么时候不用</strong><br>· 当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。<br>· 由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。</p><h3 id="4-单例模式（Singleton-Pattern）"><a href="#4-单例模式（Singleton-Pattern）" class="headerlink" title="4. 单例模式（Singleton Pattern）"></a>4. 单例模式（Singleton Pattern）</h3><p><a href="https://segmentfault.com/a/1190000021101281">JavaScript设计模式第1篇：单例模式 - SegmentFault 思否</a></p><blockquote><p>单个Class中最多只有一个实例，并提供一个访问它的全局访问点。</p><p>当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。</p><p>而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。</p></blockquote><p>实现方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 单例构造器</span><br><span class="line">const FooServiceSingleton = (function () &#123;</span><br><span class="line">  // 隐藏的Class的构造函数</span><br><span class="line">  function FooService() &#123;&#125;</span><br><span class="line">  // 未初始化的单例对象</span><br><span class="line">  let fooService;</span><br><span class="line">  return &#123;</span><br><span class="line">    // 创建/获取单例对象的函数</span><br><span class="line">    getInstance: function () &#123;</span><br><span class="line">      if (!fooService) &#123;</span><br><span class="line">        fooService = new FooService();</span><br><span class="line">      &#125;</span><br><span class="line">      return fooService;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>实现的关键点有：</p><ol><li>使用 IIFE创建局部作用域并即时执行；</li><li>**getInstance() **为一个闭包，使用闭包保存局部作用域中的单例对象并返回。</li></ol><p>我们可以验证下单例对象是否创建成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const fooService1 = FooServiceSingleton.getInstance();</span><br><span class="line">const fooService2 = FooServiceSingleton.getInstance();</span><br><span class="line">console.log(fooService1 === fooService2); // true</span><br></pre></td></tr></table></figure><p><strong>场景例子</strong><br>· 定义命名空间和实现分支型方法<br>· 登录框<br>· vuex 和 redux中的store</p><p><strong>优点</strong><br>· 划分命名空间，减少全局变量<br>· 增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护<br>· 只会实例化一次。简化了代码的调试和维护</p><p><strong>缺点</strong><br>· 由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合<br>· 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一<br>· 个单元一起测试。</p><h3 id="5-策略模式（Strategy-Pattern）"><a href="#5-策略模式（Strategy-Pattern）" class="headerlink" title="5. 策略模式（Strategy Pattern）"></a>5. 策略模式（Strategy Pattern）</h3><p>简单描述：对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。把它们一个个封装起来，并且使它们可以互相替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;策略模式-校验表单&lt;/title&gt;</span><br><span class="line">  &lt;meta content=&quot;text/html&quot; charset=&quot;utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;form id = &quot;registerForm&quot; method=&quot;post&quot; action=&quot;http://xxxx.com/api/register&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt;</span><br><span class="line">    密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;</span><br><span class="line">    手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 策略对象</span><br><span class="line">    const strategies = &#123;</span><br><span class="line">      isNoEmpty: function (value, errorMsg) &#123;</span><br><span class="line">        if (value === &#x27;&#x27;) &#123;</span><br><span class="line">          return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      isNoSpace: function (value, errorMsg) &#123;</span><br><span class="line">        if (value.trim() === &#x27;&#x27;) &#123;</span><br><span class="line">          return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      minLength: function (value, errorMsg, lens) &#123;</span><br><span class="line">        if (value.trim().length &lt; lens) &#123;</span><br><span class="line">          return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      maxLength: function (value, errorMsg, lens) &#123;</span><br><span class="line">        if (value.length &gt; lens) &#123;</span><br><span class="line">          return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      isMobile: function (value, errorMsg) &#123;</span><br><span class="line">        if (!/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$/.test(value)) &#123;</span><br><span class="line">          return errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 验证类</span><br><span class="line">    class Validator &#123;</span><br><span class="line">      constructor() &#123;</span><br><span class="line">        this.cache = [];</span><br><span class="line">      &#125;</span><br><span class="line">      add(dom, rules) &#123;</span><br><span class="line">        for(let i = 0, rule; rule = rules[i++];) &#123;</span><br><span class="line">          let strategyAry = rule.strategy.split(&#x27;:&#x27;);</span><br><span class="line">          let errorMsg = rule.errorMsg;</span><br><span class="line">          this.cache.push(() =&gt; &#123;</span><br><span class="line">            let strategy = strategyAry.shift();</span><br><span class="line">            strategyAry.unshift(dom.value);</span><br><span class="line">            strategyAry.push(errorMsg);</span><br><span class="line">            return strategies[strategy].apply(dom, strategyAry);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      start() &#123;</span><br><span class="line">        for(let i = 0, validatorFunc; validatorFunc = this.cache[i++];) &#123;</span><br><span class="line">          let errorMsg = validatorFunc();</span><br><span class="line">          if (errorMsg) &#123;</span><br><span class="line">            return errorMsg;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用代码(尝试使用)</span><br><span class="line">    let registerForm = document.getElementById(&#x27;registerForm&#x27;);</span><br><span class="line">    let validataFunc = function() &#123;</span><br><span class="line">      let validator = new Validator();</span><br><span class="line">      validator.add(registerForm.userName, [&#123;</span><br><span class="line">        strategy: &#x27;isNoEmpty&#x27;,</span><br><span class="line">        errorMsg: &#x27;用户名不能为空&#x27;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        strategy: &#x27;isNoSpace&#x27;,</span><br><span class="line">        errorMsg: &#x27;密码不能为空&#x27;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        strategy: &#x27;minLength:2&#x27;,</span><br><span class="line">        errorMsg: &#x27;用户名长度不能小于2位&#x27;</span><br><span class="line">      &#125;]);</span><br><span class="line"></span><br><span class="line">      validator.add(registerForm.password, [ &#123;</span><br><span class="line">        strategy: &#x27;minLength:6&#x27;,</span><br><span class="line">        errorMsg: &#x27;密码长度不能小于6位&#x27;</span><br><span class="line">      &#125;]);</span><br><span class="line"></span><br><span class="line">      validator.add(registerForm.phoneNumber, [&#123;</span><br><span class="line">        strategy: &#x27;isMobile&#x27;,</span><br><span class="line">        errorMsg: &#x27;请输入正确的手机号码格式&#x27;</span><br><span class="line">      &#125;]);</span><br><span class="line"></span><br><span class="line">      return validator.start();</span><br><span class="line">    &#125;</span><br><span class="line">    registerForm.onsubmit = function() &#123;</span><br><span class="line">      let errorMsg = validataFunc();</span><br><span class="line">      if (errorMsg) &#123;</span><br><span class="line">        alert(errorMsg);</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>场景例子</strong><br>· 如果在一个系统里面有许多类，它们之间的区别仅在于它们的’行为’，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。<br>· 一个系统需要动态地在几种算法中选择一种。<br>· 表单验证</p><p><strong>优点</strong><br>· 利用组合、委托、多态等技术和思想，可以有效的避免多重条件选择语句<br>· 提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，理解，易于扩展<br>· 利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的代替方案</p><p><strong>缺点</strong><br>· 会在程序中增加许多策略类或者策略对象<br>· 要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy</p><h3 id="6-迭代器模式（Iterator-Pattern）"><a href="#6-迭代器模式（Iterator-Pattern）" class="headerlink" title="6. 迭代器模式（Iterator Pattern）"></a>6. 迭代器模式（Iterator Pattern）</h3><p>如果你看到这，ES6中的迭代器 Iterator 相信你还是有点印象的，上面第60条已经做过简单的介绍。迭代器模式简单的说就是提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><p>迭代器模式解决了以下问题：<br>· 提供一致的遍历各种数据结构的方式，而不用了解数据的内部结构<br>· 提供遍历容器（集合）的能力而无需改变容器的接口</p><p>一个迭代器通常需要实现以下接口：<br>· hasNext()：判断迭代是否结束，返回Boolean<br>· next()：查找并返回下一个元素</p><p>为Javascript的数组实现一个迭代器可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const item = [1, &#x27;red&#x27;, false, 3.14];</span><br><span class="line"></span><br><span class="line">function Iterator(items) &#123;</span><br><span class="line">  this.items = items;</span><br><span class="line">  this.index = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator.prototype = &#123;</span><br><span class="line">  hasNext: function () &#123;</span><br><span class="line">    return this.index &lt; this.items.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  next: function () &#123;</span><br><span class="line">    return this.items[this.index++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下迭代器是否工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const iterator = new Iterator(item);</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">  console.log(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line">//输出：1, red, false, 3.14</span><br></pre></td></tr></table></figure><p>ES6提供了更简单的迭代循环语法 for…of，使用该语法的前提是操作对象需要实现 可迭代协议（The iterable protocol），简单说就是该对象有个Key为 Symbol.iterator 的方法，该方法返回一个iterator对象。</p><p>比如我们实现一个 Range 类用于在某个数字区间进行迭代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Range(start, end) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    [Symbol.iterator]: function () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        next() &#123;</span><br><span class="line">          if (start &lt; end) &#123;</span><br><span class="line">            return &#123; value: start++, done: false &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          return &#123; done: true, value: end &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (num of Range(1, 5)) &#123;</span><br><span class="line">  console.log(num);</span><br><span class="line">&#125;// 输出：1, 2, 3, 4</span><br></pre></td></tr></table></figure><h3 id="7-观察者模式（Observer-Pattern）即发布-x2F-订阅模式"><a href="#7-观察者模式（Observer-Pattern）即发布-x2F-订阅模式" class="headerlink" title="7. 观察者模式（Observer Pattern）即发布&#x2F;订阅模式"></a>7. 观察者模式（Observer Pattern）即发布&#x2F;订阅模式</h3><p>日常生活中的应用也比比皆是，比如：订阅某个博主的频道，当有内容更新时会收到推送；又比如JavaScript中的事件订阅响应机制。</p><p>观察者模式的思想用一句话描述就是： <strong>被观察对象（</strong>subject<strong>）维护一组观察者（observer），当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者</strong> 。</p><p>观察者模式中Subject对象一般需要实现以下API：</p><ul><li>subscribe()：接收一个观察者observer对象，使其订阅自己</li><li>unsubscribe()：接收一个观察者observer对象，使其取消订阅自己</li><li>ire()：触发事件，通知到所有观察者</li></ul><p>用JavaScript手动实现观察者模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 被观察者</span><br><span class="line">function Subject() &#123;</span><br><span class="line">  this.observers = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Subject.prototype = &#123;</span><br><span class="line">  // 订阅</span><br><span class="line">  subscribe: function (observer) &#123;</span><br><span class="line">    this.observers.push(observer);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 取消订阅</span><br><span class="line">  unsubscribe: function (observerToRemove) &#123;</span><br><span class="line">    this.observers = this.observers.filter(observer =&gt; &#123;</span><br><span class="line">      return observer !== observerToRemove;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 事件触发</span><br><span class="line">  fire: function () &#123;</span><br><span class="line">    this.observers.forEach(observer =&gt; &#123;</span><br><span class="line">      observer.call();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>验证一下订阅是否成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const subject = new Subject();</span><br><span class="line">function observer1() &#123;</span><br><span class="line">  console.log(&#x27;Observer 1 Firing!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function observer2() &#123;</span><br><span class="line">  console.log(&#x27;Observer 2 Firing!&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.subscribe(observer1);</span><br><span class="line">subject.subscribe(observer2);</span><br><span class="line">subject.fire();</span><br><span class="line"></span><br><span class="line">//输出：</span><br><span class="line">Observer 1 Firing! </span><br><span class="line">Observer 2 Firing!</span><br></pre></td></tr></table></figure><p>验证一下取消订阅是否成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subject.unsubscribe(observer2);</span><br><span class="line">subject.fire();</span><br><span class="line">//输出：</span><br><span class="line">Observer 1 Firing!</span><br></pre></td></tr></table></figure><p><strong>场景</strong><br>· DOM事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&#x27;click&#x27;, function() &#123;</span><br><span class="line">    console.log(&#x27;hello world!&#x27;);</span><br><span class="line">&#125;);document.body.click()</span><br></pre></td></tr></table></figure><p>· vue 响应式<br><strong>优点</strong></p><ul><li>支持简单的广播通信，自动通知所有已经订阅过的对象</li><li>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用</li><li>增加了灵活性</li><li>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</li></ul><p><strong>缺点</strong></p><blockquote><p>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</p></blockquote><h3 id="8-中介者模式（Mediator-Pattern）"><a href="#8-中介者模式（Mediator-Pattern）" class="headerlink" title="8. 中介者模式（Mediator Pattern）"></a>8. 中介者模式（Mediator Pattern）</h3><p>在中介者模式中，中介者（Mediator）包装了一系列对象相互作用的方式，使得这些对象不必直接相互作用，而是由中介者协调它们之间的交互，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。</p><p>中介者模式和观察者模式有一定的相似性，都是一对多的关系，也都是集中式通信，不同的是中介者模式是处理同级对象之间的交互，而观察者模式是处理Observer和Subject之间的交互。中介者模式有些像婚恋中介，相亲对象刚开始并不能直接交流，而是要通过中介去筛选匹配再决定谁和谁见面。</p><p><strong>场景</strong></p><blockquote><p>例如购物车需求，存在商品选择表单、颜色选择表单、购买数量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事件，实现各个事件间的解耦，仅仅维护中介者对象即可。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var goods = &#123;   </span><br><span class="line">    //手机库存</span><br><span class="line">    &#x27;red|32G&#x27;: 3,</span><br><span class="line">    &#x27;red|64G&#x27;: 1,</span><br><span class="line">    &#x27;blue|32G&#x27;: 7,</span><br><span class="line">    &#x27;blue|32G&#x27;: 6,</span><br><span class="line">&#125;;</span><br><span class="line">//中介者</span><br><span class="line">var mediator = (function() &#123;</span><br><span class="line">    var colorSelect = document.getElementById(&#x27;colorSelect&#x27;);</span><br><span class="line">    var memorySelect = document.getElementById(&#x27;memorySelect&#x27;);</span><br><span class="line">    var numSelect = document.getElementById(&#x27;numSelect&#x27;);</span><br><span class="line">    return &#123;</span><br><span class="line">        changed: function(obj) &#123;</span><br><span class="line">            switch(obj)&#123;</span><br><span class="line">                case colorSelect:</span><br><span class="line">                    //TODO</span><br><span class="line">                    break;</span><br><span class="line">                case memorySelect:</span><br><span class="line">                    //TODO</span><br><span class="line">                    break;</span><br><span class="line">                case numSelect:</span><br><span class="line">                    //TODO</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">colorSelect.onchange = function() &#123;</span><br><span class="line">    mediator.changed(this);</span><br><span class="line">&#125;;</span><br><span class="line">memorySelect.onchange = function() &#123;</span><br><span class="line">    mediator.changed(this);</span><br><span class="line">&#125;;</span><br><span class="line">numSelect.onchange = function() &#123;</span><br><span class="line">    mediator.changed(this);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>· 聊天室里</p><p>聊天室成员类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Member(name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.chatroom = null;</span><br><span class="line">&#125;</span><br><span class="line">Member.prototype = &#123;</span><br><span class="line">  // 发送消息</span><br><span class="line">  send: function (message, toMember) &#123;</span><br><span class="line">    this.chatroom.send(message, this, toMember);</span><br><span class="line">  &#125;,</span><br><span class="line">  // 接收消息</span><br><span class="line">  receive: function (message, fromMember) &#123;</span><br><span class="line">    console.log(`$&#123;fromMember.name&#125; to $&#123;this.name&#125;: $&#123;message&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聊天室类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Chatroom() &#123;</span><br><span class="line">  this.members = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Chatroom.prototype = &#123;</span><br><span class="line">  // 增加成员</span><br><span class="line"> addMember: function (member) &#123;</span><br><span class="line">    this.members[member.name] = member;</span><br><span class="line">    member.chatroom = this;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 发送消息</span><br><span class="line">  send: function (message, fromMember, toMember) &#123;</span><br><span class="line">    toMember.receive(message, fromMember);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const chatroom = new Chatroom();const bruce = new Member(&#x27;bruce&#x27;);const frank = new Member(&#x27;frank&#x27;);</span><br><span class="line">chatroom.addMember(bruce);</span><br><span class="line">chatroom.addMember(frank);</span><br><span class="line">bruce.send(&#x27;Hey frank&#x27;, frank);</span><br><span class="line">//输出：bruce to frank: hello frank</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ul><li>使各对象之间耦合松散，而且可以独立地改变它们之间的交互</li><li>中介者和对象一对多的关系取代了对象之间的网状多对多的关系</li><li>如果对象之间的复杂耦合度导致维护很困难，而且耦合度随项目变化增速很快，就需要中介者重构代码</li></ul><p><strong>缺点</strong></p><blockquote><p>系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象。</p></blockquote><h3 id="9-访问者模式（Visitor-Pattern）"><a href="#9-访问者模式（Visitor-Pattern）" class="headerlink" title="9. 访问者模式（Visitor Pattern）"></a>9. 访问者模式（Visitor Pattern）</h3><p><strong>访问者模式</strong> 是一种将算法与对象结构分离的设计模式，通俗点讲就是：访问者模式让我们能够在不改变一个对象结构的前提下能够给该对象增加新的逻辑，新增的逻辑保存在一个独立的访问者对象中。访问者模式常用于拓展一些第三方的库和工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 访问者  </span><br><span class="line">class Visitor &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">  visitConcreteElement(ConcreteElement) &#123;</span><br><span class="line">    ConcreteElement.operation()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 元素类  </span><br><span class="line">class ConcreteElement &#123;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">  operation() &#123;</span><br><span class="line">    console.log(&quot;ConcreteElement.operation invoked&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  accept(visitor) &#123;</span><br><span class="line">    visitor.visitConcreteElement(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// client</span><br><span class="line">let visitor = new Visitor()</span><br><span class="line">let element = new ConcreteElement()</span><br><span class="line">elementA.accept(visitor)</span><br></pre></td></tr></table></figure><p>访问者模式的实现有以下几个要素：<br>· Visitor Object：访问者对象，拥有一个<strong>visit()<strong>方法<br>· Receiving Object：接收对象，拥有一个</strong> accept()</strong> 方法<br>· visit(receivingObj)：用于Visitor接收一个<strong>Receiving Object</strong><br>· accept(visitor)：用于<strong>Receving Object</strong>接收一个Visitor，并通过调用<strong>Visitor</strong>的<strong>visit()</strong> 为其提供获取<strong>Receiving Object</strong>数据的能力</p><p>简单的代码实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Receiving Object:</span><br><span class="line"></span><br><span class="line">function Employee(name, salary) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee.prototype = &#123;</span><br><span class="line">  getSalary: function () &#123;</span><br><span class="line">    return this.salary;</span><br><span class="line">  &#125;,</span><br><span class="line">  setSalary: function (salary) &#123;</span><br><span class="line">    this.salary = salary;</span><br><span class="line">  &#125;,</span><br><span class="line">  accept: function (visitor) &#123;</span><br><span class="line">    visitor.visit(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Visitor Object：</span><br><span class="line"></span><br><span class="line">function Visitor() &#123; &#125;</span><br><span class="line"></span><br><span class="line">Visitor.prototype = &#123;</span><br><span class="line">  visit: function (employee) &#123;</span><br><span class="line">    employee.setSalary(employee.getSalary() * 2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const employee = new Employee(&#x27;bruce&#x27;, 1000);</span><br><span class="line">const visitor = new Visitor();</span><br><span class="line">employee.accept(visitor);</span><br><span class="line">console.log(employee.getSalary());//输出：2000</span><br></pre></td></tr></table></figure><p><strong>场景</strong><br>· 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作<br>· 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。<br><strong>优点</strong><br>· 符合单一职责原则<br>· 优秀的扩展性<br>· 灵活性</p><p><strong>缺点</strong><br>· 具体元素对访问者公布细节，违反了迪米特原则<br>· 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。<br>· 具体元素变更比较困难</p><p>相关参考资料：<br><a href="https://juejin.cn/post/6844904032826294286" title="https://juejin.cn/post/6844904032826294286">JavaScript设计模式es6（23种)</a><br><a href="https://juejin.cn/book/6844733763675488269/section/6844733763792928776" title="https://juejin.cn/book/6844733763675488269/section/6844733763792928776">《前端面试之道》</a><br><a href="#heading-3" title="https://juejin.cn/post/6844903503266054157#heading-3">《**JavaScript **设计模式》</a><br><a href="https://juejin.cn/post/6844903607452581896" title="https://juejin.cn/post/6844903607452581896">《**JavaScript **中常见设计模式整理》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h2&gt;&lt;h3 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://superq314.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Web APIs</title>
    <link href="https://superq314.github.io/2022/07/12/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/Web-APIs/"/>
    <id>https://superq314.github.io/2022/07/12/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/Web-APIs/</id>
    <published>2022-07-12T12:57:41.314Z</published>
    <updated>2022-07-18T15:11:21.328Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容参考：<a href="https://juejin.cn/post/7118259341060210701#heading-90">JavaScript学习笔记</a></p><p>Web APIs</p><p>JavaScript基础和Web APIs两个阶段的关联性：JS基础学习ECMAScript基础语法为后面做铺垫，Web APIs是JS的应用，大量使用JS基础语法做交互效果</p><p>API 和Web API：</p><p>API （应用程序编程接口），是一些预先定义的函数，目的是提供应用程序与开发人员基于某种软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节（API是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能）</p><p>Web API是<strong>浏览器</strong>提供的一套操作<strong>浏览器功能</strong>和<strong>页面元素</strong>的 <strong>API</strong> （BOM和DOM）</p><p>BOM：浏览器对象模型</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c68bdc64d183490db6f74d4fb85b2cf7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="图片.png"></p><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM：文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言（HTML或XML）的标准<strong>编程接口</strong></p><p>W3C定义了一系列的DOM接口，通过这些DOM接口可改变网页的内容、结构、样式</p><p>DOM中的专有名词：</p><ul><li>文档：一个页面就是一个文档，DOM中使用document表示</li><li>元素：页面中的所有标签都是元素，DOM中使用element表示</li><li>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用node表示</li></ul><p>关于DOM操作，主要针对于元素的操作，主要有创建、增、删、改、查、属性操作、事件操作</p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>DOM中获取页面中元素的几种方式：</p><ul><li>根据ID获取</li><li>根据标签名获取</li><li>通过HTML5新增的方法获取</li><li>特殊元素获取</li></ul><h4 id="根据ID获取-getElementById"><a href="#根据ID获取-getElementById" class="headerlink" title="根据ID获取 getElementById()"></a>根据ID获取 getElementById()</h4><p>getElementById()：匹配特定ID的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 语法</span><br><span class="line">var element = document.getElementById(id);</span><br><span class="line"></span><br><span class="line">// 示例</span><br><span class="line">&lt;div id=&#x27;time&#x27;&gt;2022-6-1&lt;/div&gt;</span><br><span class="line">var timeId = document.getElementById(&#x27;time&#x27;);</span><br><span class="line">console.log(timeId) // &lt;div id=&quot;time&quot;&gt;2022-6-1&lt;/div&gt;</span><br><span class="line">console.dir(timeId)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>返回一个元素对象</li><li>返回值：返回一个匹配到ID的DOM Element对象，若在当前Document下没有找到，则返回null</li><li>console.dir(timeId)：打印返回的元素对象，可更好的查里面的属性和方法</li></ul><h4 id="根据标签名获取-getElementsByTagName"><a href="#根据标签名获取-getElementsByTagName" class="headerlink" title="根据标签名获取 getElementsByTagName()"></a>根据标签名获取 getElementsByTagName()</h4><p>getElementsByTagName()：返回带有指定标签名的 <strong>对象的集合</strong> （以伪数组的形式存储的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">var lis = document.getElementsByTagName(&#x27;li&#x27;); // 选中所有相同的标签</span><br><span class="line">console.log(lis); // 指定标签名的对象合集  以伪数组的方式存储</span><br><span class="line">console.log(lis[0]); // &lt;li&gt;2022-01-01 1&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">// 遍历</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    console.log(lis[i]);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>getElementsByTagName()：获取指定标签名的对象合集，以伪数组的方式存储（可使用数组的部分方法）</li><li>可用for遍历元素对象</li><li>如果页面中只有一个li，返回的依然是伪数组的形式</li><li>如果页面中没有该元素，返回的是一个空的伪数组</li></ul><p>获取某个元素（父元素）内部所有指定标签名的子元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol id=&#x27;ol&#x27;&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2022-01-01 5&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">// 先获取父元素，再获取父元素中的指定标签名</span><br><span class="line">var ol = document.getElementById(&#x27;ol&#x27;)</span><br><span class="line">var ollis = ol.getElementsByTagName(&#x27;li&#x27;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：父元素必须是<strong>单个对象（必须指明是哪一个元素对象）</strong> ，获取的时候不包括父元素自己</p><h4 id="H5新增的方法"><a href="#H5新增的方法" class="headerlink" title="H5新增的方法"></a>H5新增的方法</h4><p>H5新增的方法不兼容IE9以下的浏览器，不考虑兼容性和移动端可放心食用</p><p><strong>getElementsByClassName()：根据类名获取某些元素集合</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;盒子&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;盒子&lt;/div&gt;</span><br><span class="line">var boxs = document.getElementsByClassName(&#x27;box&#x27;);</span><br><span class="line">console.log(boxs); // 伪数组的方式存储</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>querySelector(‘选择器’)：根据指定选择器，返回第一个元素对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;盒子 1&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;盒子 2&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;产品&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 类选择器</span><br><span class="line">var box = document.querySelector(&#x27;.box&#x27;)</span><br><span class="line">console.log(box); // &lt;div class=&quot;box&quot;&gt;盒子 1&lt;/div&gt;</span><br><span class="line">// ID选择器</span><br><span class="line">var nav = document.querySelector(&#x27;#nav&#x27;)</span><br><span class="line">console.log(nav); // </span><br><span class="line">// 标签选择器</span><br><span class="line">var li = document.querySelector(&#x27;li&#x27;)</span><br><span class="line">console.log(li); // &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>querySelectorAll(‘选择器’)：根据指定选择器返回所有元素对象的集合</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;盒子 1&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;盒子 2&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;产品&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 选择所有的.box （类选择器）</span><br><span class="line">var allBox = document.querySelectorAll(&#x27;.box&#x27;);  // 以伪数组的方式存储</span><br><span class="line">var allLi = document.querySelectorAll(&#x27;li&#x27;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="获取body和HTML元素"><a href="#获取body和HTML元素" class="headerlink" title="获取body和HTML元素"></a>获取body和HTML元素</h4><p>获取body元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var body = document.body;</span><br><span class="line">console.log(body);</span><br><span class="line">console.dir(body); // console.dir() 打印返回的元素对象，可更好的查里面的属性和方法</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>获取HTML元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var html = document.documentElement;</span><br><span class="line">console.log(html)      </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="事件基础"><a href="#事件基础" class="headerlink" title="事件基础"></a>事件基础</h3><p>JavaScript可创建动态页面，事件是可被JavaScript侦测到的行为</p><p>事件三要素：</p><ul><li>事件源：被触发的对象（谁触发的事件）</li><li>事件类型：如何触发。比如：鼠标点击，鼠标经过、键盘按下</li><li>事件处理程序：通过函数赋值的方式 完成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.getElementById(&#x27;btn&#x27;)</span><br><span class="line">btn.onclick = function () &#123;</span><br><span class="line">    alert(&#x27;点击&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="常见的鼠标事件"><a href="#常见的鼠标事件" class="headerlink" title="常见的鼠标事件"></a>常见的鼠标事件</h4><table><thead><tr><th>鼠标事件</th><th>触发条件</th></tr></thead><tbody><tr><td><strong>onclick</strong></td><td><strong>鼠标点击左键触发</strong></td></tr><tr><td><strong>onmouseover</strong></td><td><strong>鼠标经过触发</strong></td></tr><tr><td>onmouseout</td><td>鼠标离开触发</td></tr><tr><td><strong>onfocus</strong></td><td><strong>获取鼠标焦点触发</strong></td></tr><tr><td>onblur</td><td>失去鼠标焦点触发</td></tr><tr><td>onmousemove</td><td>鼠标移动触发</td></tr><tr><td>onmouseup</td><td>鼠标弹起触发</td></tr><tr><td>onmousedown</td><td>鼠标按下触发</td></tr></tbody></table><h3 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h3><p>JavaScript的DOM操作可改变网页内容、结构、样式，可利用DOM操作元素来改变元素里面的内容、属性等</p><h4 id="改变元素内容（innerText、innerHTML）"><a href="#改变元素内容（innerText、innerHTML）" class="headerlink" title="改变元素内容（innerText、innerHTML）"></a>改变元素内容（innerText、innerHTML）</h4><p>innerText：修改元素的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 示例：点击获取当前系统时间</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;点击获取当前系统时间&lt;/button&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.getElementById(&#x27;btn&#x27;)</span><br><span class="line">var p = document.querySelector(&#x27;p&#x27;)</span><br><span class="line">btn.onclick = function () &#123;</span><br><span class="line">    p.innerText = getNowDay()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getNowDay() &#123;</span><br><span class="line">    var date = new Date();</span><br><span class="line">    var year = date.getFullYear();</span><br><span class="line">    var month = date.getMonth();</span><br><span class="line">    var dates = date.getDate();</span><br><span class="line">    var day = date.getDay();</span><br><span class="line">    var arr = [&#x27;星期日&#x27;, &#x27;星期一&#x27;, &#x27;星期二&#x27;, &#x27;星期三&#x27;, &#x27;星期四&#x27;, &#x27;星期五&#x27;, &#x27;星期六&#x27;];</span><br><span class="line">    return &#x27;今天是：&#x27; + year + &#x27;年&#x27; + month + &#x27;月&#x27; + dates + &#x27;日 &#x27; + arr[day]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 页面加载就显示时间（不依赖事件）</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">div.innerText = getNowDay()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>共同点：</p><ul><li>innerText和innerHTML都可修改页面内容</li></ul><p>区别：</p><ul><li>innerText 不识别html标签 ， innerHTML识别html标签</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">div.innerText = &#x27;&lt;strong&gt;今天是：&lt;strong&gt;2020年&#x27;; // 不识别html标签，页面会显示&lt;strong&gt;</span><br><span class="line">div.innerHTML = &#x27;&lt;strong&gt;今天是：&lt;strong&gt;2020年&#x27;;// 识别html标签，今天是 加粗显示</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>innerText 非标准（老版本火狐不支持），innerHTML W3C标准（推荐）</li><li>这两个属性可读写（可获取元素里面的内容）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    王权</span><br><span class="line">&lt;span&gt;陈斌&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">console.log(div.innerText); // 王权 陈斌</span><br><span class="line">console.log(div.innerHTML); //  王权  &lt;span&gt;陈斌&lt;/span&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>innerText 去除html标签，同时空格和换行也会去掉</li><li>innerHTML 保留html标签，同时保留空格和换行</li></ul><h4 id="修改元素属性"><a href="#修改元素属性" class="headerlink" title="修改元素属性"></a>修改元素属性</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=204&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=204&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><h4 id="分时问候（案例）"><a href="#分时问候（案例）" class="headerlink" title="分时问候（案例）"></a>分时问候（案例）</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=205&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=205&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><h4 id="修改表单属性"><a href="#修改表单属性" class="headerlink" title="修改表单属性"></a>修改表单属性</h4><p>利用DON可用操作表单元素的属性：</p><p>type、value、checked、selected、disabled</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; value=&quot;输入。。。&quot;&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">var input = document.querySelector(&#x27;input&#x27;)</span><br><span class="line">btn.onclick = function () &#123;</span><br><span class="line">    input.value = &#x27;999&#x27;;</span><br><span class="line">    // this指向事件函数的调用者 btn</span><br><span class="line">    // disabled 被点击之后，不能再使用</span><br><span class="line">    this.disabled = true</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="样式属性操作"><a href="#样式属性操作" class="headerlink" title="样式属性操作"></a>样式属性操作</h4><p>可通过JavaScript修改元素的大小、颜色、位置等样式</p><p>element. <strong>style</strong> ：<strong>行内样式操作</strong></p><p>element. <strong>className</strong> ：<strong>类名样式操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// element.style：行内样式操作</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">// 鼠标经过时的样式</span><br><span class="line">div.onmouseover = function () &#123;</span><br><span class="line">    // div.style.backgroundColor = &#x27;#f90&#x27; // 可用this this指向事件函数的调用者</span><br><span class="line">    this.style.backgroundColor = &#x27;#f90&#x27;</span><br><span class="line">    this.style.width = &#x27;500px&#x27;</span><br><span class="line">&#125;</span><br><span class="line">// 鼠标离开时的样式</span><br><span class="line">div.onmouseout = function () &#123;</span><br><span class="line">    this.style.backgroundColor = &#x27;red&#x27;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>JS里面的样式采用驼峰命名法。比如：backgroundColor、fontSize</li><li>js修改style样式操作，产生的是行内样式，权重比较高</li><li>如果样式少，或者简单的情况下使用（多的情况下，使用className）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> // element.className：类名样式操作</span><br><span class="line">.change&#123;</span><br><span class="line">    background-color:#f90;</span><br><span class="line">    width:500px;</span><br><span class="line">    height: 500px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&#x27;div-style&#x27;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">// 鼠标经过时的样式</span><br><span class="line">div.onmouseover = function () &#123;</span><br><span class="line">   this.className = &#x27;change&#x27;; // 可以理解为：给他添加个类名</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>可以理解为：提前写好样式，给他添加个这个类名</li><li>适合样式多或功能负责的情况</li><li>className 会直接更改元素的类名，会覆盖原先的类名，如果想要保留原先的类名，做法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.className = &#x27;原先的类名  改变后的类名&#x27;</span><br><span class="line">this.className = &#x27;div-style  change&#x27;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h4 id="操作元素总结"><a href="#操作元素总结" class="headerlink" title="操作元素总结"></a>操作元素总结</h4><p>操作元素：</p><ul><li>操作元素内容<ul><li>innerText</li><li>innerHTML</li></ul></li><li>操作常见元素属性<ul><li>src、href、title、alt等</li></ul></li><li>操作表单元素属性<ul><li>type、value、disabled等</li></ul></li><li>操作元素样式属性<ul><li>element.style</li><li>className</li></ul></li></ul><h4 id="全选与取消全选（案例）"><a href="#全选与取消全选（案例）" class="headerlink" title="全选与取消全选（案例）"></a>全选与取消全选（案例）</h4><p>案例分析：</p><p>1、全选取消全选的做法：让下面的复选框的checked属性 跟随 全选按钮即可（循环下面的复选框，将其checked属性改为和全选按钮一样）</p><p>2、下面的复选框需要全部选中，上面的全选才能选中：给下面的所有复选框绑定点击事件，每次点击，都要循环一下查看下面所有的复选框是否都选中，如果存在一个没选选中，则全选按钮不选中。设置一个变量，来控制是否选中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">全选：&lt;input type=&quot;checkbox&quot;&gt;</span><br><span class="line">&lt;div id=&quot;checkboxContent&quot;&gt;</span><br><span class="line">    篮球&lt;input type=&quot;checkbox&quot;&gt;</span><br><span class="line">    足球&lt;input type=&quot;checkbox&quot;&gt;</span><br><span class="line">    排球&lt;input type=&quot;checkbox&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var allCheckbox = document.querySelector(&#x27;input&#x27;)</span><br><span class="line">// 选择ID为checkboxContent下所有的input标签的元素集合</span><br><span class="line">var inputs = document.getElementById(&#x27;checkboxContent&#x27;).getElementsByTagName(&#x27;input&#x27;)</span><br><span class="line"></span><br><span class="line">// 当全选框选中时，其他的复选框全部选中</span><br><span class="line">allCheckbox.onclick = function () &#123;</span><br><span class="line">    // this.checked 复选框是选中状态为true，未选中为fasle</span><br><span class="line">    // this指向调用事件函数的allCheckbox</span><br><span class="line">    // console.log(this.checked);</span><br><span class="line">    for (var i = 0; i &lt; inputs.length; i++) &#123;</span><br><span class="line">        // 循环其他的复选框，把其它的状态改为和全选的状态一样</span><br><span class="line">        inputs[i].checked = this.checked; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 给下面的所有复选框绑定点击事件，每次点击，都要循环一下查看下面所有的复选框是否都选中，如果存在一个没选中，则全选按钮不选中</span><br><span class="line">// 变量 flag 控制全选按钮是否选中</span><br><span class="line">for (var i = 0; i &lt; inputs.length; i++) &#123;</span><br><span class="line">    inputs[i].onclick = function () &#123;</span><br><span class="line">        // flag 控制全选按钮是否选中</span><br><span class="line">        var flag = true;</span><br><span class="line">        // 每次点击下面的复选框，都要循环检查其他的按钮是否全被选中</span><br><span class="line">        for (var i = 0; i &lt; inputs.length; i++) &#123;</span><br><span class="line">            if (!inputs[i].checked) &#123;</span><br><span class="line">                flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        allCheckbox.checked = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="获取自定义属性值-getAttribute"><a href="#获取自定义属性值-getAttribute" class="headerlink" title="获取自定义属性值 getAttribute()"></a>获取自定义属性值 getAttribute()</h4><p>自定义属性：程序员自己添加的属性，称为自定义属性</p><p>获取元素的属性值：</p><ul><li>element.属性</li><li>element.getAttribute(‘属性’)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;div id=&#x27;demo&#x27;&gt;&lt;div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">console.log(div.id); // demo </span><br><span class="line">console.log(div.getAttribute(&#x27;id&#x27;)); // demo</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>区别：</p><ul><li>element.属性：获取内置属性值（元素本身自带的属性）</li><li>element.getAttribute(‘属性’)：主要获取自定义的属性（标准的），程序员自定义的属性</li></ul><h4 id="自定义属性的操作（设置、移除属性）"><a href="#自定义属性的操作（设置、移除属性）" class="headerlink" title="自定义属性的操作（设置、移除属性）"></a>自定义属性的操作（设置、移除属性）</h4><p><strong>设置属性的值</strong></p><ul><li>element.属性 &#x3D; ‘值’ 设置内置属性值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;div id=&#x27;demo&#x27; class=&#x27;div1&#x27; index=&#x27;1&#x27; &gt;&lt;div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">div.id = &#x27;test&#x27;;</span><br><span class="line">div.className = &#x27;test1&#x27;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li>element.setAttribute(‘属性’, ‘值’) ：主要针对自定义属性<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;div id=&#x27;demo&#x27; class=&#x27;div1&#x27; index=&#x27;1&#x27; &gt;&lt;div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">div.setAttribute(&#x27;index&#x27;, 2);</span><br><span class="line">div.setAttribute(&#x27;class&#x27;, &#x27;footer&#x27;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>移除属性 removeAttribute(属性)：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.removeAttribute(&#x27;index&#x27;)</span><br><span class="line">// 移除后</span><br><span class="line">&lt;div id=&#x27;demo&#x27; class=&#x27;div1&#x27; &gt;&lt;div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="tab栏切换（案例）"><a href="#tab栏切换（案例）" class="headerlink" title="tab栏切换（案例）"></a>tab栏切换（案例）</h4><p>案例分析：</p><p>1、tab切换有两个大模块</p><p>2、上面的模块选项卡，点击某一个，当前这个的背景颜色变成红色，其余的不变，可用修改类名的方式</p><p>3、下面的模块内容，会随着上面的选项卡变化而变化，所以下面的模块变化写在点击事件里面</p><p>4、规律：下面的模块显示内容和上面的选项卡一一对应，相匹配</p><p>5、核心思路：给上面的tab_list里面的所有小li添加自定义属性（setAttribute），属性值从0开始编号</p><p>6、当点击tab_list里面的某个小li，让tab_con里面对应序号的内容显示，其余隐藏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;tab_list&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li class=&quot;current&quot;&gt;1&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;tab_con&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;display: block;&quot;&gt;111&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;222&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;333&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;444&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;555&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var tab_list = document.querySelector(&#x27;.tab_list&#x27;);</span><br><span class="line">var lis = tab_list.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">var items = document.querySelector(&#x27;.tab_con&#x27;).querySelectorAll(&#x27;div&#x27;)</span><br><span class="line">// 循环绑定事件</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    // 给五个li设置索引号 </span><br><span class="line">    lis[i].setAttribute(&#x27;data-index&#x27;, i)</span><br><span class="line">    lis[i].onclick = function () &#123;</span><br><span class="line">        // 上面的模块选项卡，点击某一个，当前这个的背景颜色变成红色，其余的不变，可用修改类名的方式</span><br><span class="line">        for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">            // 清除所有li的class 这个类</span><br><span class="line">            lis[i].className = &#x27;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 只留下当前点击的那个，给他添加上类（样式）</span><br><span class="line">        this.className = &#x27;current&#x27;;</span><br><span class="line"></span><br><span class="line">        // 点击切换时，显示的内容模块</span><br><span class="line">        var index = this.getAttribute(&#x27;data-index&#x27;)</span><br><span class="line">        // 先把所有的隐藏</span><br><span class="line">        for (var i = 0; i &lt; items.length; i++) &#123;</span><br><span class="line">            items[i].style.display = &#x27;none&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        // 只留下当前的要显示的内容（和上对应的内容）</span><br><span class="line">        items[index].style.display = &#x27;block&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="H5自定义属性"><a href="#H5自定义属性" class="headerlink" title="H5自定义属性"></a>H5自定义属性</h4><p>自定义属性的目的：为了保存并使用数据，有些数据可保存到页面中，不必保存到数据库中</p><p>自定义属性获取属性是通过：getAttribute(‘属性’)</p><p>但是有些自定义属性很容易引起歧义，不容易判断元素是内置属性还是自定义属性</p><p>H5新增的自定义属性（不考虑兼容性问题）：</p><ul><li>H5规定自定义属性data-开头作为属性名，并且赋值。比如：<code>&lt;div data-index = &#39;1&#39;&gt;&lt;/div&gt;</code></li><li>通过setAttribute(‘属性’)自定义属性。比如：<code>div.setAttribute(&#39;data-time&#39;, 20)</code></li><li>获取自定义属性的值getAttribute。比如：<code>div.getAttribute(&#39;data-time&#39;)</code></li><li>dataset 是一个集合，里面存放了所有以data开头的自定义属性。<ul><li>示例：<code>console.log(div.dataset.index)</code> 打印data-开头 index的自定义属性，<code>console.log(div.dataset)</code>打印所有以data开头的自定义属性</li><li><code>div.dataset[&#39;index&#39;]</code> 打印data开头 index的自定义属性</li><li>dataset 兼容性差 IE11才兼容</li></ul></li><li>如果自定义属性里面有多个-连接的单词，获取自定义属性时，需要采取驼峰命名法。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 自定义属性里面有多个-连接的单词，获取自定义属性时，需要采取驼峰命名法</span><br><span class="line">&lt;div data-list-name=&#x27;andy&#x27;&gt;&lt;/div&gt;</span><br><span class="line">console.log(div.dataset.listName); // andy</span><br><span class="line">console.log(div.dataset[&#x27;listName&#x27;]); // andy</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><p>页面中的所有内容都是节点（标签、属性、文本、注释等），在DOM中，节点使用node来表示</p><p>HTML DOM树中的所有节点均可以通过JavaScript进行访问，所有HTML元素（节点）均可被修改、创建、删除</p><p>一般的节点至少拥有：<strong>nodeType（节点类型）</strong> 、<strong>nodeName（节点名称）</strong> 、<strong>nodeValue（节点值）</strong> 三个基本属性</p><p>nodeType（节点类型）：</p><ul><li>元素节点 nodeType 为 1</li><li>属性节点 nodeType 为 2</li><li>文本节点 nodeType 为 3（文本节点包括：文字、空格、换行）</li></ul><p>在实际开发中，节点操作主要操作的是<strong>元素节点</strong></p><h4 id="父节点-parentNode"><a href="#父节点-parentNode" class="headerlink" title="父节点 parentNode"></a>父节点 parentNode</h4><p>语法：<code>node.parentNode</code> 返回指定子节点的父节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;div class=&#x27;box&#x27;&gt;</span><br><span class="line">    &lt;span class=&#x27;font&#x27;&gt;文字文字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 父节点</span><br><span class="line">var font = document.querySelector(&#x27;.font&#x27;);</span><br><span class="line">// var box = document.querySelector(&#x27;.box&#x27;) // 以前的写法</span><br><span class="line">console.log(font.parentNode); // font.parentNode 可以直接获取子节点font的父节点</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>node.parentNode 得到的是离子节点最近的父节点</li><li>如果指定的节点找不到父节点，则返回为null</li></ul><h4 id="子节点-children"><a href="#子节点-children" class="headerlink" title="子节点 children"></a>子节点 children</h4><p>语法：parentNode.childNodes 返回包含指定节点的子节点（包含：元素节点、文本节点等）的集合，该集合为即使更新的集合</p><p>如果只想要获得里面的元素节点，则需要专门处理，一般不提倡用childNodes</p><p>推荐使用：<code>parentNode.children</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">// var li = document.querySelector(&#x27;li&#x27;); // 以前的写法</span><br><span class="line">console.log(ul.children); // ul.children 可以直接获取父节点ul下的所有子节点</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="第一个和最后一个子节点"><a href="#第一个和最后一个子节点" class="headerlink" title="第一个和最后一个子节点"></a>第一个和最后一个子节点</h4><p>parentNode.firstElementChild ：返回第一个子元素节点，找不到返回null</p><p>parentNode.lastElementChild：返回最后一个子元素节点，找不到返回null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;11&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;22&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;33&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;)</span><br><span class="line">console.log(ul.firstElementChild); // 第一个子元素节点： &lt;li&gt;11&lt;/li&gt;</span><br><span class="line">console.log(ul.lastElementChild); // 最后一个子元素节点： &lt;li&gt;33&lt;/li&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：这两个方法有兼容性问题，IE9以上才支持</p><p>实际开发的写法，<strong>既没有兼容性问题，又能返回第一个和最后一个子元素：</strong></p><p>ul.children[ol.children.length - 1 ] ：获取最后一个子元素（父节点所有子节点的长度减1，则是元素的下标），不管子元素增加减少，都可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ul.children 返回ul下面所有的子节点，再用children[0]数组的方式取第一个子节点</span><br><span class="line">console.log(ul.children[0]); // 第一个子元素节点： &lt;li&gt;11&lt;/li&gt;</span><br><span class="line">console.log(ul.children[2]); // 最后一个子元素节点： &lt;li&gt;33&lt;/li&gt;</span><br><span class="line">console.log( ul.children[ol.children.length - 1 ]); // 最后一个子元素节点： &lt;li&gt;33&lt;/li&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="导航栏（父子节点案例）"><a href="#导航栏（父子节点案例）" class="headerlink" title="导航栏（父子节点案例）"></a>导航栏（父子节点案例）</h4><p>案例分析：</p><p>1、导航栏里面的li都要鼠标经过的效果，所以需要循环绑定鼠标事件</p><p>2、核心元素：当鼠标经过li里面的第二个孩子ul显示，当鼠标离开，ul隐藏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;nav&quot;&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href=&quot;&quot;&gt;首 页&lt;/a&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;a href=&quot;&quot;&gt;微 博&lt;/a&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;微博内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;微博内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;&quot;&gt;微博内容&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var nav = document.querySelector(&#x27;.nav&#x27;)</span><br><span class="line">var lis = nav.children; // 得到nav下面的子li</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    lis[i].onmouseover = function () &#123;</span><br><span class="line">        this.children[1].style.display = &#x27;block&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    lis[i].onmouseout = function () &#123;</span><br><span class="line">        this.children[1].style.display = &#x27;none&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><p>语法：</p><ul><li><code>node.nextElementSibling</code> 返回下一个兄弟元素节点，找不到返回null</li><li><code>node.previousElementSibling</code> 返回下一个兄弟元素节点，找不到返回null</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;div&lt;/div&gt;</span><br><span class="line">&lt;span&gt;span&lt;/span&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">console.log(div.nextElementSibling); // &lt;span&gt;span&lt;/span&gt;</span><br><span class="line">console.log(div.previousElementSibling); // null</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：这两个方法有兼容性问题，IE9以上才支持</p><h4 id="创建-x2F-添加-x2F-删除-x2F-替换-x2F-查找节点"><a href="#创建-x2F-添加-x2F-删除-x2F-替换-x2F-查找节点" class="headerlink" title="创建&#x2F;添加&#x2F;删除&#x2F;替换&#x2F;查找节点"></a>创建&#x2F;添加&#x2F;删除&#x2F;替换&#x2F;查找节点</h4><p>语法：</p><ul><li><p>创建节点：因为这些元素原先是不存在的，是根据需要动态生成的，所以也称为<strong>动态创建元素节点</strong></p><ul><li><p><code>document.createElement(&#39;tagName&#39;)</code></p><ul><li>创建由tagName指定的HTML元素</li></ul></li><li><p><code>document.createDocumentFragment()</code></p><ul><li>创建一个DOM片段</li></ul></li><li><p><code>document.createTextNode() </code></p><ul><li>创建一个文本节点</li></ul></li></ul></li><li><p>添加节点</p><ul><li><code>node.appendChild(child)</code><ul><li>将一个节点添加到指定父节点的子节点列表的 <strong>末尾</strong> （node：父级，child子级）</li></ul></li><li><code>node.insertBefore(child, 指定元素)</code><ul><li>将一个节点添加到父节点的指定子节点<strong>前面</strong></li></ul></li></ul></li><li><p>删除节点</p><ul><li>语法：<code>node.removeChild(child)</code> 从父节点中删除一个子节点，返回删除的节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">&lt;button&gt;删除&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>11<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>22<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 1.获取元素</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.删除元素  node.removeChild(child)</span></span><br><span class="line"><span class="comment">// ul.removeChild(ul.children[0])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.点击按钮依次删除子节点</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">// 如果父节点下没有子节点了，按钮禁用，还有子节点则可以继续删除</span></span><br><span class="line">    ul.<span class="property">children</span>.<span class="property">length</span> == <span class="number">0</span> ?  <span class="variable language_">this</span>.<span class="property">disabled</span> = <span class="literal">true</span> :  ul.<span class="title function_">removeChild</span>(ul.<span class="property">children</span>[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>替换节点</p><ul><li>replaceChild(new,old)</li></ul></li><li><p>拷贝节点</p><ul><li>语法：node.cloneNode() 返回调用该方法的节点的一个副本，也成为克隆节点&#x2F;拷贝节点</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>22<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>33<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>44<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="comment">// 复制ul下面第一个孩子li的节点</span></span><br><span class="line"><span class="keyword">var</span> lili = ul.<span class="property">children</span>[<span class="number">0</span>].<span class="title function_">cloneNode</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 添加到ul下的li列表的末尾</span></span><br><span class="line">ul.<span class="title function_">appendChild</span>(lili)</span><br><span class="line"><span class="comment">// 添加到ul下的li列表的第一个li的前面</span></span><br><span class="line">ul.<span class="title function_">insertBefore</span>(lili, ul.<span class="property">children</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>  注意：</p><ul><li><p>如果括号内的参数为<strong>空</strong>或者为 <strong>false</strong> ，则是 <strong>浅拷贝</strong> ，只克隆复制节点本身，<strong>只复制标签不复制里面的内容</strong></p></li><li><p>如果括号内为 <strong>true</strong> ，则是 <strong>深拷贝</strong> ，<strong>复制里面的标签和内容</strong></p></li><li><p>查找节点</p><ul><li>getElementById();</li><li>getElementsByName();</li><li>getElementsByTagName();</li><li>getElementsByClassName();</li><li>querySelector();</li><li>querySelectorAll();</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;99&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">// 1.创建节点 元素节点</span><br><span class="line">var li = document.createElement(&#x27;li&#x27;);</span><br><span class="line"></span><br><span class="line">// 2.添加节点 node.appendChild(child) node 父级  child 子级</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">ul.appendChild(li)</span><br><span class="line"></span><br><span class="line">// 3.添加节点 node.insertBefore(child, 指定元素)</span><br><span class="line">var lili = document.createElement(&#x27;li&#x27;);</span><br><span class="line">ul.insertBefore(lili, ul.children[0]);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果需要在页面添加一个新的元素（步骤）：</p><p>1.创建元素</p><p>2.添加元素</p><h4 id="留言板（创建-x2F-添加-x2F-删除节点案例）"><a href="#留言板（创建-x2F-添加-x2F-删除节点案例）" class="headerlink" title="留言板（创建&#x2F;添加&#x2F;删除节点案例）"></a>留言板（创建&#x2F;添加&#x2F;删除节点案例）</h4><p>核心思路：点击按钮之后，就动态创建一个li，添加到ul里面</p><p>创建li的同时，把文本域里面的值通过li.innerHTML赋值给li</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;button&gt;添加&lt;/button&gt;</span><br><span class="line">&lt;ul&gt;&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;)</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;)</span><br><span class="line">var text = document.querySelector(&#x27;textarea&#x27;)</span><br><span class="line">btn.onclick = function () &#123;</span><br><span class="line">    if (text.value == &#x27;&#x27;) &#123;</span><br><span class="line">        alert(&#x27;您还没有输入留言~&#x27;);</span><br><span class="line">        return false; // 终止操作</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 创建元素节点</span><br><span class="line">        var li = document.createElement(&#x27;li&#x27;)</span><br><span class="line">        // 现有li 才能赋值</span><br><span class="line">        // console.log(text.value); // 留言的内容</span><br><span class="line">        li.innerHTML = text.value + &quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;</span><br><span class="line"></span><br><span class="line">        // 添加元素节点 insertBefore 添加的元素永远在一个行</span><br><span class="line">        ul.insertBefore(li, ul.children[0])</span><br><span class="line">        // 添加留言完成之后，清空原来输入框的内容</span><br><span class="line">        text.value = &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">        // 删除元素节点 删除的是当前链接的父节点</span><br><span class="line">        var as = document.querySelectorAll(&#x27;a&#x27;);</span><br><span class="line">        for (var i = 0; i &lt; as.length; i++) &#123;</span><br><span class="line">            as[i].onclick = function () &#123;</span><br><span class="line">                // node.removeChild(child) 删除的是li  当前a所在的li  this.parentNode</span><br><span class="line">                // li 的父节点是ul ul.removeChild()</span><br><span class="line">                ul.removeChild(this.parentNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="动态生成表格（综合案例）"><a href="#动态生成表格（综合案例）" class="headerlink" title="动态生成表格（综合案例）"></a>动态生成表格（综合案例）</h4><p>案例分析：</p><p>1、因为里面的数据是动态的，需要js动态生成。先模拟数据，定义好相应的数据，数据采取数组对象的形式存储</p><p>2、所有的数据都是放在tbody里面的行里面</p><p>3、因为行很多，需要循环创建多个行（多少人创建多少行）</p><p>4、每一个行里面有多个单元格（对应里面的数据），需要使用循环创建多个单元格，并且把数据存入里面（双重for循环）</p><p>5、最后一列单元格是删除，需要单独创建单元格</p><p>6、点击a删除当前a所在的行（链接的父级的父级） node.removeChild(child)，当前a的父级是列，列的父级是行，删除一整行： this.parentNode.parentNode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(k in obj)&#123;</span><br><span class="line">    // k 得到的是属性名</span><br><span class="line">    // obj[k] 得到的是属性值</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// 动态生成表格案例</span><br><span class="line">&lt;table cellspacing=&quot;0&quot;&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;科目&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;成绩&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">// 1.先准备数据</span><br><span class="line">var datas = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;王权&#x27;,</span><br><span class="line">        subject: &#x27;JavaScript&#x27;,</span><br><span class="line">        score: 100</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;沉稳五&#x27;,</span><br><span class="line">        subject: &#x27;JavaScript&#x27;,</span><br><span class="line">        score: 90</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;灵梦&#x27;,</span><br><span class="line">        subject: &#x27;JavaScript&#x27;,</span><br><span class="line">        score: 80</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">// 2.往tbody里面创建行：多少人创建多少行，通过数组的长度创建几行</span><br><span class="line">var tbody = document.querySelector(&#x27;tbody&#x27;);</span><br><span class="line">for (var i = 0; i &lt; datas.length; i++) &#123; // 外面的for循环决定多少行</span><br><span class="line">    // 创建tr行</span><br><span class="line">    var tr = document.createElement(&#x27;tr&#x27;);</span><br><span class="line">    // 在父节点tbody下添加子节点tr</span><br><span class="line">    tbody.appendChild(tr)</span><br><span class="line"></span><br><span class="line">    // 3.行里面创建单元格 td，单元格的数量取决于对象里面的属性个数 ，得到数组对象属性个数，也就是单元格列的个数</span><br><span class="line">    // for循环遍历对象（每个datas数组里面的元素对象都要遍历一遍，得到每一个元素对象属性的个数）</span><br><span class="line">    for (var k in datas[i]) &#123; // 里面的for循环决定多少列 td</span><br><span class="line">        // 创建单元格列</span><br><span class="line">        var td = document.createElement(&#x27;td&#x27;);</span><br><span class="line">        // 把对象里面的属性值给td  </span><br><span class="line">        td.innerHTML = datas[i][k];</span><br><span class="line">        // 单元格放在行里面</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">    &#125;</span><br><span class="line">    // 4.创建删除的单元格</span><br><span class="line">    var td = document.createElement(&#x27;td&#x27;);</span><br><span class="line">    // 给删除的单元格添加删除的文字</span><br><span class="line">    td.innerHTML = &quot;&lt;a href=&#x27;#&#x27;&gt;删 除&lt;/a&gt;&quot;</span><br><span class="line">    // 将删除的单元格放入行中</span><br><span class="line">    tr.appendChild(td)</span><br><span class="line">&#125;</span><br><span class="line">// 5.删除单元格操作</span><br><span class="line">var as = document.querySelectorAll(&#x27;a&#x27;)</span><br><span class="line">for (var i = 0; i &lt; as.length; i++) &#123;</span><br><span class="line">    as[i].onclick = function () &#123;</span><br><span class="line">        // 点击a删除当前a所在的行（链接的父级的父级） node.removeChild(child)</span><br><span class="line">        // 当前a的父级是列，列的父级是行，删除一整行： this.parentNode.parentNode</span><br><span class="line">        tbody.removeChild(this.parentNode.parentNode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="三种动态创建元素的区别"><a href="#三种动态创建元素的区别" class="headerlink" title="三种动态创建元素的区别"></a>三种动态创建元素的区别</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=245&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=245&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><ul><li>document.write()（了解）：直接将内容写入页面的内容流。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 例如：点击按钮在文档中写入一个内容是123的div,按钮点击之后，文档重绘，其他的内容都没有了，只有这个123的div</span><br><span class="line">document.write(&#x27;&lt;div&gt;123&lt;/div&gt;&#x27;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>element.innerHTML：创建元素</li><li>document.createElement()：创建元素</li></ul><p>区别：</p><ul><li>document.write() 正常下是没有问题的，但是当文档流执行完毕，则它会导致页面全部重绘（原来的内容就没有了）</li><li>innerHTML 是将内容写入某个DOM节点，不会导致页面全部重绘</li><li>innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组push形式拼接，再转换成字符），结构稍微复杂</li><li>createElement() 创建多个元素效率稍微低一点，但是结构更清晰</li></ul><p>总结：不同浏览器下，innerHTML效率比createElement高</p><h2 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h2><h3 id="注册（绑定）事件的方式"><a href="#注册（绑定）事件的方式" class="headerlink" title="注册（绑定）事件的方式"></a>注册（绑定）事件的方式</h3><p>给元素添加事件，称为<strong>注册事件</strong>或者<strong>绑定事件</strong></p><p>注册事件的两种方式：</p><ul><li>传统的方式</li><li>方法监听注册方式</li></ul><h4 id="传统注册方式"><a href="#传统注册方式" class="headerlink" title="传统注册方式"></a>传统注册方式</h4><p>传统注册方式：</p><ul><li>利用on开头的事件 onclick</li><li><code>&lt;button onclick=&#39;alert(&#39;99&#39;)&#39;&gt;&lt;/button&gt;</code></li><li><code>btn.onclick = function()&#123;&#125;</code></li><li>特点：注册事件的唯一性</li><li>同一个元素同一个事件只能设置一个处理函数，后面注册的处理函数会覆盖前面注册的处理函数</li></ul><h4 id="方法监听注册方式"><a href="#方法监听注册方式" class="headerlink" title="方法监听注册方式"></a>方法监听注册方式</h4><p>方法监听注册方式：</p><ul><li>W3C标准 推荐方式</li><li><strong>addEventListener()</strong> 方法</li><li>IE9之前的IE不支持此方法，可用attachEvent() （不提倡用此方法）代替</li><li>特点：<strong>同一个元素同一个事件可注册（绑定）多个监听器（处理函数function(){}）</strong></li><li>按照绑定的顺序依次执行</li></ul><h4 id="addEventListener-事件监听方式"><a href="#addEventListener-事件监听方式" class="headerlink" title="addEventListener 事件监听方式"></a>addEventListener 事件监听方式</h4><p>语法：<code>eventTarget.addEventListener(type, listener[, useCapture])</code> 将指定的监听器绑定到eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</p><p>该方法接收三个参数：</p><ul><li>type：事件类型字符串（要加引号）。比如：click、mouseover等，注意这里不需要带on</li><li>listener：事件处理函数，事件发生时，会调用该函数</li><li>useCapture：是否阻止冒泡，可选参数，布尔值，默认是false</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    console.log(&#x27;按钮&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="删除事件（事件解绑）"><a href="#删除事件（事件解绑）" class="headerlink" title="删除事件（事件解绑）"></a>删除事件（事件解绑）</h3><h4 id="传统注册事件的事件解绑"><a href="#传统注册事件的事件解绑" class="headerlink" title="传统注册事件的事件解绑"></a>传统注册事件的事件解绑</h4><p>传统注册事件的事件解绑：<code>eventTarget.onclick = null;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 示例 只能点击一次，点完第一次 btn.onclick = null  事件解绑</span><br><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">btn.onclick = function () &#123;</span><br><span class="line">    console.log(&#x27;按钮&#x27;);</span><br><span class="line">    btn.onclick = null</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="方法监听注册方式-1"><a href="#方法监听注册方式-1" class="headerlink" title="方法监听注册方式"></a>方法监听注册方式</h4><p>方法监听注册方式：<code>eventTarget.removeEventListener(type, listener[, useCapture])</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, fn) // 里面的fn  调用不需要加 小括号</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&#x27;按钮&#x27;);</span><br><span class="line">    btn.removeEventListener(&#x27;click&#x27;, fn)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：removeEventListener 方法解除事件绑定，必须告诉他解除哪个处理函数，前面绑定的函数可单独写出来</p><h3 id="DOM事件流（重要）"><a href="#DOM事件流（重要）" class="headerlink" title="DOM事件流（重要）"></a>DOM事件流（重要）</h3><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=252&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=252&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><p>事件流：描述的是从页面中接收事件的顺序</p><p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播的过程称为 <strong>DOM事件流</strong> （ <strong>DOM事件流：事件传播的过程</strong> ）</p><p>DOM事件流分为三个阶段：</p><ul><li>捕获阶段：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接收的过程</li><li>当前目标阶段</li><li>冒泡阶段：IE最早提出，事件开始时由具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程</li></ul><p>注意：</p><ul><li>JS代码中，只能执行捕获或者冒泡其中的一个阶段</li><li>onclick、attachEvent只能得到冒泡阶段</li><li>addEventListener(type, listener[, useCapture]) 第三个参数如果是true，表示事件捕获阶段调用事件处理程序；如果是false（不写默认是false），表示事件冒泡阶段调用事件处理程序</li><li>在实际开发中，很少使用事件捕获，更关注事件冒泡</li><li>有些事件是没有冒泡的。比如：onblur、onfocus、onmouseenter、onmouseleave</li></ul><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">btn.onclick = function (event) &#123;</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, function(event)&#123;</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>event 就是一个事件对象，写在侦听函数的小括号里面，当形参来看</li><li>事件对象只有有了事件才会存在，它是系统自动创建的，不需要我们传递参数</li><li>事件对象：是事件的一系列相关数据的集合，跟事件相关的。比如：鼠标点击，里面包含了鼠标的相关信息（鼠标坐标等）；如果是键盘事件，里面则包含的是键盘事件相关的信息（比如判断用户按下了哪个键）</li><li>事件对象简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放在这个对象里面，这个对象就是事件对象event，它有很多属性和方法</li><li>事件对象可自己命名。比如：event、evt、e（常用）</li><li>事件对象由兼容性问题。IE6&#x2F;7&#x2F;8通过window.event</li></ul><p>事件对象兼容性写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = function (e) &#123;</span><br><span class="line">    e = e || window.event;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="e-target-和-this-的区别"><a href="#e-target-和-this-的区别" class="headerlink" title="e.target 和 this 的区别"></a>e.target 和 this 的区别</h3><p>e.target 返回的是触发事件的对象（元素）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;123&lt;/div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">div.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">    console.log(e.target); // &lt;div&gt;123&lt;/div&gt;</span><br><span class="line">    console.log(this);// &lt;div&gt;123&lt;/div&gt;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>区别：</p><ul><li>e.target 返回的是触发事件的对象（元素），this返回的是绑定事件的对象（元素）</li><li>e.target 点击了哪个元素，就返回哪个元素；this 哪个元素绑定了，就返回哪个元素</li></ul><h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><p>组织默认行为，比如：让链接不跳转，让提交按钮不提交</p><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=255&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=255&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><p>事件冒泡：事件开始时由具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程</p><p>阻止事件冒泡：</p><ul><li>标准写法（推荐）：利用事件对象里面stopPropagation()方法</li><li>非标准写法：IE6-8 利用事件对象cancelBubble属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">    e.stopPropagation(); // 阻止事件冒泡</span><br><span class="line">    e.cancelBubble = true // 阻止事件冒泡</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="事件委托（代理、委派）"><a href="#事件委托（代理、委派）" class="headerlink" title="事件委托（代理、委派）"></a>事件委托（代理、委派）</h3><p><strong>事件委托的原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在父节点上，然后利用冒泡原理影响每个子节点</strong></p><p>事件委托的作用：只操作一次DOM，提高了程序的性能</p><p>下面案例：给ul绑定点击事件，然后利用事件对象的target来找到当前所点击的li，因为点击li，事件会冒泡到ul上，ul有注册事件，就会触发事件监听器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">ul.addEventListener(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">    // alert(&#x27;弹框~~&#x27;);</span><br><span class="line">    // e.target 可得到点击的对象</span><br><span class="line">    console.log(e.target);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h3><p>获取鼠标在页面中的坐标</p><p>event对象代表事件的状态，跟事件相关的一系列信息的集合。</p><p>鼠标事件：MouseEvent</p><h4 id="获取鼠标的坐标"><a href="#获取鼠标的坐标" class="headerlink" title="获取鼠标的坐标"></a>获取鼠标的坐标</h4><table><thead><tr><th>鼠标事件对象</th><th>说明</th></tr></thead><tbody><tr><td>e.clientX</td><td>返回鼠标相对于浏览器窗口可视区的x坐标</td></tr><tr><td>e.clientY</td><td>返回鼠标相对于浏览器窗口可视区的y坐标</td></tr><tr><td>e.pageX</td><td>返回鼠标相对于文档页面的x坐标 IE9+支持</td></tr><tr><td>e.pageY</td><td>返回鼠标相对于文档页面的y坐标 IE9+支持</td></tr><tr><td>e.screenX</td><td>返回鼠标相对于电脑屏幕的X坐标</td></tr><tr><td>e.screenY</td><td>返回鼠标相对于电脑屏幕的y坐标</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">document.addEventListener(&#x27;click&#x27;, function(e)&#123;</span><br><span class="line">    // 1.client 鼠标在可视区的x和y坐标</span><br><span class="line">    console.log(e.clientX);</span><br><span class="line">    console.log(e.clientY);</span><br><span class="line">    // 2.page 鼠标在页面文档的x和y坐标</span><br><span class="line">    console.log(e.pageX);</span><br><span class="line">    console.log(e.pageY);</span><br><span class="line">    // 3.screen 鼠标在电脑屏幕的x和y坐标</span><br><span class="line">    console.log(e.screenX);</span><br><span class="line">    console.log(e.screenY);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="跟随鼠标移动的div（案例）"><a href="#跟随鼠标移动的div（案例）" class="headerlink" title="跟随鼠标移动的div（案例）"></a>跟随鼠标移动的div（案例）</h4><p>案例分析：</p><p>1、鼠标不断的移动，使用鼠标移动事件：mousemove</p><p>2、在页面中移动，给document注册事件</p><p>3、div要移动距离，而且不占位置，使用绝对定位即可</p><p>4、核心原理：每次鼠标移动，都会获得最新的鼠标坐标，把这个x和y坐标作为图片的top和left值就可移动图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">    position: absolute;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">// mousemove 只要鼠标移动1px，就会触发这个事件</span><br><span class="line">document.addEventListener(&#x27;mousemove&#x27;, function (e) &#123;</span><br><span class="line">    // e.pageX e.pageY 鼠标在页面文档的x和y坐标</span><br><span class="line">    var x = e.pageX;</span><br><span class="line">    var y = e.pageY;</span><br><span class="line">    // console.log(x, y);</span><br><span class="line">    // 拼接单位px</span><br><span class="line">    div.style.left = x - 50 + &#x27;px&#x27;;</span><br><span class="line">    div.style.top = y - 50 + &#x27;px&#x27;;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><h4 id="keyup、keydown、keypress"><a href="#keyup、keydown、keypress" class="headerlink" title="keyup、keydown、keypress"></a>keyup、keydown、keypress</h4><table><thead><tr><th>键盘事件</th><th>说明</th></tr></thead><tbody><tr><td>onkeyup</td><td>某个键盘按键被松开时触发</td></tr><tr><td>onkeydown</td><td>某个键盘按键被按下时触发</td></tr><tr><td>onkeypress</td><td>某个键盘按键被按下时触发，但是不识别功能键，比如ctrl、shift、箭头等</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">document.addEventListener(&#x27;keyup&#x27;, function () &#123;</span><br><span class="line">    console.log(&#x27;弹起~&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">document.addEventListener(&#x27;keydown&#x27;, function () &#123;</span><br><span class="line">    console.log(&#x27;按下~&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">document.addEventListener(&#x27;keypress&#x27;, function () &#123;</span><br><span class="line">    console.log(&#x27;按下keypress~&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>传统方式需要加on，addEventListener不需要加on</li><li>onkeypress和前两个的区别是：不识别功能键。比如ctrl、左右箭头、shift等</li><li>三个执行顺序：keydown -&gt; keypress -&gt; keyup</li></ul><h4 id="keyCode判断用户按下哪个键"><a href="#keyCode判断用户按下哪个键" class="headerlink" title="keyCode判断用户按下哪个键"></a>keyCode判断用户按下哪个键</h4><p>键盘事件对象中的keyCode属性可用得到相应键的ASCII码值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;keyup&#x27;, function (e) &#123;</span><br><span class="line"> console.log(e.keyCode);</span><br><span class="line">&#125;)</span><br><span class="line">document.addEventListener(&#x27;keydown&#x27;, function (e) &#123;</span><br><span class="line">    console.log(e.keyCode);</span><br><span class="line">&#125;)</span><br><span class="line">document.addEventListener(&#x27;keypress&#x27;, function (e) &#123;</span><br><span class="line">   console.log(e.keyCode);</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>keyup 和 keydown事件不区分大小写，a 和 A 得到的ASCII码值都是65</li><li>keypress 事件区分大小写，a 97 ，A 65</li></ul><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="BOM概述"><a href="#BOM概述" class="headerlink" title="BOM概述"></a>BOM概述</h3><p> <strong>BOM：浏览器对象模型</strong> ，它提供了独立于内容而与 <strong>浏览器窗口进行交互的对象</strong> ，其核心对象时window</p><p>DOM和BOM的区别：</p><table><thead><tr><th>DOM</th><th>BOM</th></tr></thead><tbody><tr><td>文档对象模型</td><td>浏览器对象模型</td></tr><tr><td>DOM就是把文档当作一个对象来看待</td><td>BOM把浏览器当作一个对象来看待</td></tr><tr><td>DOM的顶级对象是document</td><td>BOM的顶级对象是window</td></tr><tr><td>DOM主要学习的是操作页面元素</td><td>BOM学习的是浏览器窗口交互的一些对象</td></tr><tr><td>DOM是W3C标准规范</td><td>BOM是浏览器厂商在各自浏览器上定义的，兼容性较差</td></tr></tbody></table><p>BOM比DOM更大，BOM包含DOM</p><p>window对象是浏览器的顶级对象：</p><ul><li>它是JS访问浏览器窗口的一个接口</li><li>它是全局对象，定义在全局作用域中的变量、函数都会变成window对象的属性和方法</li></ul><h3 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h3><p>语法（两种）：</p><ul><li>传统：window.onload &#x3D; function(){}</li><li>方法：window.addEventListener(‘load’, function(){})</li></ul><p>window.onload 是窗口（页面）加载事件，当文档内容完全加载完成之后（包括图像、文字</p><p>css等），会触发该事件，就调用处理函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function ()&#123;</span><br><span class="line"> // js代码</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>有了window.onload就可以把JS代码写在页面元素的任何地方，因为onload是等页面内容全部加载完毕再去执行处理函数的</li><li>window.onload传统注册事件方式只能写一个，如果有多个，后面的会覆盖前面的，以最后一个为准</li><li>如果使用addEventListener，则没有限制</li></ul><h3 id="调整浏览器窗口大小事件"><a href="#调整浏览器窗口大小事件" class="headerlink" title="调整浏览器窗口大小事件"></a>调整浏览器窗口大小事件</h3><p>语法：<code>window.onresize = function()&#123;&#125;</code>或者 <code>window.addEventListener(&#39;resize&#39;, function()&#123;&#125;)</code></p><p>window.onresize 是调整浏览器窗口大小时加载的事件，当触发时就调用处理函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;resize&#x27;, function () &#123;</span><br><span class="line">    console.log(&#x27;窗口尺寸变化了&#x27;);</span><br><span class="line">     console.log(window.innerWidth); // 当前屏幕的宽度</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>只要窗口大小发生变化，就会触发这个事件</li><li>可利用这个事件完成响应式布局，配合 <code>window.innerWidth</code>获取当前屏幕的宽度</li></ul><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>两种定时器：</p><ul><li>setTimeout()</li><li>setInterval()</li></ul><h4 id="setTimeout-定时器"><a href="#setTimeout-定时器" class="headerlink" title="setTimeout() 定时器"></a>setTimeout() 定时器</h4><p>语法：</p><p><code>window.setTimeout(回调函数， [延迟的毫秒数])</code></p><p>作用：用于设置一个定时器，该定时器会在定时器到期后执行回调函数，只执行一次就结束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 示例一</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&#x27;2秒到了&#x27;);</span><br><span class="line">&#125;, 2000)</span><br><span class="line"></span><br><span class="line">// 示例二</span><br><span class="line">setTimeout(callback, 2000)</span><br><span class="line">function callback() &#123;</span><br><span class="line">    console.log(&#x27;2秒到了&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>这个window在调用时可省略</li><li>延时的事件单位时毫秒（1000ms &#x3D; 1s），可省略，如果省略为0，则立即调用</li></ul><h4 id="clearTimeout-清除定时器"><a href="#clearTimeout-清除定时器" class="headerlink" title="clearTimeout() 清除定时器"></a>clearTimeout() 清除定时器</h4><p>语法：</p><p><code>window.clearTimeout(timeout ID)</code></p><p>clearTimeout()方法可取消setTimeout()建立的定时器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;button&gt; 按钮 &lt;/button&gt;</span><br><span class="line">var timer = setTimeout(function () &#123;</span><br><span class="line">console.log(&#x27;2秒到了&#x27;);</span><br><span class="line">&#125;, 2000)</span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">    // 清除定时器</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="setInterval-定时器"><a href="#setInterval-定时器" class="headerlink" title="setInterval() 定时器"></a>setInterval() 定时器</h4><p>语法：<code>window.setInterval(回调函数,[间隔的毫秒数])</code></p><p>setInterval() 方法重复调用一个函数，每隔一段时间（设置的间隔时间），就去调用一次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function () &#123;</span><br><span class="line">    console.log(&#x27;111&#x27;);</span><br><span class="line">&#125;, 1000)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>这个window在调用时可省略</li><li>延时的事件单位时毫秒（1000ms &#x3D; 1s），可省略，如果省略为0，则立即调用</li></ul><h4 id="clearInterval-清除定时器"><a href="#clearInterval-清除定时器" class="headerlink" title="clearInterval 清除定时器"></a>clearInterval 清除定时器</h4><p>语法：<code>window.clearInterval(interval ID)</code></p><p>clearInterval() 方法清除通过setInterval创建的定时器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;button&gt; 按钮&lt;/button&gt;</span><br><span class="line">var timer = setInterval(function () &#123;</span><br><span class="line">console.log(&#x27;2秒到了&#x27;);</span><br><span class="line">&#125;, 2000)</span><br><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">    // 清除定时器</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="倒计时（案例）"><a href="#倒计时（案例）" class="headerlink" title="倒计时（案例）"></a>倒计时（案例）</h4><p>案例分析：</p><p>1、因为时间是不断变化的，因此需要定时器来自动变化（setInterval）</p><p>2、三个盒子里面分别存放时、分、秒</p><p>3、三个盒子利用innerHTML放入计算出来的时、分、秒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;hour&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;minute&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;second&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var hour = document.querySelector(&#x27;.hour&#x27;);</span><br><span class="line">var minute = document.querySelector(&#x27;.minute&#x27;);</span><br><span class="line">var second = document.querySelector(&#x27;.second&#x27;);</span><br><span class="line">var inputTime = +new Date(&#x27;2022-6-5 18:00:00&#x27;)</span><br><span class="line">countDown(); // 先调用一次时间函数，防止页面刷新出现空白的情况</span><br><span class="line">// 开启定时器，每隔一秒调用一次</span><br><span class="line">setInterval(countDown, 1000)</span><br><span class="line">// 计算 倒计时 时间的函数</span><br><span class="line">function countDown() &#123;</span><br><span class="line">    var nowTime = +new Date(); // 括号内为空，则返回的是当前时间的总毫秒数</span><br><span class="line"></span><br><span class="line">    /* 输入的时间 - 现在时间的总毫秒，再除以1000将毫秒转换为秒 */</span><br><span class="line">    var times = (inputTime - nowTime) / 1000; // times 是剩余时间的总秒数，1s = 1000ms</span><br><span class="line"></span><br><span class="line">    var h = parseInt(times / 60 / 60 % 24); // 小时</span><br><span class="line">    var m = parseInt(times / 60 % 60);// 分钟</span><br><span class="line">    var s = parseInt(times % 60); // 秒数</span><br><span class="line"></span><br><span class="line">    h = h &lt; 10 ? &#x27;0&#x27; + h : h;</span><br><span class="line">    m = m &lt; 10 ? &#x27;0&#x27; + m : m;</span><br><span class="line">    s = s &lt; 10 ? &#x27;0&#x27; + s : s;</span><br><span class="line"></span><br><span class="line">    hour.innerHTML = h;</span><br><span class="line">    minute.innerHTML = m;</span><br><span class="line">    second.innerHTML = s;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="this-指向问题"><a href="#this-指向问题" class="headerlink" title="this 指向问题"></a>this 指向问题</h3><ul><li>全局作用域或者普通函数中的this指向全局对象window，定时器里面的this也指向window</li><li>方法调用中谁调用this指向谁</li><li>构造函数中this指向构造函数的实例</li></ul><h3 id="JS执行队列（重要）"><a href="#JS执行队列（重要）" class="headerlink" title="JS执行队列（重要）"></a>JS执行队列（重要）</h3><h4 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a>JS是单线程</h4><p>JavaScript语言的一大特点就是 <strong>单线程</strong> ，也就是说：<strong>同一个时间只能做一件事</strong></p><p>这是因为JavaScript这门脚本语言诞生的使命所致–JavaScript是为处理页面中用户的交互，以及操作DOM而诞生的。</p><p>比如：对某个DOM元素进行添加和删除操作，不能同时进行，要先添加后删除</p><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>为了解决代码一行一行执行，可能会导致后面的代码堵塞的问题，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程。</p><p>于是，JavaScript出现了<strong>同步</strong>和<strong>异步</strong></p><p><strong>同步：前一个任务结束后再执行后面的任务，程序的执行顺序与任务的排列顺序是一致的、同步的，会出现代码阻塞的情况。</strong></p><p>比如：做饭的同步做法：烧水煮饭，等水开了（10分钟之后），再去切菜、炒菜。</p><p><strong>异步：同时做多个任务，多个任务一块进行</strong></p><p>比如：做饭的异步做法：烧水煮饭，烧水的同时，去切菜、炒菜。</p><h4 id="同步异步任务执行过程"><a href="#同步异步任务执行过程" class="headerlink" title="同步异步任务执行过程"></a>同步异步任务执行过程</h4><table><thead><tr><th>同步任务</th><th>异步任务</th></tr></thead><tbody><tr><td>同步任务都在<strong>主线程上执行</strong> ，形成一个<strong>执行栈</strong></td><td>js异步是通过<strong>回调函数</strong>实现的</td></tr><tr><td></td><td>一般而言，异步任务有以下三种类型：</td></tr><tr><td></td><td>1、普通事件。如：click、resize等</td></tr><tr><td></td><td>2、资源加载。如：load、error等</td></tr><tr><td></td><td>3、定时器，包括setInterval、setTimeout等</td></tr><tr><td></td><td>异步任务相关<strong>回调函数</strong>添加到<strong>任务队列</strong>中（任务队列也叫 <strong>消息队列</strong> ）</td></tr></tbody></table><p><strong>执行机制：</strong></p><p>1、把JS任务分为同步任务和异步任务，同步任务放在执行栈中，异步任务放在任务队列中（消息队列）</p><p>1、先执行执行栈中的同步任务</p><p>2、再去任务队列里面去看有没有异步任务，如果有则把任务队列里面的异步任务放到执行栈中执行</p><p>3、一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.log(3);</span><br><span class="line">// 输出顺序：1 3 2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="/" alt="js执行机制"></p><h4 id="异步进程处理"><a href="#异步进程处理" class="headerlink" title="异步进程处理"></a>异步进程处理</h4><p><img src="/" alt="js执行机制（事件循环）"></p><h3 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h3><p>window对象提供了一个 <strong>location属性</strong> ，用于 <strong>获取或设置窗体的URL</strong> ，并且可以用于 <strong>解析URL</strong> 。</p><p>因为这个属性返回的是一个对象，所以这个属性也称为<strong>location对象</strong></p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p> <strong>URL：统一资源定位符</strong> ，是互联网上标准资源的地址</p><p>互联网上每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它</p><p>URL的一般语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol://host[:port]/path/[?query]#fragment</span><br><span class="line">https://www.bilibili.com/video/BV1Sy4y1C7ha?p=281</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><table><thead><tr><th>组成</th><th>说明</th></tr></thead><tbody><tr><td>protocol</td><td>通信协议。常用：http、ftp、maito等</td></tr><tr><td>host</td><td>主机（域名）<a href="https://link.juejin.cn/?target=www.bilibili.com" title="www.bilibili.com">www.bilibili.com</a></td></tr><tr><td>port</td><td>端口号，可选，省略时使用方案的默认端口 。如：http默认端口号为80</td></tr><tr><td>path</td><td>路径。由零个或多个’&#x2F;‘符号隔开的字符串，一般用啦表示主机上的一个目录或文件地址</td></tr><tr><td>query</td><td>参数。以键值对的形式，通过&amp;符号分隔开</td></tr><tr><td>fragment</td><td>片段 #后面内容，常见于链接 锚点</td></tr></tbody></table><h4 id="location-对象常见的属性"><a href="#location-对象常见的属性" class="headerlink" title="location 对象常见的属性"></a>location 对象常见的属性</h4><table><thead><tr><th>location对象</th><th>返回值</th></tr></thead><tbody><tr><td>location.href</td><td>获取或设置 整个URL</td></tr><tr><td>location.host</td><td>返回主机（域名）<a href="https://link.juejin.cn/?target=www.bilibili.com" title="www.bilibili.com">www.bilibili.com</a></td></tr><tr><td>location.port</td><td>返回端口号。如果没有端口号，返回空字符串</td></tr><tr><td>location.pathname</td><td>返回路径</td></tr><tr><td>location.search</td><td>返回参数</td></tr><tr><td>location.hash</td><td>返回片段 #后面内容 常见于链接 锚点</td></tr></tbody></table><p>记住：location.href 获取或设置 整个URL 、 location.search 返回参数</p><h4 id="5秒后跳转页面（案例）"><a href="#5秒后跳转页面（案例）" class="headerlink" title="5秒后跳转页面（案例）"></a>5秒后跳转页面（案例）</h4><p>获取当前URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;button&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">    btn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">        console.log(location.href); //  file:///E:/practice/css/img/location.html</span><br><span class="line">        // 修改url地址，当按钮点击时，则会跳转到修改过后的地址</span><br><span class="line">        location.href = &#x27;https://www.baidu.com/&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>5秒后跳转页面：</p><p>案例分析：</p><p>1、利用定时器做倒计时效果</p><p>2、时间到了，就跳转页面，使用location.href</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var p = document.querySelector(&#x27;p&#x27;);</span><br><span class="line">    var timer = 5;</span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">        if (timer == 0) &#123;</span><br><span class="line">            location.href = &#x27;https://www.baidu.com/&#x27;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            p.innerHTML = timer + &#x27;秒后跳转到百度页面&#x27;</span><br><span class="line">            timer--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="获取URL参数（案例）"><a href="#获取URL参数（案例）" class="headerlink" title="获取URL参数（案例）"></a>获取URL参数（案例）</h4><p>案例分析：</p><p>1、第一个登录页面，里面由提交表单，action提交到index.html页面</p><p>2、第二个页面，可以使用第一个页面的参数，这样实现了一个数据不同页面之间的传递效果</p><p>3、第二个页面之所有可以使用第一个页面的数据，是利用了URL里面的location.search参数</p><p>4、第二个页面中，需要把这个参数提取</p><p>5、第一步去掉问好? 利用substr</p><p>6、第二步利用&#x3D;等号分隔键和值 split(‘&#x3D;’)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// --login.html</span><br><span class="line">&lt;form action=&quot;index.html&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">// --index.html</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">script&gt;</span><br><span class="line">    console.log(location.search); // ?username=andy</span><br><span class="line">    // 1.去掉？问号 substr(&#x27;起始位置&#x27;， 截取几个字符)</span><br><span class="line">    // 从字符串的第二个元素开始截取，substr()方法如果不写截取几个字符，默认后面的全部截取</span><br><span class="line">    var params = location.search.substr(1);  // params = username=andy</span><br><span class="line">soncole.log(params); //  username=andy</span><br><span class="line"></span><br><span class="line">    // 2.利用=等号 把字符串分割为数组  split(&#x27;=&#x27;)</span><br><span class="line">    var arr = params.split(&#x27;=&#x27;)</span><br><span class="line">    console.log(arr); //  [&#x27;username&#x27;, &#x27;andy&#x27;]</span><br><span class="line"></span><br><span class="line">    var div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">    div.innerHTML = arr[1] + &#x27; 欢迎您！&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="location-常见方法"><a href="#location-常见方法" class="headerlink" title="location 常见方法"></a>location 常见方法</h4><table><thead><tr><th>location方法</th><th>返回值</th></tr></thead><tbody><tr><td>location.assign()</td><td>跟href一样，可以跳转页面（也称为重定向页面），记录浏览历史，可以后退页面</td></tr><tr><td>location.replace()</td><td>替换当前页面，因为不记录历史，所以不能后退页面</td></tr><tr><td>location.reload()</td><td>重新加载页面，相当于刷新按钮，或者F5。如果参数为true，强制刷新你ctrl+F5</td></tr></tbody></table><h3 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h3><p><strong>navigator</strong>对象：包含有关浏览器的信息</p><p>它有很多属性，最常用的是 <strong>userAgent</strong> ，该属性可以<strong>返回由客户机发送服务器的user-agent头部的值</strong></p><p>前端代码可以判断用户在哪个终端（PC端、移动端等）打开页面，实现跳转</p><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=285" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=285">www.bilibili.com/video/BV1Sy…</a></p><h3 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h3><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=286&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=286&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><p>window 对象提供了一个history对象，与浏览器历史记录进行交互</p><p>history对象包含用户（在浏览器窗口中）访问过的URL</p><table><thead><tr><th>history对象方法</th><th>说明</th></tr></thead><tbody><tr><td>back()</td><td>可以后退页面功能</td></tr><tr><td>forward()</td><td>前进页面功能</td></tr><tr><td>go(参数)</td><td>前进后退功能。参数如果是1，则前进1个页面；如果参数是-1，则后退1个页面</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;a href=&#x27;index.html&#x27;&gt;点击去首页&lt;/a&gt;</span><br><span class="line">&lt;button&gt;前进&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var btn = document.querySelectot(&#x27;button&#x27;);</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, function()&#123;</span><br><span class="line">        history.forward(); // </span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="PC端网页特效"><a href="#PC端网页特效" class="headerlink" title="PC端网页特效"></a>PC端网页特效</h2><h3 id="元素偏移量-offset系列"><a href="#元素偏移量-offset系列" class="headerlink" title="元素偏移量 offset系列"></a>元素偏移量 offset系列</h3><p>offset：偏移量，使用offset系列相关属性可动态的得到该元素的位置（偏移量）、大小等</p><ul><li>获得元素距离带有定位的父元素的位置</li><li>获得元素自身的大小（宽高）</li><li>注意：但会的数值都不带单位</li></ul><h4 id="offset系列常用属性"><a href="#offset系列常用属性" class="headerlink" title="offset系列常用属性"></a>offset系列常用属性</h4><table><thead><tr><th>offset系列属性</th><th>说明</th></tr></thead><tbody><tr><td>element.offsetParent</td><td>返回该元素带有定位的父元素，如果父元素没有定位，则返回body</td></tr><tr><td>element.offsetTop</td><td>返回元素相对带有定位的父元素上方的偏移</td></tr><tr><td>element.offsetLeft</td><td>返回元素相对带有定位的父元素左边框的偏移量</td></tr><tr><td>element.offsetWidth</td><td>返回自身包括padding、边框、内容的宽度，返回数值不带单位</td></tr><tr><td>element.offsetHeight</td><td>返回自身包括padding、边框、内容的高度，返回数值不带单位</td></tr></tbody></table><h4 id="offsetLeft-、offsetTop"><a href="#offsetLeft-、offsetTop" class="headerlink" title="offsetLeft 、offsetTop"></a>offsetLeft 、offsetTop</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=288" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=288">www.bilibili.com/video/BV1Sy…</a></p><p>offsetLeft 、offsetTop返回元素相对于带有定位的父元素上方&#x2F;左边的偏移，如果父级没有定位，则以body为准距离上方&#x2F;左方的距离是多少</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .father &#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        margin-left: 100px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .son &#123;</span><br><span class="line">        width: 50px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        background-color: rgb(51, 61, 197);</span><br><span class="line">        margin-left: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var father = document.querySelector(&#x27;.father&#x27;);</span><br><span class="line">    var son = document.querySelector(&#x27;.son&#x27;)</span><br><span class="line">    console.log(father.offsetTop); // 0</span><br><span class="line">    console.log(father.offsetLeft); // 100 因为father  margin-left: 100px; 距离左侧100的距离</span><br><span class="line">// 如果父级没有加定位 是 0 110 ，加了定位是 0 10</span><br><span class="line">    console.log(son.offsetTop); </span><br><span class="line">    console.log(son.offsetLeft);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="offsetWidth、offsetHeight"><a href="#offsetWidth、offsetHeight" class="headerlink" title="offsetWidth、offsetHeight"></a>offsetWidth、offsetHeight</h4><p>offsetWidth、offsetHeight 返回自身包括padding、边框、内容的宽度&#x2F;高度，返回数值不带单位</p><p>当盒子没有宽度时，盒子随之浏览器窗口大小变化而变化，offsetWidth、offsetHeight可以动态的获取盒子的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.test &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    border: 10px solid pink;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var test = document.querySelector(&#x27;.test&#x27;)</span><br><span class="line">    console.log(test.offsetWidth); // 140 offsetWidth = width + padding + border </span><br><span class="line">    console.log(test.offsetHeight); // 140</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h4><p>offsetParent 返回该元素带有定位的父元素，如果父元素没有定位，则返回body</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(son.offsetParent); // div class=&quot;father&quot;&gt;&lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">console.log(son.parentNode);// </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>offsetParent 和 parentNode的区别：</p><ul><li>offsetParent：返回带有定位的父级，没有没有一直往上找，直到body</li><li>parentNode：不管有没有定位，返回其父级</li></ul><h4 id="offset-和-style-的区别"><a href="#offset-和-style-的区别" class="headerlink" title="offset 和 style 的区别"></a>offset 和 style 的区别</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=290&spm_id_from=pageDriver" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=290&amp;spm_id_from=pageDriver">www.bilibili.com/video/BV1Sy…</a></p><table><thead><tr><th>offset</th><th>style</th></tr></thead><tbody><tr><td>offset可得到任意样式表中的样式值</td><td>style只能得到行内样式表中的样式值</td></tr><tr><td>offset系列获得的数值没有单位</td><td>style.width 获得的时带单位的字符串</td></tr><tr><td>offsetWidth包含 padding + border + width</td><td>style.width 不包含padding + border</td></tr><tr><td>offsetWidth 等属性是只读属性，只能获取不能赋值（不能修改）</td><td>style.width 是可读写属性，可获取也可赋值修改</td></tr><tr><td>所以，想要获取元素大小位置：offset</td><td>所以：想要修改元素的值：style</td></tr></tbody></table><h4 id="鼠标在盒子内的坐标（案例）"><a href="#鼠标在盒子内的坐标（案例）" class="headerlink" title="鼠标在盒子内的坐标（案例）"></a>鼠标在盒子内的坐标（案例）</h4><p>案例分析：</p><p>1、在盒子内移动，得到鼠标距离盒子左右的距离（盒子添加mousemove鼠标移动事件）</p><p>2、首先，得到鼠标在页面中的坐标（e.pageX e.pageY）</p><p>3、其次，盒子在页面中的距离（box.offsetLeft box.offsetTop）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .box &#123;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 500px;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var box = document.querySelector(&#x27;.box&#x27;)</span><br><span class="line">    box.addEventListener(&#x27;mousemove&#x27;, function (e) &#123;</span><br><span class="line">        var x = e.pageX - this.offsetLeft;</span><br><span class="line">        var y = e.pageY - this.offsetTop;</span><br><span class="line">        console.log(box.offsetLeft, box.offsetTop);</span><br><span class="line">        box.innerHTML = &#x27;x坐标是：&#x27; + x + &#x27;y坐标是：&#x27; + y</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="拖拉拽（案例）"><a href="#拖拉拽（案例）" class="headerlink" title="拖拉拽（案例）"></a>拖拉拽（案例）</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=293" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=293">www.bilibili.com/video/BV1Sy…</a></p><p>拖拉拽的原理：鼠标按下（mousedown） + 鼠标移动（mousemove） + 松开鼠标（mouseup）</p><p>案例分析：</p><p>1、拖拉拽过程：鼠标移动过程中，获得最新的值，再赋值给盒子的left和top值，div就可以跟着鼠标移动</p><p>2、鼠标在页面的坐标 - 鼠标在盒子内的坐标 &#x3D; 盒子移动时的坐标</p><p>3、鼠标按下：得到鼠标在盒子中的坐标</p><p>4、鼠标移动：盒子的坐标 &#x3D; 鼠标坐标 - 盒子坐标 。注意移动事件要写在鼠标按下的事件里面</p><p>5、鼠标松开：停止拖拽，解除鼠标移动事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .box &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: red;</span><br><span class="line">        position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var box = document.querySelector(&#x27;.box&#x27;)</span><br><span class="line">    // 1.当鼠标按下，获取鼠标再盒子内的坐标</span><br><span class="line">    box.addEventListener(&#x27;mousedown&#x27;, (e) =&gt; &#123;</span><br><span class="line">        // 鼠标在盒子内的坐标 = 鼠标在页面中的坐标 - 盒子在页面中的坐标</span><br><span class="line">        var x = e.pageX - box.offsetLeft;</span><br><span class="line">        var y = e.pageY - box.offsetTop;</span><br><span class="line">        console.log(e.pageX, e.pageY, box.offsetLeft, box.offsetTop);</span><br><span class="line">        // 2.鼠标移动的时候，把鼠标在页面中的坐标，减去鼠标在盒子内的坐标，得到盒子的left和top值</span><br><span class="line">        document.addEventListener(&#x27;mousemove&#x27;, move)</span><br><span class="line">        function move(e) &#123;</span><br><span class="line">            box.style.left = e.pageX - x + &#x27;px&#x27;;</span><br><span class="line">            box.style.top = e.pageY - y + &#x27;px&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3.鼠标松开，移除鼠标移动事件</span><br><span class="line">        document.addEventListener(&#x27;mouseup&#x27;, () =&gt; &#123;</span><br><span class="line">            document.removeEventListener(&#x27;mousemove&#x27;, move)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="放大镜效果（案例）"><a href="#放大镜效果（案例）" class="headerlink" title="放大镜效果（案例）"></a>放大镜效果（案例）</h4><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=297" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=297">www.bilibili.com/video/BV1Sy…</a></p><ul><li>整个案例分为三个模块</li><li>鼠标经过小图片盒子，黄色遮挡层和大图片盒子显示；鼠标离开两个盒子隐藏<ul><li>鼠标经过：mouseover</li><li>鼠标离开：mouseout</li><li>显示隐藏：display:block display:none</li></ul></li><li>黄色的遮挡层跟随鼠标移动<ul><li>把鼠标坐标给遮挡曾不合适，因为遮挡层的坐标以父盒子为准</li><li>首先，获得鼠标在盒子的坐标</li><li>其次，把数值给遮挡层的 left 和 top 值</li><li>此时，用到鼠标移动事件，但是还是在小图片盒子内移动</li><li>为了使鼠标在遮罩层的中间，需要减去遮罩层宽高的一半 offsetWidth、offsetHeight获取盒子的宽高</li><li>遮挡层不能超过小盒子的范围（如果小于0，就把坐标设置为0）</li><li>遮挡层最大的移动距离：小图片盒子宽度 减去 遮挡层盒子宽度</li></ul></li><li>移动黄色遮挡层，大图片跟随移动<ul><li>求大图片移动的公式：大图片移动距离 &#x3D; 遮挡层移动的距离 * 大图片最大移动距离 &#x2F; 遮挡层最大移动距离</li><li><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=299" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=299">www.bilibili.com/video/BV1Sy…</a></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .box &#123;</span><br><span class="line">        position: relative;</span><br><span class="line">        width: 502px;</span><br><span class="line">        height: 285px;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .mask &#123;</span><br><span class="line">        display: none;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        width: 150px;</span><br><span class="line">        height: 150px;</span><br><span class="line">        background-color: rgb(235, 238, 82, 0.4);</span><br><span class="line">        /* 鼠标经过变成移动的样式 */</span><br><span class="line">        cursor: move;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .enlarge &#123;</span><br><span class="line">        display: none;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 510px;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 285px;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .enlarge img &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;./img/大数据热点图.jpg&quot; alt=&quot;&quot; class=&quot;img1&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;enlarge&quot;&gt;</span><br><span class="line">        &lt;img src=&quot;./img/大数据热点图.jpg&quot; alt=&quot;&quot; class=&quot;img2&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var box = document.querySelector(&#x27;.box&#x27;)</span><br><span class="line">    var mask = document.querySelector(&#x27;.mask&#x27;);</span><br><span class="line">    var enlarge = document.querySelector(&#x27;.enlarge&#x27;);</span><br><span class="line">    var img1 = document.querySelector(&#x27;.img1&#x27;);</span><br><span class="line"></span><br><span class="line">    // 鼠标经过显示遮罩层和大图片盒子</span><br><span class="line">    box.addEventListener(&#x27;mouseover&#x27;, () =&gt; &#123;</span><br><span class="line">        mask.style.display = &#x27;block&#x27;;</span><br><span class="line">        enlarge.style.display = &#x27;block&#x27;;</span><br><span class="line">    &#125;)</span><br><span class="line">    // 鼠标经过隐藏遮罩层和大图片盒子</span><br><span class="line">    box.addEventListener(&#x27;mouseout&#x27;, () =&gt; &#123;</span><br><span class="line">        mask.style.display = &#x27;none&#x27;;</span><br><span class="line">        enlarge.style.display = &#x27;none&#x27;;</span><br><span class="line">    &#125;)</span><br><span class="line">    // </span><br><span class="line">    box.addEventListener(&#x27;mousemove&#x27;, (e) =&gt; &#123;</span><br><span class="line">        // 先计算出鼠标在盒子内的坐标</span><br><span class="line">        var x = e.pageX - box.offsetLeft;</span><br><span class="line">        var y = e.pageY - box.offsetTop;</span><br><span class="line">        // console.log(x,y);</span><br><span class="line"></span><br><span class="line">        // 把鼠标在盒子内的坐标赋值给遮罩层的left和top值</span><br><span class="line">        // 为了使鼠标在遮罩层的中间，需要减去遮罩层宽高的一半 offsetWidth、offsetHeight获取盒子的宽高</span><br><span class="line">        var maskX = x - mask.offsetWidth / 2;</span><br><span class="line">        var maskY = y - mask.offsetHeight / 2</span><br><span class="line"></span><br><span class="line">        // 遮挡层最大的移动距离：小图片盒子宽度 减去 遮挡层盒子宽度</span><br><span class="line">        var maskXMax = box.offsetWidth - mask.offsetWidth;</span><br><span class="line">        var maskYMax = box.offsetHeight - mask.offsetHeight;</span><br><span class="line">        // console.log(maskXMax, maskYMax);</span><br><span class="line">        if (maskX &lt; 0) &#123;</span><br><span class="line">            maskX = 0</span><br><span class="line">        &#125; else if (maskX &gt;= maskXMax) &#123;</span><br><span class="line">            maskX = maskXMax</span><br><span class="line">        &#125;</span><br><span class="line">        if (maskY &lt; 0) &#123;</span><br><span class="line">            maskY = 0</span><br><span class="line">        &#125; else if (maskY &gt;= maskYMax) &#123;</span><br><span class="line">            maskY = maskYMax</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mask.style.left = maskX + &#x27;px&#x27;;</span><br><span class="line">        mask.style.top = maskY + &#x27;px&#x27;;</span><br><span class="line"></span><br><span class="line">        // 大图片移动距离 = 遮挡层移动的距离 * 大图片最大移动距离 / 遮挡层最大移动距离</span><br><span class="line">        // 大图</span><br><span class="line">        var img2 = document.querySelector(&#x27;.img2&#x27;);</span><br><span class="line">        // 大图片最大移动的距离</span><br><span class="line">        var enlargeMax = img2.offsetWidth - enlarge.offsetWidth;</span><br><span class="line">        // 大突破的移动距离</span><br><span class="line">        var enlargeX = maskX * enlargeMax / maskXMax;</span><br><span class="line">        var enlargeY = maskY * enlargeMax / maskYMax;</span><br><span class="line">        img2.style.left = -enlargeX + &#x27;px&#x27;;</span><br><span class="line">        img2.style.top = -enlargeY + &#x27;px&#x27;;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="元素可视区-client-系列"><a href="#元素可视区-client-系列" class="headerlink" title="元素可视区 client 系列"></a>元素可视区 client 系列</h3><p>client 就是客户端，client 系列的相关属性来获取元素可视区的相关信息。</p><p>通过client系列的相关属性可动态的得到该元素的边框大小、元素大小等</p><table><thead><tr><th>client系列</th><th>说明</th></tr></thead><tbody><tr><td>element.clientTop</td><td>返回元素上边框的大小</td></tr><tr><td>element.clientLeft</td><td>返回元素左边框的大小</td></tr><tr><td>element.clientWidth</td><td>返回自身包括padding、内容的宽度，不含边框，返回的数值不带单位</td></tr><tr><td>element.clientHeight</td><td>返回自身包括padding、内容的高度，不含边框，返回的数值不带单位</td></tr></tbody></table><h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h4><p>立即执行函数：不需要调用，立马能够自己执行的函数，也可以传递参数</p><p>立即执行函数最大的作用：独立创建了一个作用域，里面所有的变量都是局部变量，不会有命名冲突的情况</p><p>两种写法语法：</p><ul><li>(function(){})()</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">   console.log(2) // 2</span><br><span class="line">&#125;)(); // 第二个小括号可看做是调用该函数</span><br><span class="line"></span><br><span class="line">(function(a)&#123;</span><br><span class="line">   console.log(a); // 1</span><br><span class="line">&#125;)(1); // 也可以传参</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>(function(){}())</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    console.log(3); // 3</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">(function sum(a) &#123; // 函数有名字也不影响</span><br><span class="line">    console.log(a); // 4</span><br><span class="line">&#125;(3));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="元素滚动-scroll-系列"><a href="#元素滚动-scroll-系列" class="headerlink" title="元素滚动 scroll 系列"></a>元素滚动 scroll 系列</h3><p>scroll：滚动事件，使用scroll系列的相关属性可动态的得到该元素的大小、滚动的距离等</p><table><thead><tr><th>scroll系列属性</th><th>说明（返回数值都不带单位）</th></tr></thead><tbody><tr><td>element.scrollTop</td><td>返回被卷去的上册距离</td></tr><tr><td>element.scrollLeft</td><td>返回被卷去的左侧距离</td></tr><tr><td>element.scrollWidth</td><td>返回自身实际的宽度，不含边框</td></tr><tr><td>element.scrollHeight</td><td>返回自身实际的高度，不含边框</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 示例</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        overflow: auto;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">    文字文字文字文字文字文字</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var div = document.querySelector(&#x27;div&#x27;);</span><br><span class="line">// scroll 滚动事件，当滚动条发生变化时，会触发该事件</span><br><span class="line">    div.addEventListener(&#x27;scroll&#x27;, () =&gt; &#123;</span><br><span class="line">        console.log(div.scrollTop);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="offset、client、scroll总结"><a href="#offset、client、scroll总结" class="headerlink" title="offset、client、scroll总结"></a>offset、client、scroll总结</h3><p>三个系列都可返回元素的大小，返回值都不带单位</p><table><thead><tr><th>三个系列大小对比</th><th>作用</th></tr></thead><tbody><tr><td>element.offsetWidth</td><td>返回自身包括padding、边框、内容区的宽度</td></tr><tr><td>element.clientWidth</td><td>返回自身包括padding、内容区的库纳杜</td></tr><tr><td>element.scrollWidth</td><td>返回自身实际的宽度，不含边框（包含了文字超出的部分）</td></tr></tbody></table><p>区别：</p><ul><li>offsetWidth 包含了边框</li><li>clientWidth 值返回元素的高度，但是如果元素内容超过了盒子的大小，则用scrollWidth可得到超出</li></ul><p>三个系列的主要用法：</p><ul><li><strong>offset系列</strong>常用于获取元素位置（ <strong>offsetLeft、offsetTop</strong> ）</li><li><strong>client系列</strong>常用于获取元素大小（ <strong>clientWidth、clientHeight</strong> ）</li><li><strong>scroll系列</strong>常用于获取滚动距离（ <strong>scrollTop、scrollLeft</strong> ）</li></ul><p>注意：页面滚动距离通过window.pageXOffset获得</p><h3 id="mouseenter-和-mouseover区别（面试题）"><a href="#mouseenter-和-mouseover区别（面试题）" class="headerlink" title="mouseenter 和 mouseover区别（面试题）"></a>mouseenter 和 mouseover区别（面试题）</h3><p>mouseenter 和 mouseover都是鼠标移动到元素上会触发的事件</p><p>区别：</p><ul><li>mouseenter 鼠标经过只有自身盒子触发，不会冒泡</li><li>mousrover 鼠标经过自身盒子会触发，经过子盒子也会触发</li><li>跟mouseenter搭配鼠标离开mouseleave同样不会冒泡</li></ul><h3 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h3><p>核心原理：通过定时器setInterval()不断移动盒子位置</p><h4 id="盒子移动动画（案例）"><a href="#盒子移动动画（案例）" class="headerlink" title="盒子移动动画（案例）"></a>盒子移动动画（案例）</h4><p>案例分析：</p><ul><li>获取盒子当前位置</li><li>让盒子在当前位置上加上一个移动距离</li><li>利用定时器不断重复这个操作</li><li>加一个结束定时器的条件</li><li>注意此元素需要添加定位，才能使用element.style.left</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .box &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 0;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var box = document.querySelector(&#x27;.box&#x27;);</span><br><span class="line">    var timer = setInterval(() =&gt; &#123;</span><br><span class="line">        // window.innerWidth 当前设备的宽度</span><br><span class="line">        if (box.offsetLeft &gt;= window.innerWidth) &#123;</span><br><span class="line">            // 如果需要停止动画：停止动画的本质是  移除定时器</span><br><span class="line">            // clearInterval(timer);</span><br><span class="line"></span><br><span class="line">            // 如果想让动画移动到设备宽度就从头开始移动，则将left设置为0</span><br><span class="line">            box.style.left = 0</span><br><span class="line">        &#125;</span><br><span class="line">        box.style.left = box.offsetLeft + 5 + &#x27;px&#x27;;</span><br><span class="line">    &#125;, 30)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="动画效果封装"><a href="#动画效果封装" class="headerlink" title="动画效果封装"></a>动画效果封装</h4><p>此方法需要传递两个参数：动画的对象、目标位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 动画的对象obj, 目标位置target</span><br><span class="line">function animate(obj, target) &#123;</span><br><span class="line">    var timer = setInterval(() =&gt; &#123;</span><br><span class="line">        if (obj.offsetLeft &gt;= target) &#123;</span><br><span class="line">            // 如果需要停止动画：停止动画的本质是  移除定时器</span><br><span class="line">            // clearInterval(timer);</span><br><span class="line"></span><br><span class="line">            // 如果想让动画移动到设备宽度就从头开始移动，则将left设置为0</span><br><span class="line">            obj.style.left = 0</span><br><span class="line">        &#125;</span><br><span class="line">        obj.style.left = obj.offsetLeft + 5 + &#x27;px&#x27;;</span><br><span class="line">    &#125;, 30)</span><br><span class="line">&#125;</span><br><span class="line">animate(box, window.innerWidth)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>优化方案：<a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=311" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=311">www.bilibili.com/video/BV1Sy…</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 优化</span><br><span class="line">function animate(obj, target, callback) &#123;</span><br><span class="line">    // 如果需要某个条件才动画，比如点击按钮动画执行，需要先清除一次定时器，</span><br><span class="line">    // 以防按钮不断点击，元素移动的速度越来越快，因为开启了太多的定时器</span><br><span class="line">    // clearInterval(obj.timer); // 先清除以前的定时器，只保留当前的一个定时器</span><br><span class="line">    obj.timer = setInterval(() =&gt; &#123;</span><br><span class="line">        // 步长写在定时器里面</span><br><span class="line">        // 把步长值改为整数,不要出现小数的问题</span><br><span class="line">        // var step = Math.ceil((target - obj.offsetLeft) / 10);</span><br><span class="line">        var step = (target - obj.offsetLeft) / 10;</span><br><span class="line">        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step)</span><br><span class="line"></span><br><span class="line">        if (obj.offsetLeft == target) &#123;</span><br><span class="line">            // 如果需要停止动画：停止动画的本质是  移除定时器</span><br><span class="line">            clearInterval(obj.timer);</span><br><span class="line"></span><br><span class="line">            // 如果想让动画移动到设备宽度就从头开始移动，则将left设置为0</span><br><span class="line">            // obj.style.left = 0</span><br><span class="line"></span><br><span class="line">            // 回调函数写在定时器里面</span><br><span class="line">            if (callback) &#123;</span><br><span class="line">                // 调用传递进来的回调函数</span><br><span class="line">                callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 把每次加1 这个步长值改为一个慢慢变小的值,步长公式:(目标值 - 现在的位置) / 10</span><br><span class="line">        obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;</span><br><span class="line">    &#125;, 30)</span><br><span class="line">&#125;</span><br><span class="line">animate(box, 500, function () &#123;</span><br><span class="line">    // 动画执行完毕后,执行回调函数, 此处代码调用</span><br><span class="line">    box.style.backgroundColor = &#x27;blue&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="常见网页特效案例"><a href="#常见网页特效案例" class="headerlink" title="常见网页特效案例"></a>常见网页特效案例</h3><h4 id="banner轮播"><a href="#banner轮播" class="headerlink" title="banner轮播"></a>banner轮播</h4><p>案例分析：</p><ul><li>鼠标经过（mouseover、mouseenter）轮播模块，左右按钮显示，鼠标离开（mouseout、mouseleave）左右按钮隐藏<ul><li>mouseover 鼠标经过自身盒子会触发，经过子盒子也会触发 ，对应mouseout</li><li>mouseenter 鼠标经过只有自身盒子触发，不会冒泡，对应mouseleave</li><li>显示隐藏按钮display</li></ul></li><li>动态生成导航小圆点<ul><li>核心思路：导航小圆点要跟图片张数一致</li><li>先得到ul里面图片的张数（图片放在li里面，li的个数也就是图片的个数）ul.children.length</li><li>循环动态生成小圆圈（小圆圈放在ol里面）</li><li>创建节点createElemeny(‘li’)</li><li>插入节点 ol.appendChild(li)</li><li>把ol里面的第一个li设置类名为current：表示选中的效果以及表示展示的是第一张图片 ol.children[0].className &#x3D; ‘current’</li><li>给导航小圆点添加点击事件：<strong>排他思想</strong> 干掉其他的li，留下当前点击的li</li></ul></li><li>点击右侧按钮播放下一张图片原理： 点击右侧按钮一次，图片往左播放一张，以此类推。左侧按钮同理<ul><li>声明一个变量num，点击一次，自增1，让这个变量 乘以 图片宽度，就是ul的滚动距离</li><li>图片无缝滚动原理（滚动到最后一张，循环滚动）：把ul第一个li复制一份放到ul的最后面，当图片滚动到复制的最后一张时，让ul快速的，不做动画的跳到最左侧：left为0</li><li>同时num赋值为0，重新开始滚动图片</li></ul></li><li>图片播放的同时，导航小圆点跟随一起变化<ul><li>简单的做法：声明一个变量cricle，每次点击自增1。注意：左侧按钮也需要这个变量，因为要声明全局变量</li><li>但是因为前面克隆了一张图片，现在图片多了一张，而小圆点的个数是之前图片的数量，所以必须加一个判断条件</li><li>如果cricle &#x3D;&#x3D; 之前图片的数量，就重新复原为cricle &#x3D; 0</li></ul></li><li>点击导航小圆点，播放相应的图片<ul><li>点击导航小圆点是ul在移动，而不是ul里面的li（要提前给ul加定位）</li><li>滚动图片的核心算法：点击某个小圆点，就让图片滚动，<strong>导航小圆点的索引号乘以图片的宽度</strong>作为ul移动的距离</li></ul></li><li>鼠标不经过轮播图，轮播图也会自动轮播图片<ul><li>定时器</li><li>自动播放轮播图，实际上类似点击了右侧按钮</li><li>此时使用手动调用右侧按钮点击事件 next.click()</li><li>鼠标经过banner，停止定时器</li><li>鼠标离开banner，开启定时器</li></ul></li></ul><h4 id="带有动画的返回顶部"><a href="#带有动画的返回顶部" class="headerlink" title="带有动画的返回顶部"></a>带有动画的返回顶部</h4><p>滚动窗口至文档中的特定位置：window.scroll(x,y)</p><p>页面滚动了多少：window.pageYOffset</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventlistener(&#x27;click&#x27;, function()&#123;</span><br><span class="line">    // 里面的x,y不跟单位，直接写数字即可</span><br><span class="line">// window.scroll(0, 0)</span><br><span class="line">    animate(window, 0); // 因为是窗口滚动，所以对象是window</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function animate(obj, target, callback) &#123;</span><br><span class="line">    // 如果需要某个条件才动画，比如点击按钮动画执行，需要先清除一次定时器，</span><br><span class="line">    // 以防按钮不断点击，元素移动的速度越来越快，因为开启了太多的定时器</span><br><span class="line">    clearInterval(obj.timer); // 先清除以前的定时器，只保留当前的一个定时器</span><br><span class="line">    obj.timer = setInterval(() =&gt; &#123;</span><br><span class="line">        // 步长写在定时器里面</span><br><span class="line">        // 把步长值改为整数,不要出现小数的问题</span><br><span class="line">        // var step = Math.ceil((target - obj.offsetLeft) / 10);</span><br><span class="line">        var step = (target - window.pageYOffset) / 10;</span><br><span class="line">        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step)</span><br><span class="line"></span><br><span class="line">        if (window.pageYOffset == target) &#123;</span><br><span class="line">            // 如果需要停止动画：停止动画的本质是  移除定时器</span><br><span class="line">            clearInterval(obj.timer);</span><br><span class="line"></span><br><span class="line">            // 如果想让动画移动到设备宽度就从头开始移动，则将left设置为0</span><br><span class="line">            // obj.style.left = 0</span><br><span class="line"></span><br><span class="line">            // 回调函数写在定时器里面</span><br><span class="line">            // if (callback) &#123;</span><br><span class="line">            //     // 调用传递进来的回调函数</span><br><span class="line">            //     callback();</span><br><span class="line">            // &#125;</span><br><span class="line">            callback &amp;&amp; callback();</span><br><span class="line">        &#125;</span><br><span class="line">        // 把每次加1 这个步长值改为一个慢慢变小的值,步长公式:(目标值 - 现在的位置) / 10</span><br><span class="line">        // obj.style.left = obj.offsetLeft + step + &#x27;px&#x27;;</span><br><span class="line">        window.scroll(0,window.pageYOffset + step)</span><br><span class="line">    &#125;, 30)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="本地存储特性"><a href="#本地存储特性" class="headerlink" title="本地存储特性"></a>本地存储特性</h3><p>特性：</p><ul><li>数据存储在用户浏览器中</li><li>设置、读取方便、页面刷新不会丢失数据</li><li>容量较大，sessionStorage约5M、localStorage约20M</li><li>只能存储字符串，可以将对象JSON.stringify()编码后存储</li></ul><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>sessionStorage：</p><ul><li>生命周期为关闭浏览器窗口（关闭浏览器窗口消失）</li><li>在同一个窗口（页面）下数据可共享</li><li>以键值对的形式存储使用</li></ul><p>存储数据：<code>sessionStorage.setItem(key, value)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    var val = inputBox.value</span><br><span class="line">    sessionStorage.setItem(&#x27;userName&#x27;, val)</span><br><span class="line">    sessionStorage.setItem(&#x27;password&#x27;, val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>获取数据：<code>sessionStorage.getItem(key)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    console.log(sessionStorage.getItem(&#x27;userName&#x27;));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除数据：<code>sessionStorage.removeItem(key)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remove.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    sessionStorage.removeItem(&#x27;userName&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除所有数据：<code>sessionStorage.clear()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    sessionStorage.clear()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>localStorage：</p><ul><li>生命周期永久生效，除非手动删除，否则关闭页面也会存在</li><li>可以多窗口（页面）共享（同一浏览器）</li></ul><p>存储数据：<code>localStorage.setItem(key, value)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    var val = inputBox.value</span><br><span class="line">    localStorage.setItem(&#x27;userName&#x27;, val)</span><br><span class="line">    localStorage.setItem(&#x27;password&#x27;, val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>获取数据：<code>localStorage.getItem(key)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    console.log(localStorage.getItem(&#x27;userName&#x27;));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除数据：<code>localStorage.removeItem(key)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remove.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    localStorage.removeItem(&#x27;userName&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除所有数据：<code>localStorage.clear()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    localStorage.clear()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="移动端特效"><a href="#移动端特效" class="headerlink" title="移动端特效"></a>移动端特效</h2><p><a href="https://link.juejin.cn/?target=https://www.bilibili.com/video/BV1Sy4y1C7ha?p=331" title="https://www.bilibili.com/video/BV1Sy4y1C7ha?p=331">www.bilibili.com/video/BV1Sy…</a></p><h3 id="触屏事件"><a href="#触屏事件" class="headerlink" title="触屏事件"></a>触屏事件</h3><p>移动端浏览器兼容性较好，不需要考虑JS的兼容性问题，可放心食用原生js</p><p>移动端也独特的地方，比如：<strong>触屏事件touch（触屏事件）</strong> ，Android和IOS都有</p><p> <strong>touch对象代表一个触摸点</strong> 。触摸点可能是手指，也可能是触摸笔。触屏事件可响应用户对屏幕或触控板的操作</p><p>常见的触屏事件：</p><table><thead><tr><th>触屏touch事件</th><th>说明</th></tr></thead><tbody><tr><td>touchstart</td><td>触摸到DOM元素时触发</td></tr><tr><td>touchmove</td><td>在DOM元素上滑动时触发</td></tr><tr><td>touchend</td><td>在DOM元素上移开时触发</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下内容参考：&lt;a href=&quot;https://juejin.cn/post/7118259341060210701#heading-90&quot;&gt;JavaScript学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Web APIs&lt;/p&gt;
&lt;p&gt;JavaScript基础和Web APIs两个阶</summary>
      
    
    
    
    <category term="前端开发" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://superq314.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    
  </entry>
  
</feed>
